<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ACE - Active Colleague Engagement</title>
<style>
  :root{
    --green:#0b4a2b;
    --green2:#0f5b35;
    --bg:#f3f5f4;
    --card:#ffffff;
    --text:#122018;
    --muted:#6b7a70;
    --line:#d7ded9;
    --danger:#c93a3a;
    --warn:#b07a00;
    --ok:#0b7a3a;
    --shadow:0 8px 28px rgba(0,0,0,.10);
    --radius:14px;
    --radius2:10px;
    --font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    /* Type scale tokens to unify typography across the app.  These values
       provide a consistent rhythm for headings, body text and small
       annotations.  Adjusting these values will cascade throughout
       table headers, modal titles and other elements. */
    --fs-xs: 12px;
    --fs-sm: 14px;
    --fs-md: 16px;
    --fs-lg: 18px;
    --fs-xl: 22px;
    /* Base border radius for interactive elements like buttons.  A
       slightly smaller radius (8px) yields a modern feel without
       becoming overly pill‑shaped. */
    --btn-radius: 8px;
    /* Unified accent variables for easier theming.  Accent colors reference
       existing palette so changing one value updates multiple UI elements.
       `--accent` drives primary actions, `--accent-soft` provides a gentle
       background tint, and `--danger-soft` is a translucent red used for
       validation feedback.  */
    --accent: var(--green);
    --accent-soft: rgba(11,74,43,0.05);
    --danger-soft: rgba(201,58,58,0.15);
    /* Category color tokens used for timeline icons and status chips.  These
       derive from the base palette and provide distinct hues for
       attendance, conduct, restrictions and other events. */
    --cat-attendance: #4caf50;
    --cat-conduct:    #e67e22;
    --cat-restrictions: #e74c3c;
    --cat-other:      #9b59b6;
  }
  *{box-sizing:border-box}
body{
  margin:0;
  font-family:var(--font);
  color:var(--text);
  background:var(--bg);
  /* Use the medium size from our type scale for base text and increase
     line height slightly to improve readability throughout the app. */
  font-size: var(--fs-sm);
  line-height: 1.5;
}
  .topbar{
    position:sticky;top:0;z-index:50;
    /* Apply a gradient on the top bar to harmonize with the login screen's greens */
    background: linear-gradient(180deg, var(--green2) 0%, var(--green) 100%);
    color:#fff;
    padding:14px 18px;
    display:flex;align-items:center;gap:14px;
  }
  /* Top-left logo (animated) */
  .topbarLogo{
    width:40px;
    height:40px;
    flex:0 0 auto;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:12px;
    background:rgba(255,255,255,.12);
    border:1px solid rgba(255,255,255,.20);
    box-shadow:0 8px 18px rgba(0,0,0,.18);
    overflow:hidden;
  }
  .topbarLogo img{
    width:34px;
    height:34px;
    display:block;
    border-radius:10px;
    background:#fff;
    padding:4px;
    object-fit:contain;
    /* 1) pop-in once  2) gentle float loop */
    animation:logoPop .55s cubic-bezier(.2,.9,.2,1) both, logoFloat 3.2s ease-in-out .55s infinite;
    transform-origin:center;
  }
  @keyframes logoPop{
    0%{transform:translateY(-8px) scale(.88);opacity:0}
    60%{transform:translateY(0) scale(1.06);opacity:1}
    100%{transform:translateY(0) scale(1);opacity:1}
  }
  @keyframes logoFloat{
    0%{transform:translateY(0) scale(1)}
    50%{transform:translateY(-2px) scale(1.02)}
    100%{transform:translateY(0) scale(1)}
  }
  @media (prefers-reduced-motion: reduce){
    .topbarLogo img{animation:none}
  }
  .brand{display:flex;flex-direction:column;line-height:1.15}
  .brand b{font-size:18px;letter-spacing:.2px}
  .brand span{font-size:12px;opacity:.85}
  .spacer{flex:1}
  .pill{
    display:flex;align-items:center;gap:8px;
    background:rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.16);
    padding:8px 10px;border-radius:999px;
    font-size:13px
  }
  select, input, textarea, button{
    font-family:inherit;
  }
  .topbar select{
    background:#fff;color:#111;border:0;border-radius:10px;
    padding:6px 8px;font-size:13px
  }
  .topbar button{
    background:#fff;color:#111;border:0;border-radius:10px;
    padding:7px 10px;font-weight:700;cursor:pointer
  }
  .layout{display:grid;grid-template-columns:280px 1fr;gap:14px;padding:14px}
  .sidebar{
    /* Apply a subtle light gradient and softer border/shadow to the sidebar */
    background: linear-gradient(180deg, #f7faf8 0%, #eef3ef 100%);
    border:1px solid rgba(0,0,0,0.05);
    border-radius:var(--radius);
    padding:12px;
    box-shadow:0 4px 12px rgba(0,0,0,0.05);
    height:calc(100vh - 86px);position:sticky;top:72px;overflow:auto
  }
  .sectionTitle{
    font-weight:800;color:#0b2b19;font-size:13px;margin:8px 6px 10px;
    display:flex;align-items:center;justify-content:space-between
  }

  /* Enhance section headings within the colleague profile.  These
     headings (History and Audit log) should appear larger,
     centred and highlighted similarly to the main profile header.
     The background gradient and white text mirror the green header
     palette used elsewhere in the application. */
  .profile-section .sectionTitle{
    display:block;
    text-align:center;
    font-size:15px;
    font-weight:800;
    background: linear-gradient(180deg, var(--green2) 0%, var(--green) 100%);
    color:#fff;
    padding:6px 12px;
    border-radius:var(--radius);
    margin:12px 0;
  }
  .navGroup{margin-bottom:12px}
  .navHeader{
    width:100%;display:flex;align-items:center;justify-content:space-between;
    /* Use the same green gradient as the top bar for consistency */
    background: linear-gradient(180deg, var(--green2) 0%, var(--green) 100%);
    color:#fff;border:0;border-radius:10px;
    padding:10px 10px;font-weight:800;cursor:pointer
  }
  .navList{list-style:none;margin:8px 0 0;padding:0}
  .navList li button{
    width:100%;text-align:left;border:0;
    background:transparent;border-radius:10px;
    padding:9px 10px;cursor:pointer;
    color:#163021
  }
  .navList li button:hover{background:#eef3ef}
  .navList li button.active{background:#e3f0e7;border:1px solid #cfe2d6}
  .content{
    min-height:calc(100vh - 86px);
  }
  .card{
    /* Light gradient and softer border/shadow for cards */
    background: linear-gradient(180deg, #ffffff 0%, #f6faf7 100%);
    border:1px solid rgba(0,0,0,0.05);
    border-radius:var(--radius);
    box-shadow:0 2px 10px rgba(0,0,0,0.05);
    padding:14px;
  }
  /*
    Redesigned card headers to match the dashboard section headers.  Each
    cardHeader now uses the same green background and centred text as the
    dashboard.  The action buttons are positioned absolutely on the right
    so the heading and hint remain centred regardless of button widths.
  */
  .cardHeader{
    position:relative;
    /* Match the green gradient used elsewhere */
    background: linear-gradient(180deg, var(--green2) 0%, var(--green) 100%);
    color:#fff;
    text-align:center;
    font-weight:700;
    padding:12px 16px;
    border-radius:var(--radius2);
    margin-bottom:10px;
  }
  /* Container for the title and hint within the card header */
  .cardHeader .header-text{
    display:block;
  }
  .cardHeader h2{
    margin:0;
    font-size:18px;
    color:#fff;
  }
  /* Lighten the hint text so it contrasts with the dark green header */
  .cardHeader .hint{
    color:rgba(255,255,255,0.85);
    font-size:12px;
    margin-top:4px;
  }
  /* Position action buttons on the right side of the card header */
  .cardHeader .actionsRow{
    position:absolute;
    right:16px;
    top:50%;
    transform:translateY(-50%);
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }

  /* When centrally aligning action buttons (e.g. Data & Backup card) we
     apply the centre-actions class to override the default absolute
     positioning.  This keeps the buttons centred below the title
     regardless of width. */
  .cardHeader .actionsRow.center-actions{
    position:relative;
    right:auto;
    top:auto;
    transform:none;
    display:flex;
    justify-content:center;
    gap:8px;
    flex-wrap:wrap;
    margin-top:8px;
  }
  /* Buttons
     ------------------------------------------------------------------
     Unify the look and feel of all buttons.  A single base style
     drives height, radius, typography and hover transitions.  Primary
     buttons use the accent colour, danger buttons use the danger
     colour and ghost buttons inherit the card background. */
  .btn{
    border: 1px solid var(--line);
    background: #fff;
    border-radius: var(--btn-radius);
    padding: 8px 14px;
    font-weight: 600;
    cursor: pointer;
    font-size: var(--fs-sm);
    line-height: 1.2;
    transition: background-color .2s ease, border-color .2s ease, box-shadow .2s ease;
  }
  .btn.primary{
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  .btn.primary:hover{
    background: var(--green2);
    border-color: var(--green2);
  }
  .btn.ghost{
    background: var(--card);
  }
  .btn.danger{
    background: var(--danger);
    border-color: var(--danger);
    color: #fff;
  }
  .btn.danger:hover{
    background: #b02f2f;
    border-color: #b02f2f;
  }
  .btn.small{
    padding: 6px 10px;
    font-size: var(--fs-xs);
    border-radius: var(--btn-radius);
  }

  /* Loading state for buttons.  When a button has the `.loading` class
     applied, it becomes semi-transparent and shows a spinner overlay.
     Use `btn.classList.add('loading')` in JavaScript to trigger this
     behaviour.  The `::after` pseudo-element draws the spinner.  */
  .btn.loading {
    position: relative;
    pointer-events: none;
    opacity: 0.7;
  }
  .btn.loading::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    width: 18px;
    height: 18px;
    margin: -9px 0 0 -9px;
    border: 2px solid rgba(255,255,255,0.6);
    border-top-color: rgba(255,255,255,1);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Focus ring for interactive elements (inputs, selects, buttons).
     Provide a consistent outline on keyboard navigation to improve
     accessibility.  */
  input:focus, select:focus, button:focus {
    outline: 2px solid var(--green2);
    outline-offset: 2px;
  }

  /* Validation styling for login inputs.  When an input is focused
     and invalid, highlight it with the danger colour.  When valid,
     highlight with the ok colour.  */
  #login-form input:focus:invalid {
    border-color: var(--danger);
    box-shadow: 0 0 0 2px var(--danger-soft);
  }
  #login-form input:focus:valid {
    border-color: var(--ok);
    box-shadow: 0 0 0 2px rgba(11, 122, 58, 0.2);
  }
  /* Show subtle red border for invalid inputs after user leaves the field. */
  #login-form input:invalid:not(:focus) {
    /* Keep the default border colour when the field has not been interacted
       with.  Without this rule the inputs would appear red on initial load. */
    border-color: var(--line);
  }

  /* Tagline styling beneath the login header to succinctly describe
     the purpose of ACE.  The italic style conveys a friendly tone
     without drawing too much attention. */
  .login-header .tagline {
    margin-top: 4px;
    font-size: 13px;
    color: var(--muted);
    font-style: italic;
    text-align: center;
  }

  /* Simple banner styles for future success/error messages.  Use the
     `.banner.success` or `.banner.error` classes on a div to display
     contextual messages across pages. */
  .banner {
    padding: 10px 14px;
    border-radius: 8px;
    margin-bottom: 12px;
    font-size: 14px;
  }
  .banner.success {
    background: var(--accent-soft);
    color: var(--green2);
    border: 1px solid var(--accent);
  }
  .banner.error {
    background: var(--danger-soft);
    color: var(--danger);
    border: 1px solid var(--danger);
  }

  /* Style for colleague name links.  They behave like hyperlinks but keep the
     bold weight. */
  .col-link{
    cursor:pointer;
    text-decoration:underline;
    color:var(--green);
  }

  /* Center the summary chart canvas horizontally */
  .chart-container canvas{
    display:block;
    margin:0 auto;
  }
  /* Legend styling for the line chart */
  .chart-legend{
    margin-top:8px;
    display:flex;
    flex-wrap:wrap;
    justify-content:center;
    gap:12px;
    font-size:12px;
  }
  .chart-legend div{
    display:flex;
    align-items:center;
    gap:4px;
  }
  .chart-legend span.dot{
    width:12px;
    height:12px;
    border-radius:50%;
    display:inline-block;
  }
  .filters{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0 12px}
  .filters label{display:flex;flex-direction:column;gap:6px;font-size:12px;color:var(--muted)}
  .filters select,.filters input{
    padding:9px 10px;border-radius:10px;border:1px solid var(--line);
    background:#fff;min-width:220px
  }
  table{width:100%;border-collapse:separate;border-spacing:0}
th,td{
  border-bottom:1px solid var(--line);
  padding:10px 10px;
  font-size: var(--fs-sm);
  line-height: 1.4;
  vertical-align: top;
}
th{
  position: sticky;
  top: 0;
  background: #fff;
  z-index: 5;
  text-align: left;
  /* Use the smallest type scale for headers and apply medium weight
     to make headings distinct without overpowering the content. */
  font-size: var(--fs-xs);
  font-weight: 600;
  color: var(--text);
  border-bottom: 2px solid var(--line);
}
/* On row hover gently tint the background using the accent‑soft colour.
   This reinforces that rows are interactive without adding harsh contrast. */
tr:hover td{
  background: var(--accent-soft) !important;
}
  .muted{color:var(--muted)}
  .tag{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border-radius:999px;font-size:12px;border:1px solid var(--line);background:#f7faf8}
  .tag.ok{border-color:#bfe5ce;background:#eaf8f0;color:#0b5b2f}
  .tag.warn{border-color:#ecd6a8;background:#fff7e6;color:#7a5400}
  .tag.bad{border-color:#f0b7b7;background:#ffecec;color:#7a0b0b}

  /* Row colouring for due dates and zebra striping */
  /* Apply !important to ensure date highlighting overrides zebra striping */
  tbody tr.overdue td { background: #fff2f2 !important; }
  tbody tr.due-soon td { background: #fff8e6 !important; }
  tbody tr.due-today td { background: #fffbe6 !important; }
  tbody tr:nth-child(odd) td { background-color: #fbfdfc; }
  tbody tr:nth-child(even) td { background-color: #f8fbf9; }

  /* Section headers for dashboard sections */
  .section-header{
    background: var(--green2);
    color: #fff;
    text-align: center;
    font-weight: 700;
    padding: 8px 12px;
    border-radius: var(--radius2);
    margin: 16px 0 8px;
    position: relative;
  }
  /* Export button group positioned within a section header */
  .section-header .export-group{
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    gap: 6px;
  }

  /* Chart tooltip styling */
  .chart-tooltip{
    position:absolute;
    background:rgba(0,0,0,.75);
    color:#fff;
    padding:6px 8px;
    border-radius:8px;
    font-size:12px;
    pointer-events:none;
    white-space:nowrap;
    z-index:10;
    box-shadow:0 2px 8px rgba(0,0,0,.2);
  }
  /* Legend for the summary chart */
  .chart-legend{
    display:flex;
    flex-wrap:wrap;
    justify-content:center;
    gap:12px;
    margin-top:10px;
    font-size:12px;
    color:var(--text);
  }
  .chart-legend .legend-item{
    display:flex;
    align-items:center;
    gap:4px;
  }
  .chart-legend .legend-color{
    width:12px;
    height:12px;
    border-radius:3px;
    flex-shrink:0;
  }
  /* Ensure the summary chart fills its container and has a sensible height */
  .chart-container canvas{
    width:100% !important;
    height:220px !important;
  }
  /* Print styles: hide sidebar and topbar, hide controls and export buttons for cleaner PDF export */
  @media print{
    .topbar,.sidebar,.dashboard-controls,.btn.small,.chart-legend{display:none !important;}
    body{background:#fff;}
    .layout{grid-template-columns:1fr !important;padding:0 !important;}
    .dashboard{padding:0 !important;}
    h3{margin-top:12px;}
  }
  /* Modal */
  .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:100}
  .backdrop.show{display:flex}

  /* Modal animations: slide down and fade in/out.  The modal starts
     slightly above its final position and transparent; when the
     backdrop's `.show` class is applied the modal slides into place
     and fades in.  Closing the modal simply reverses the class
     change, allowing the transition to run backwards before the
     element is removed from the DOM. */
  .backdrop .modal{
    transform: translateY(-20px);
    opacity: 0;
    transition: transform 0.3s ease, opacity 0.3s ease;
  }
  .backdrop.show .modal{
    transform: translateY(0);
    opacity: 1;
  }
  .modal{
    width:min(720px, 94vw);
    background:#fff;border-radius:18px;border:1px solid #d9dfdb;
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .modalHeader{
    display:flex;align-items:center;justify-content:space-between;
    padding:14px 16px;background:#f7faf8;border-bottom:1px solid var(--line)
  }
  .modalHeader b{
    /* Use a larger font size for modal titles to clearly separate them
       from body content.  This draws attention to the purpose of the
       dialog without dominating the layout. */
    font-size: var(--fs-lg);
    font-weight: 700;
  }
  .modalBody{
    padding:16px;
    max-height:min(72vh, 680px);
    overflow:auto;
    /* Match the base font size and line height for modal content
       to improve readability, especially in long forms. */
    font-size: var(--fs-sm);
    line-height: 1.5;
  }
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .field{display:flex;flex-direction:column;gap:6px}
  .field label{
    font-size: var(--fs-xs);
    color: var(--muted);
  }
  .field input,
  .field select,
  .field textarea{
    padding: 10px 10px;
    border-radius: var(--btn-radius);
    border: 1px solid var(--line);
    background: #fff;
    font-size: var(--fs-sm);
  }
  .field textarea{min-height:90px;resize:vertical}
  .modalFooter{display:flex;gap:10px;justify-content:flex-end;padding:14px 16px;border-top:1px solid var(--line);background:#fff}
  .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}

  /* Group heading styling for Upcoming/Completed actions */
  .group-heading{
    background: var(--green2);
    color: #fff;
    padding: 6px 10px;
    border-radius: 8px;
    text-align: center;
    margin-top: 12px;
    margin-bottom: 6px;
    /* Use larger font and bold weight so section headings stand out */
    font-size: 18px;
    font-weight: bold;
  }

  /* Table alignment for Upcoming and Completed actions.  These classes enforce
     consistent column widths, prevent wrapping, and align action buttons. */
  .upcoming-table, .completed-logs-table, .absences-table {
    table-layout: fixed;
    width: 100%;
    border-collapse: collapse;
  }
  .upcoming-table th, .upcoming-table td,
  .completed-logs-table th, .completed-logs-table td,
  .absences-table th, .absences-table td {
    padding: 8px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  /* Column widths for Upcoming actions: Colleague, Details, Due, Action */
  .upcoming-table td:nth-child(1) { width: 32%; }
  .upcoming-table td:nth-child(2) { width: 28%; }
  .upcoming-table td:nth-child(3) { width: 25%; }
  .upcoming-table td:nth-child(4) { width: 15%; text-align: center; }
  /* Column widths for Completed logs: Colleague, Details, Completed, Actions */
  .completed-logs-table td:nth-child(1) { width: 35%; }
  .completed-logs-table td:nth-child(2) { width: 35%; }
  .completed-logs-table td:nth-child(3) { width: 15%; }
  .completed-logs-table td:nth-child(4) { width: 15%; text-align: center; }
  /* Column widths for Completed absences: Colleague, Start, Reason, Sanction, Return, Logged, Actions */
  .absences-table td:nth-child(1) { width: 20%; }
  .absences-table td:nth-child(2) { width: 15%; }
  .absences-table td:nth-child(3) { width: 15%; }
  .absences-table td:nth-child(4) { width: 15%; }
  .absences-table td:nth-child(5) { width: 15%; }
  .absences-table td:nth-child(6) { width: 10%; }
  .absences-table td:nth-child(7) { width: 10%; text-align: center; }
  .loginWrap{
    min-height:100vh;display:grid;place-items:center;padding:20px
  }
  .loginCard{
    width:min(460px, 92vw);
    background:#fff;border:1px solid var(--line);border-radius:18px;box-shadow:var(--shadow);
    overflow:hidden
  }
  .loginTop{background:var(--green);color:#fff;padding:18px 18px}
  .loginTop b{font-size:18px}
  .loginTop div{opacity:.9;font-size:12px;margin-top:2px}
  .loginBody{padding:16px 18px}
  .loginBody .field input{font-size:14px}
  .loginErr{display:none;margin-top:10px;padding:10px 12px;border-radius:12px;background:#ffecec;border:1px solid #f0b7b7;color:#7a0b0b;font-size:13px}

  /* === Login (tidy contained square card) === */
  #login-screen{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:22px;
    /* New multi-layer background: diagonal gradient, soft spotlight, and subtle texture */
    background:
      radial-gradient(
        600px 300px at 50% 40%,
        rgba(11, 74, 43, 0.08),
        transparent 70%
      ),
      linear-gradient(
        135deg,
        #ffffff 0%,
        #f2f6f4 30%,
        #0b4a2b 100%
      ),
      repeating-linear-gradient(
        45deg,
        rgba(11, 74, 43, 0.02) 0 1px,
        transparent 1px 6px
      );
    position:relative;
    overflow:hidden;
  }
  .login-card{
    width:420px; /* locked size */
    max-width:92vw;
    border-radius:18px;
    /* Lighten the border and strengthen the drop shadow to lift the card off the darker gradient */
    border:1px solid rgba(255,255,255,0.25);
    box-shadow:0 18px 55px rgba(0,0,0,.15);
    /* Apply a subtle green-tinted gradient to give the card depth */
    background: linear-gradient(180deg, #f6faf7 0%, #ffffff 60%);
    overflow:hidden;
    position:relative;
  }
  /* faded image behind the form */
  .login-card::before{
    content:"";
    position:absolute;
    inset:0;
    /* Embed the ACE logo directly as an inline SVG so no external image file is needed */
    background: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230b4a2b'/><text x='32' y='41' font-family='Arial,Helvetica,sans-serif' font-size='28' text-anchor='middle' fill='white' font-weight='700'>ACE</text></svg>") center 18px/180px no-repeat;
    opacity:.06;
    pointer-events:none;
  }
  /* Large ghost ACE logo watermark layered behind everything */
  #login-screen::before{
    content:"";
    position:absolute;
    inset:0;
    background:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230b4a2b'/><text x='32' y='41' font-family='Arial,Helvetica,sans-serif' font-size='28' text-anchor='middle' fill='white' font-weight='700'>ACE</text></svg>") center / 500px no-repeat;
    opacity:0.05;
    pointer-events:none;
  }
  .login-header{
    position:relative;
    padding:16px 18px 12px;
    border-bottom:1px solid var(--line);
    text-align:center;
    background:linear-gradient(180deg, rgba(19,107,64,.10) 0%, rgba(255,255,255,.0) 100%);
  }
  .login-header img{
    display:block;
    margin:2px auto 10px;
    max-width:180px;
    max-height:70px;
    width:auto;
    height:auto;
    object-fit:contain;
  }
  .login-header h1{
    margin:0;
    font-size:16px;
  }
  .login-header .welcome{
    margin:6px 0 0;
    font-weight:800;
    font-size:18px;
    color:var(--text);
  }
  .login-header p{
    margin:6px 0 0;
    font-size:12px;
    color:var(--muted);
  }
  #login-form{
    position:relative;
    /* Light tinted panel behind the login fields */
    background: rgba(11, 74, 43, 0.03);
    border-radius: 14px;
    box-shadow: inset 0 2px 6px rgba(11, 74, 43, 0.08);
    padding:16px;
    /* Add a light border to distinguish the panel against the gradient */
    border: 1px solid rgba(255,255,255,0.3);
  }
  #login-form .form-group{margin-bottom:12px}
  #login-form input{
    width:100%;
    padding:10px 10px;
    border-radius:10px;
    border:1px solid var(--line);
    font-size:14px;
    transition: box-shadow 0.15s ease, border-color 0.15s ease;
  }
  #login-form input:focus{
    outline:none;
    border-color: rgba(11, 74, 43, 0.4);
    box-shadow: 0 0 0 2px rgba(11, 74, 43, 0.2), 0 0 0 4px rgba(11, 74, 43, 0.1);
  }
  #login-form button{
    width:100%;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
  }
  #login-form button:hover{
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
  .login-footer-note{margin-top:10px;font-size:12px;color:var(--muted);text-align:center}
  @media (max-width: 960px){
    .layout{grid-template-columns:1fr}
    .sidebar{position:relative;top:0;height:auto}
    th{position:static}
    .grid{grid-template-columns:1fr}
  }

/* === Disable bold text globally === */
b, strong {
  font-weight: 400 !important;
}


/* === Disable bold text on buttons === */
button, .btn {
  font-weight: 400 !important;
}

  /* ========================= */
  /* Additional UI enhancements */
  /* ========================= */

  /* Search bar styling */
  .search-wrapper {
    position: relative;
    flex: 1 1 250px;
    max-width: 250px;
  }
  .search-wrapper input {
    width: 100%;
    padding: 6px 28px 6px 10px;
    border: 1px solid var(--line);
    border-radius: 8px;
    font-size: 14px;
  }
  .search-wrapper input:focus {
    border-color: var(--green);
    box-shadow: 0 0 0 2px rgba(11, 74, 43, 0.2);
  }
  .search-wrapper .search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: var(--card);
    border: 1px solid var(--line);
    border-top: none;
    border-radius: 0 0 8px 8px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 30;
  }
  .search-results button {
    display: block;
    width: 100%;
    text-align: left;
    padding: 6px 10px;
    border: none;
    background: none;
    cursor: pointer;
    font-size: 14px;
    color: var(--text);
  }
  .search-results button:hover {
    background: var(--accent-soft);
  }

  /* Quick Add button and menu */
  .quick-add-container {
    position: relative;
    /* Increase spacing to harmonise with other controls */
    margin-left: 16px;
  }
  /* Specific rule for the quick add button to override the generic
     `.topbar button` styles.  We qualify it with `.topbar` to ensure
     it takes precedence. */
  .topbar .quick-add-btn {
    /* Increase size and adjust styling for better prominence */
    width: 40px;
    height: 40px;
    font-size: 26px;
    line-height: 38px;
    border-radius: 10px !important;
    /* Use a translucent white background so the button stands out against the
       dark gradient top bar without being overly stark. */
    background: rgba(255, 255, 255, 0.35) !important;
    border: 1px solid rgba(255, 255, 255, 0.5) !important;
    color: var(--green) !important;
    text-align: center;
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    transition: background .2s ease, color .2s ease, transform .1s ease;
  }

  /* Hover and active states for the quick add button */
  .topbar .quick-add-btn:hover {
    /* Invert colours on hover for stronger affordance */
    background: var(--accent) !important;
    color: #ffffff !important;
    border-color: var(--accent) !important;
  }
  .topbar .quick-add-btn:active {
    transform: scale(0.95);
  }
  .quick-add-menu {
    position: absolute;
    top: 100%;
    right: 0;
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.08);
    margin-top: 4px;
    z-index: 40;
    display: flex;
    flex-direction: column;
    min-width: 150px;
  }
  .quick-add-menu button {
    padding: 8px 12px;
    border: none;
    background: none;
    text-align: left;
    cursor: pointer;
    font-size: 14px;
    color: var(--text);
    background: none;
  }
  .quick-add-menu button:hover {
    background: var(--accent-soft);
  }

  /* Breadcrumb and last updated indicator */
  .breadcrumb {
    padding: 8px 12px;
    font-size: 14px;
    color: var(--green2);
    background: var(--bg);
    border-bottom: 1px solid var(--line);
  }
  .last-updated {
    padding: 4px 12px;
    font-size: 12px;
    color: var(--muted);
    text-align: right;
    background: var(--bg);
  }

  /* Recently viewed colleagues section no longer uses bespoke styling.  Instead,
     the recents group adopts the same navList and navHeader styles as other
     sidebar sections.  The Quick Add label styling ensures the text next to
     the plus icon remains legible on the top bar. */
  .quick-add-container{
    display:flex;
    align-items:center;
  }
  .quick-add-label{
    margin-left:6px;
    font-size:14px;
    color:rgba(255,255,255,0.8);
    user-select:none;
  }

  /* Active nav item highlight and icons */
  .navList button.active {
    background: var(--accent-soft);
    color: var(--green2);
  }
  .navList button {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .navList button .nav-icon {
    width: 12px;
    height: 12px;
    display: inline-block;
    background: var(--green);
    border-radius: 50%;
    opacity: 0.6;
  }

  /* Table zebra stripes and hover highlight */
  table tbody tr:nth-child(even) {
    background: #f6faf7;
  }
  table tbody tr:hover {
    background: var(--accent-soft);
  }

  /* Sticky dashboard controls */
  .dashboard-controls {
    position: sticky;
    top: 68px;
    z-index: 20;
    background: var(--bg);
    padding-top: 4px;
    padding-bottom: 4px;
  }

  /* Toast container and toast styling */
  .toast-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 100;
  }
  /* Toasts
     ------------------------------------------------------------------
     Notification pop‑ups appear in the bottom right corner with a
     subtle slide‑in animation.  They have generous padding, larger
     radius and optional icon support.  A light left border coloured
     with the accent conveys success. */
  @keyframes toastIn {
    from {
      transform: translateX(100%);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
  .toast {
    background: var(--card);
    border: 1px solid var(--line);
    border-left: 4px solid var(--accent);
    border-radius: 12px;
    padding: 12px 16px;
    margin-top: 10px;
    box-shadow: 0 6px 12px rgba(0,0,0,0.12);
    display: flex;
    align-items: center;
    gap: 8px;
    animation: toastIn 0.5s ease forwards;
  }
  .toast .toast-icon {
    font-size: 18px;
    color: var(--accent);
    margin-right: 6px;
    line-height: 1;
  }
  .toast .toast-msg {
    flex: 1;
    font-size: var(--fs-sm);
  }
  .toast .toast-undo {
    color: var(--green2);
    cursor: pointer;
    text-decoration: underline;
    font-size: var(--fs-sm);
  }

  /* Dashboard enhancements */
  .dashboard{display:flex;flex-direction:column;gap:22px;}
  .dashboard-kpis{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px;}
  .kpi-card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);box-shadow:0 4px 8px rgba(0,0,0,.05);padding:12px;}
  .kpi-card .label{font-size:12px;color:var(--muted);}
  .kpi-card .number{font-size:26px;font-weight:700;margin:4px 0;}
  .kpi-card .trend{font-size:11px;}
  .kpi-card .trend.up{color:var(--ok);}
  .kpi-card .trend.down{color:var(--danger);}
  .priority-list{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);padding:12px;}
  /* Container for each priority section to separate next/overdue lists */
  .dash-section{margin-bottom:20px;}
  .priority-item{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--line);}
  .priority-item:last-child{border-bottom:0;}
  .priority-item .info{display:flex;flex-direction:column;}
  .priority-item .info .name{font-weight:600;}
  .priority-item .badge{font-size:11px;padding:2px 6px;border-radius:6px;}
  .badge.danger{background:rgba(201,58,58,.15);color:var(--danger);}
  .badge.warn{background:rgba(176,122,0,.15);color:var(--warn);}
  .badge.ok{background:rgba(11,122,58,.15);color:var(--ok);}
  .activity-bars{display:flex;flex-direction:column;gap:8px;}
  .activity-bar{display:flex;flex-direction:column;gap:4px;}
  .activity-bar .labelRow{display:flex;justify-content:space-between;font-size:12px;}
  .activity-bar .barOuter{width:100%;height:8px;background:var(--line);border-radius:4px;overflow:hidden;}
  .activity-bar .barInner{height:100%;width:0;background:var(--ok);transition:width .3s ease;}
  .dept-table{width:100%;border-collapse:collapse;}
  .dept-table th,.dept-table td{text-align:left;padding:8px;border-bottom:1px solid var(--line);font-size:13px;}
  .dept-table th{background:#f9fbfa;font-weight:600;}
  .risk-table{width:100%;border-collapse:collapse;}
  .risk-table th,.risk-table td{text-align:left;padding:8px;border-bottom:1px solid var(--line);font-size:13px;}
  .risk-table th{background:#f9fbfa;font-weight:600;}
  .risk-tag{display:inline-block;background:var(--line);color:var(--text);border-radius:6px;padding:2px 6px;font-size:11px;margin-right:4px;}

  /* Needs attention list styling */
  .attention-list{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);padding:12px;display:flex;flex-direction:column;gap:16px;}
  .attention-group{}
  .attention-title{font-weight:600;font-size:14px;margin-bottom:4px;color:var(--text);}  
  .att-item{padding:6px 0;border-bottom:1px solid var(--line);cursor:pointer;}
  .att-item:last-child{border-bottom:0;}
  .att-item:hover{background:rgba(0,0,0,0.04);} /* subtle hover */

  /* Dashboard control toggles */
  .dashboard-controls{display:flex;justify-content:space-between;flex-wrap:wrap;gap:10px;margin-bottom:10px;}
  .range-toggle, .focus-toggle{display:flex;gap:6px;margin:6px 0;flex-wrap:wrap;}
  .range-toggle button, .focus-toggle button{padding:4px 8px;border:1px solid var(--line);border-radius:8px;background:var(--card);cursor:pointer;font-size:12px;}
  .range-toggle button.active, .focus-toggle button.active{background:var(--green);color:#fff;border-color:var(--green);}
  .kpi-card svg{width:18px;height:18px;margin-right:6px;flex:0 0 auto;color:var(--green2);}  
  .kpi-card-header{display:flex;align-items:center;}

  /* Make KPI cards interactive when they have a target tab.  Provide hover and focus effects */
  .kpi-card[data-tab]{cursor:pointer;transition:transform .2s ease, box-shadow .2s ease;}
  .kpi-card[data-tab]:hover{transform:translateY(-2px);box-shadow:0 6px 12px rgba(0,0,0,.08);}  
  .range-toggle button, .focus-toggle button{transition:background .2s ease,color .2s ease;}
  /* Settings page styling */
  .settings{
    max-width:600px;
    margin:0 auto;
    padding:12px;
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:0 2px 4px rgba(0,0,0,0.05);
  }
  .settings h2{
    margin:0 0 12px 0;
    font-size:20px;
    color:var(--text);
  }
  .settings-form{
    display:flex;
    flex-direction:column;
    gap:16px;
  }
  .settings-form .form-row{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .settings-form label{
    font-weight:600;
    color:var(--text);
  }
  .settings-form input[type="number"]{
    padding:6px 10px;
    border:1px solid var(--line);
    border-radius:8px;
    background:#fff;
    width:100%;
    font-size:14px;
  }

  /* Manager filter styling on the dashboard controls */
  .manager-filter{
    display:flex;
    align-items:center;
    gap:4px;
    font-size:12px;
    margin:6px 0;
  }
  .manager-filter label{
    font-weight:500;
    color:var(--text);
  }
  .manager-filter select{
    padding:4px 8px;
    border:1px solid var(--line);
    border-radius:8px;
    background:var(--card);
    font-size:12px;
    cursor:pointer;
  }

  /* Quick actions bar appears below the KPI cards on the dashboard.  Display the
     buttons inline with consistent spacing and wrap when necessary for small
     screens. */
  .quick-actions{
    display:flex;
    gap:10px;
    margin:10px 0 20px;
    flex-wrap:wrap;
  }
  /* Badge that displays counts beside section headings.  Use rounded corners and
     subtle background colours reflecting the urgency. */
  .badge-count{
    font-size:12px;
    padding:2px 6px;
    border-radius:999px;
    margin-left:6px;
    font-weight:700;
    vertical-align:middle;
  }
  .badge-count.warn{
    background:rgba(176,122,0,.15);
    color:var(--warn);
  }
  .badge-count.danger{
    background:rgba(201,58,58,.15);
    color:var(--danger);
  }

  /* Profile modal styles */
  .profile-tabs .tab-buttons{
    display:flex;
    gap:6px;
    margin-bottom:8px;
    flex-wrap:wrap;
  }
  .profile-tabs .tab-btn{
    padding:6px 12px;
    border:1px solid var(--line);
    border-radius:8px;
    background:var(--card);
    cursor:pointer;
    font-size:var(--fs-xs);
    /* Prevent tab text from being clipped or collapsed.  Ensures labels like
       "Audit" remain visible even in flex layouts. */
    white-space: nowrap;
    overflow: visible;
    /* Explicitly set text colour for inactive tab buttons to avoid inheritance
       issues that could render the label invisible. */
    color: var(--text);
  }
  /* Use pseudo-elements to insert tab labels based on data-tab attribute.  This
     avoids issues where inner text may not render correctly in some cases. */
  .profile-tabs .tab-btn[data-tab="history"]::before{ content:"History"; }
  .profile-tabs .tab-btn[data-tab="audit"]::before{ content:"Audit"; }
  .profile-tabs .tab-btn span{ display:none; }
  .profile-tabs .tab-btn.active{
    background:var(--primary);
    color:#fff;
  }
  .profile-tabs .tab-content{
    display:none;
    margin-top:6px;
  }
  .profile-tabs .tab-content.active{
    display:block;
  }
  .profile-summary{
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(160px,1fr));
    gap:12px;
    margin-bottom:12px;
  }
  /* Highlight summary fields that represent risks (e.g. overdue restrictions).  */
  .profile-summary .field.danger{
    border-color: var(--danger);
  }
  .profile-summary .field.danger input{
    color: var(--danger);
    font-weight:700;
  }
  .profile-summary .field{
    background:var(--card);
    border:1px solid var(--line);
    border-radius:12px;
    padding:10px;
  }
  .profile-summary .field input{
    border:none;
    background:transparent;
    pointer-events:none;
    font-size:var(--fs-md);
    font-weight:600;
    padding:0;
    color:var(--text);
  }
  .profile-summary .field label{
    font-size:var(--fs-xs);
    color:var(--muted);
    margin-bottom:4px;
  }
  .tab-actions{
    margin-bottom:8px;
  }
  .tab-actions .btn{
    margin-right:4px;
  }

  /* Status strip for the colleague profile.  Displays chips summarising
     key conditions such as overdue reviews, open investigations or
     high absence.  Chips inherit their colour from inline styles. */
  .status-strip{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin:8px 0;
  }
  .status-chip{
    display:inline-block;
    padding:3px 8px;
    border-radius:999px;
    font-size:12px;
    font-weight:600;
    color:#fff;
  }

  /* Meta information under the summary, providing last updated and
     provenance details.  Rendered in a small muted style. */
  .profile-meta{
    margin-top:4px;
    font-size: var(--fs-xs);
    color: var(--muted);
    display:flex;
    flex-wrap:wrap;
    gap:12px;
  }

  /* Insights card within the colleague profile.  Provides trends,
     common reasons and next-step recommendations in a distinct
     highlighted panel. */
  .profile-insights{
    border-left:4px solid var(--green);
    background:#f7faf8;
    padding:12px;
    border-radius:12px;
    margin-top:12px;
  }
  .profile-insights h4{
    margin:0 0 6px;
    font-size:var(--fs-md);
    font-weight:700;
    color: var(--text);
  }
  .profile-insights p{
    margin:4px 0;
    font-size:var(--fs-sm);
    color: var(--muted);
  }

  /* Timeline filter bar allows users to filter history items by
     category.  Active button receives the accent colour. */
  .timeline-filter{
    margin-bottom:8px;
    display:flex;
    gap:6px;
    flex-wrap:wrap;
  }
  .timeline-filter .btn{
    font-size:12px;
    padding:4px 8px;
  }
  .timeline-filter .btn.active{
    background: var(--green2);
    color: #fff;
  }

  /* Month group header within the history timeline.  Introduces
     chronological grouping for better scan-ability. */
  .timeline-month{
    margin-top:16px;
    margin-bottom:8px;
    font-weight:700;
    color: var(--text);
    font-size: var(--fs-sm);
  }

  /* Timeline entry styling.  Each entry card lifts slightly on hover
     and uses a coloured dot to signify category. */
  .timeline-entry{
    border:1px solid var(--line);
    border-radius:12px;
    padding:8px;
    margin-bottom:8px;
    background:#fff;
    transition:box-shadow 0.15s ease, transform 0.15s ease;
  }
  .timeline-entry:hover{
    transform: translateY(-2px);
    box-shadow:0 3px 6px rgba(0,0,0,0.08);
  }
  .timeline-entry-head{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }
  .timeline-entry-body{
    margin-top:6px;
    color: var(--muted);
    font-size: var(--fs-sm);
    white-space: pre-wrap;
  }
  .timeline-icon{
    display:inline-block;
    width:8px;
    height:8px;
    border-radius:50%;
    margin-right:6px;
    margin-top:3px;
  }

  /* Empty state panel used when no history or audit log entries exist.
     Offers suggested next actions and a friendly message. */
  .empty-state{
    border:1px solid var(--line);
    border-radius:12px;
    background:#f7faf8;
    padding:16px;
    text-align:center;
    margin-top:8px;
  }
  .empty-state p{
    margin:4px 0;
    color: var(--muted);
    font-size: var(--fs-sm);
  }
  .empty-state .actions{
    margin-top:12px;
    display:flex;
    flex-wrap:wrap;
    gap:6px;
    justify-content:center;
  }
  .empty-state .actions .btn{
    font-size:12px;
    padding:4px 10px;
  }

  /* Micro-interactions: subtle hover and active states for buttons and
     fields to give a more tactile feel. */
  .btn{
    transition: background-color 0.15s ease, color 0.15s ease, transform 0.1s ease;
  }
  .btn:hover{
    box-shadow:0 2px 5px rgba(0,0,0,0.1);
  }
  .btn:active{
    transform: translateY(1px);
  }
  .field:hover{
    box-shadow:0 1px 4px rgba(0,0,0,0.05);
  }

</style>
</head>
<body>

<!-- Login screen (keeps the same visuals as your original ACE build) -->
<section id="login-screen">
  <div class="login-card">
    <div class="login-header">
      <!-- Updated login screen logo to align with the ACE branding used in the main UI. Embed the SVG directly so no external image file is required -->
      <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230b4a2b'/><text x='32' y='41' font-family='Arial,Helvetica,sans-serif' font-size='28' text-anchor='middle' fill='white' font-weight='700'>ACE</text></svg>" alt="ACE Logo" />
      <h1>ACE - Active Colleague Engagement</h1>
      <div class="welcome">Welcome to ACE</div>
      <p>Secure access for authorised warehouse management only.</p>
      <!-- Tagline describing the purpose of the platform -->
      <p class="tagline">Attendance, clarity, engagement.</p>
    </div>
    <form id="login-form">
      <div class="form-group">
        <label for="username">Username</label>
        <input id="username" name="username" required autocomplete="username" />
      </div>
      <div class="form-group">
        <label for="password">Password</label>
        <input id="password" name="password" type="password" required autocomplete="current-password" />
      </div>
      <div class="text-right" style="margin-top:8px">
        <!-- Use a submit button so the form's submit handler triggers when clicked -->
        <button type="submit" id="login-btn" class="btn primary">Log in</button>
      </div>
      <div class="login-footer-note">For internal use only. Do not share colleague data outside authorised channels.</div>
      <div class="loginErr" id="login-error" style="display:none">Invalid username or password.</div>
    </form>
  </div>
</section>

<div id="app-view" style="display:none">
  <div class="topbar">
    <div class="topbarLogo" aria-label="ACE logo">
      <img alt="ACE" src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230b4a2b'/><text x='32' y='41' font-family='Arial,Helvetica,sans-serif' font-size='28' text-anchor='middle' fill='white' font-weight='700'>ACE</text></svg>">
    </div>
    <div class="brand">
      <b>ACE - Active Colleague Engagement</b>
      <span>Warehouse colleague absence &amp; engagement hub</span>
    </div>
    <!-- Global search bar for colleagues and other records -->
    <div class="search-wrapper">
      <input id="global-search" type="text" placeholder="Search colleagues..." autocomplete="off"/>
      <div id="search-results" class="search-results" style="display:none;"></div>
    </div>
    <!-- Quick Add button with dropdown menu -->
    <div class="quick-add-container">
      <!-- Inline style ensures the quick-add button stands out against the dark top bar and
           remains consistent even if other CSS rules change.  The flexbox centring
           guarantees the plus sign is centred vertically and horizontally. -->
      <button id="quick-add-btn" class="quick-add-btn" aria-label="Quick Add" title="Add new..."
              style="width:40px;height:40px;font-size:26px;line-height:38px;border-radius:10px;
                     background:rgba(255,255,255,0.35);border:1px solid rgba(255,255,255,0.5);
                     color:#0b4a2b;display:flex;align-items:center;justify-content:center;
                     box-shadow:0 2px 4px rgba(0,0,0,0.05);">
        +
      </button>
      <!-- Subtle label displayed beside the plus icon to clarify the button's purpose -->
      <span id="quick-add-label" class="quick-add-label">Quick Add</span>
      <div id="quick-add-menu" class="quick-add-menu" style="display:none;">
        <button id="qa-absence">Add Absence</button>
        <!-- Rebrand quick add actions to Part Shift and Me Day -->
        <button id="qa-partshift">Add Part Shift</button>
        <button id="qa-meday">Add Me Day</button>
      </div>
    </div>
    <div class="spacer"></div>

    <div class="pill">
      <span class="muted" style="color:#e6efe9">Department</span>
      <select id="dept-filter">
        <option value="ALL">All departments</option>
        <option>Dot Com</option>
        <option>Retail</option>
        <option>Transport</option>
        <option>Stock - Dot Com</option>
        <option>Stock - Retail</option>
      </select>
    </div>

    <div class="pill" id="login-pill">Logged in as: <b id="whoami">-</b></div>
    <button id="logout-btn">Log out</button>
  </div>

  <!-- Breadcrumb and last updated indicator placed below the top bar -->
  <div id="breadcrumb" class="breadcrumb"></div>
  <div id="last-updated" class="last-updated"></div>

  <div class="layout">
    <aside class="sidebar">
      <!-- The Recent section will be placed near the bottom of the sidebar -->

      <div class="navGroup">
        <button class="navHeader" data-group="attendance">Attendance &amp; Welfare <span>▾</span></button>
        <ul class="navList" data-list="attendance">
          <li onclick="openTab('absence')"><button data-tab="absence" onclick="openTab('absence')">Absence</button></li>
          <li onclick="openTab('partshift')"><button data-tab="partshift" onclick="openTab('partshift')">Part Shift</button></li>
          <li onclick="openTab('medical')"><button data-tab="medical" onclick="openTab('medical')">Medical Reports</button></li>
          <li onclick="openTab('restrictions')"><button data-tab="restrictions" onclick="openTab('restrictions')">Authorised restrictions</button></li>
          <li onclick="openTab('flexible')"><button data-tab="flexible" onclick="openTab('flexible')">Flexible leave</button></li>
          <li onclick="openTab('ihc')"><button data-tab="ihc" onclick="openTab('ihc')">IHC process</button></li>
          <li onclick="openTab('rehab')"><button data-tab="rehab" onclick="openTab('rehab')">Rehabilitations</button></li>
          <li onclick="openTab('illhealth')"><button data-tab="illhealth" onclick="openTab('illhealth')">Ill Health Leave</button></li>
          <li onclick="openTab('bereavement')"><button data-tab="bereavement" onclick="openTab('bereavement')">Bereavement</button></li>
          <li onclick="openTab('awol')"><button data-tab="awol" onclick="openTab('awol')">AWOL</button></li>
          <li onclick="openTab('medays')"><button data-tab="medays" onclick="openTab('medays')">Me Days</button></li>
          <li onclick="openTab('latertw')"><button data-tab="latertw" onclick="openTab('latertw')">Late RTW</button></li>
        </ul>
      </div>

      
      <div class="navGroup">
        <button class="navHeader" data-group="conduct">Conduct <span>▾</span></button>
        <ul class="navList" data-list="conduct">
          <li onclick="openTab('investigations')"><button data-tab="investigations" onclick="openTab('investigations')">Investigations</button></li>
          <li onclick="openTab('warnings')"><button data-tab="warnings" onclick="openTab('warnings')">Warnings</button></li>
          <li onclick="openTab('da')"><button data-tab="da" onclick="openTab('da')">D&amp;A</button></li>
          <li onclick="openTab('positiveRoc')"><button data-tab="positiveRoc" onclick="openTab('positiveRoc')">Positive ROC</button></li>
        </ul>
      </div>
<div class="navGroup">
        <button class="navHeader" data-group="people">People <span>▾</span></button>
        <ul class="navList" data-list="people">
          <li><button data-tab="colleagues" onclick="openTab('colleagues')">Colleagues</button></li>
          <li><button data-tab="upcoming" onclick="openTab('upcoming')">Upcoming actions</button></li>
          <li><button data-tab="completed" onclick="openTab('completed')">Completed Actions</button></li>
          <!-- Additional colleague-related tabs can be added here -->
        </ul>
      </div>
      <!-- Data and Admin section -->
      <div class="navGroup">
        <button class="navHeader" data-group="dataadmin">Data and Admin <span>▾</span></button>
        <ul class="navList" data-list="dataadmin">
          <li><button data-tab="dashboard" onclick="openTab('dashboard')">Dashboard</button></li>
          <li><button data-tab="admin" onclick="openTab('admin')">Admin</button></li>
          <li><button data-tab="settings" onclick="openTab('settings')">Settings</button></li>
        </ul>
      </div>
      <!-- Profile section moved to bottom -->
      <div class="navGroup">
        <button class="navHeader" data-group="profile">Profile <span>▾</span></button>
        <ul class="navList" data-list="profile">
          <li><button data-tab="profile" onclick="openTab('profile')">Change Password</button></li>
        </ul>
      </div>
      <!-- Recent colleagues collapsible group -->
      <div class="navGroup">
        <button class="navHeader" data-group="recent">Recent <span>▾</span></button>
        <ul class="navList" data-list="recent" id="recent-col-nav"></ul>
      </div>

      <!-- Always-visible footer note -->
      <!--
        Adjusted sidebar footer styling to be more subtle. The font size is
        intentionally small and the opacity is lowered so it doesn’t compete
        for attention with primary navigation items.
      -->
      <div class="sidebar-footer" style="margin:12px;font-size:0.5rem;color:var(--muted);opacity:0.6;">
        ACE System ©️ 2025<br>Designed and implemented by:<br>Ashley Tappenden / Jason Cliffe<br>For Authorised Personnel / Site use only
      </div>
    </aside>

    <main class="content">
      <div id="tab-host"></div>
    </main>
  </div>

  <!-- Toast notifications container for success/error and undo messages -->
  <div id="toast-container" class="toast-container"></div>
</div>

<!-- Modal -->
<div class="backdrop" id="modal-backdrop" role="dialog" aria-modal="true">
  <div class="modal">
    <div class="modalHeader">
      <b id="modal-title">Modal</b>
      <button class="btn small" id="modal-close">Close</button>
    </div>
    <div class="modalBody" id="modal-body"></div>
    <div class="modalFooter" id="modal-footer"></div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
<script>
  // Firebase (compat) initialisation. Uses global `firebase` so it loads synchronously
  // before the main app script runs.
  const firebaseConfig = {
    apiKey: "AIzaSyAtbCRVEgI4BHGITBtCPSpsWXRzRdcsuP8",
    authDomain: "ace-app-b6264.firebaseapp.com",
    projectId: "ace-app-b6264",
    storageBucket: "ace-app-b6264.firebasestorage.app",
    messagingSenderId: "822422486914",
    appId: "1:822422486914:web:3d751ee389d7b33230d99b",
    measurementId: "G-WZQX1R1B3W"
  };

  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  // Minimal shim that mimics the v9 modular API used by the app's cloud-sync code.
  window.__aceFirebase = {
    auth,
    db,
    // doc(db, ...segments)
    doc: (dbObj, ...segments) => dbObj.doc(segments.join('/')),
    // getDoc(ref)
    getDoc: async (ref) => {
      const snap = await ref.get();
      return {
        exists: () => !!snap.exists,
        data: () => snap.data()
      };
    },
    // setDoc(ref, data, options)
    setDoc: async (ref, data, options) => ref.set(data, options),
    // onSnapshot(ref, next, error)
    onSnapshot: (ref, next, error) => {
      return ref.onSnapshot(
        (snap) => next({ exists: () => !!snap.exists, data: () => snap.data() }),
        (err) => { if (typeof error === 'function') error(err); }
      );
    },
    // serverTimestamp()
    serverTimestamp: () => firebase.firestore.FieldValue.serverTimestamp(),

    onAuthStateChanged: (authObj, cb) => authObj.onAuthStateChanged(cb),
    signInWithEmailAndPassword: (authObj, email, pass) => authObj.signInWithEmailAndPassword(email, pass),
    createUserWithEmailAndPassword: (authObj, email, pass) => authObj.createUserWithEmailAndPassword(email, pass),
    signOut: (authObj) => authObj.signOut()
  };

  // In compat mode, we can consider Firebase ready immediately.
  window.__aceFirebaseReady = Promise.resolve(true);
</script>
<script>
/* ================================
   ACE Attendance & Welfare Rebuild
   Robust persistence + UK dates
   ================================ */

const BUILD_ID = "ATTWELFARE_REWRITE_v1";
// Safely set the build identifier. Some templates may omit the build-id element,
// so guard against null before assigning to avoid breaking the login logic.
{
  const buildEl = document.getElementById("build-id");
  if (buildEl) buildEl.textContent = BUILD_ID;
}

const LS_KEY = "ACE_APP_STATE_V1";        // full app state
// A separate key for the session portion of state. We store the session
// (loggedIn, username, role) in sessionStorage so that it persists across
// page refreshes but is cleared when the tab/window is closed. This means
// the user remains logged in when refreshing, but will be logged out when
// closing the browser or opening a new tab.
const LS_SESSION = LS_KEY + "_SESSION";
const LS_UI  = "ACE_APP_UI_V1";           // UI state (tab, dept, collapsed groups)

const USERS = [
  // ACETEST is given admin permissions so they can view the Admin tab.  The
  // canAdmin flag grants access to the admin section without needing to
  // change their role from 'user'.  See bindLoginHard for how canAdmin is
  // mapped to session.canAdmin.  We also set canDelete to true so ACETEST
  // has permission to delete actions (absence, part shift, me day, etc.).
  // NOTE: This is only an obfuscation step (client-side code can always be inspected).
  // We store a SHA-256 hash of the password so the plaintext is not present in the HTML.
  { username: "ACETEST", passwordHash: "43887b3b262e93249faef66817f468c5c9616e340aa654d9d4dea796e3c40ac9", role: "user", canAdmin: true, canDelete: true },
  { username: "LYMEDALEADMIN", password: "ASDA2025", role: "admin" }
];

// Password verification helper.
// Supports either a plaintext `password` field (legacy) or a SHA-256 hex `passwordHash`.
async function sha256Hex(str){
  const data = new TextEncoder().encode(String(str));
  const hash = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2,'0')).join('');
}
async function verifyPassword(userObj, entered){
  if(!userObj) return false;
  if(userObj.passwordHash){
    const h = await sha256Hex(entered);
    return h === String(userObj.passwordHash).toLowerCase();
  }
  return String(userObj.password || '') === String(entered || '');
}

/* ---------- Utilities ---------- */
const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);
const pad2 = (n) => String(n).padStart(2,"0");
function toUKDate(isoOrDate){
  if(!isoOrDate) return "";
  const d = (isoOrDate instanceof Date) ? isoOrDate : new Date(isoOrDate);
  if(Number.isNaN(d.getTime())) return String(isoOrDate);
  return `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()}`;
}

// Format a date/time string into UK date and 24h time (HH:MM). Accepts ISO string or Date.
function toUKDateTime(isoOrDate){
  if(!isoOrDate) return "";
  const d = (isoOrDate instanceof Date) ? isoOrDate : new Date(isoOrDate);
  if(Number.isNaN(d.getTime())) return String(isoOrDate);
  return `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
}

// Format a plain time string (HH:MM or HH:MM:SS...) into 24h HH:MM. If the
// input contains seconds or a timezone (e.g., "12:34:50.703Z"), it will be
// truncated to the first five characters. If the input does not match the
// pattern, the original value is returned. Returns an empty string if
// falsy.
function toUKTime(timeStr){
  if(!timeStr) return "";
  const str = String(timeStr);
  // If it starts with two digits, colon and two digits, return that prefix
  const m = str.match(/^\d{2}:\d{2}/);
  return m ? m[0] : str;
}
function fromDateInput(value){ // value from <input type="date"> => ISO string yyyy-mm-dd
  return value ? value : "";
}
function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
function downloadCSV(filename, rows){
  const esc = (v) => `"${String(v ?? "").replace(/"/g,'""')}"`;
  // IMPORTANT: keep newline as an escaped string so the script parses correctly
  const csv = rows.map(r => r.map(esc).join(",")).join("\\n");
  const blob = new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a); a.click(); a.remove();
}

/* ---------- Chart drawing ---------- */
// Older bar chart implementation has been renamed to drawSummaryBarChart.  It
// remains in the file for reference but is not used.  The current dashboard
// uses a responsive line chart implementation defined later in the script.
let _summaryCounts = null;
function drawSummaryBarChart(counts){
  // Persist counts for resize redrawing
  _summaryCounts = counts;
  const canvas = document.getElementById('summary-chart');
  const tooltip = document.getElementById('chart-tooltip');
  if(!canvas || !tooltip) return;
  const container = canvas.parentElement;
  // Set canvas dimensions based on the container width.  Canvas width must be
  // explicit to ensure crisp rendering; height fixed to 220px (defined via CSS).
  const rect = container.getBoundingClientRect();
  // Account for device pixel ratio for high resolution displays
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(parseInt(getComputedStyle(canvas).height) * dpr);
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const width = canvas.width / dpr;
  const height = canvas.height / dpr;

  // Helper: convert a hex colour string to an [r,g,b] array
  function hexToRgb(hex){
    hex = hex.replace(/^#/, '');
    if(hex.length === 3){ hex = hex.split('').map(x => x+x).join(''); }
    const bigint = parseInt(hex, 16);
    return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
  }
  // Helper: lighten a hex colour by mixing with white.  factor=0 means no change,
  // factor=1 results in white.
  function lighten(hex, factor){
    const [r,g,b] = hexToRgb(hex);
    // Clamp factor between -1 and 1
    const f = Math.max(-1, Math.min(1, factor));
    let r2, g2, b2;
    if(f >= 0){
      // Lighten towards white
      r2 = Math.round(r + (255 - r) * f);
      g2 = Math.round(g + (255 - g) * f);
      b2 = Math.round(b + (255 - b) * f);
    } else {
      // Darken towards black
      const amt = -f;
      r2 = Math.round(r * (1 - amt));
      g2 = Math.round(g * (1 - amt));
      b2 = Math.round(b * (1 - amt));
    }
    return '#' + [r2,g2,b2].map(x=>x.toString(16).padStart(2,'0')).join('');
  }
  // Extract colours from CSS variables.  Use getComputedStyle on the root
  // document element so colours match the current theme.  Provide fallback
  // defaults if variables are not defined.
  const rs = getComputedStyle(document.documentElement);
  const colDanger = rs.getPropertyValue('--danger').trim() || '#c93a3a';
  const colWarn   = rs.getPropertyValue('--warn').trim()   || '#b07a00';
  const colOk     = rs.getPropertyValue('--ok').trim()     || '#0b7a3a';
  // Compose categories with base colours.  AWOL and Late RTW share colours
  // from the danger/warn palette.  Sort them by value descending to highlight
  // the most significant categories first.
  let categories = [
    { key:'absences', label:'Absences', color: lighten(colDanger, 0.1) },
    { key:'partShifts', label:'Part shifts', color: lighten(colWarn,   0.1) },
    { key:'meDays', label:'Me days', color: lighten(colOk,     0.1) },
    { key:'awol', label:'AWOL', color: lighten(colDanger, 0.25) },
    { key:'lateRTW', label:'Late RTW', color: lighten(colWarn,   0.25) }
  ];
  categories = categories.sort((a,b) => (counts[b.key]||0) - (counts[a.key]||0));
  // Determine maximum value for scaling.  If zero, set to 1 to prevent division by zero
  let maxVal = 0;
  categories.forEach(cat => { maxVal = Math.max(maxVal, counts[cat.key] || 0); });
  if(maxVal === 0) maxVal = 1;
  // Total value for percentage calculation
  const totalVal = categories.reduce((sum, cat) => sum + (counts[cat.key] || 0), 0) || 1;
  // Chart layout definitions
  const barCount = categories.length;
  const marginX = 20;
  const barSpacing = 16;
  const availableWidth = width - marginX*2;
  const barWidth = Math.min(80, (availableWidth - barSpacing*(barCount - 1)) / barCount);
  const chartHeight = height - 48; // extra space for values
  // Clear canvas and set up fonts
  ctx.clearRect(0, 0, width, height);
  ctx.font = '12px ' + (rs.getPropertyValue('--font') || 'system-ui');
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  // Draw horizontal grid lines (0-100% at 25% intervals)
  ctx.strokeStyle = lighten(rs.getPropertyValue('--line').trim() || '#d7ded9', 0.25);
  ctx.lineWidth = 1;
  for(let i=0; i<=5; i++){
    const yPos = chartHeight - (chartHeight/5) * i;
    ctx.beginPath();
    ctx.moveTo(marginX/2, yPos);
    ctx.lineTo(width - marginX/2, yPos);
    ctx.stroke();
    // Draw percentage label at left of grid line
    const perc = Math.round(i * 25);
    ctx.fillStyle = rs.getPropertyValue('--muted') || '#6b7a70';
    ctx.fillText(perc + '%', marginX/2 - 4, yPos - 6);
  }
  // Precompute bar rectangles for hover detection
  const bars = [];
  categories.forEach((cat, i) => {
    const val = counts[cat.key] || 0;
    const barHeight = (val / maxVal) * chartHeight;
    const x = marginX + i * (barWidth + barSpacing);
    const y = chartHeight - barHeight;
    // Draw bar
    ctx.fillStyle = cat.color;
    ctx.fillRect(x, y, barWidth, barHeight);
    // Draw value above bar
    ctx.fillStyle = rs.getPropertyValue('--text') || '#122018';
    ctx.textBaseline = 'bottom';
    ctx.fillText(val, x + barWidth/2, y - 4);
    // Reset baseline for label below bar
    ctx.textBaseline = 'top';
    ctx.fillText(cat.label, x + barWidth/2, chartHeight + 8);
    // Determine percentage for tooltip
    const percentVal = Math.round((val / totalVal) * 100);
    bars.push({ x: x, y: y, w: barWidth, h: barHeight, label: cat.label, value: val, percent: percentVal, color: cat.color });
  });
  // Hover interaction: when mouse moves over a bar, show tooltip and
  // redraw bar with a darker shade.  Otherwise hide tooltip.
  let currentHover = null;
  function onMove(e){
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (canvas.width / rect.width) / dpr;
    const py = (e.clientY - rect.top) * (canvas.height / rect.height) / dpr;
    let found = null;
    bars.forEach(bar => {
      if(px >= bar.x && px <= bar.x + bar.w && py >= bar.y && py <= bar.y + bar.h){
        found = bar;
      }
    });
    if(found){
      if(currentHover !== found){
        currentHover = found;
        redraw();
        // Position and show tooltip with value and percentage
        tooltip.textContent = `${found.label}: ${found.value} (${found.percent}%)`;
        const tipRect = tooltip.getBoundingClientRect();
        let tx = e.clientX + 10;
        let ty = e.clientY - tipRect.height - 8;
        // Ensure tooltip stays within viewport horizontally
        if(tx + tipRect.width > window.innerWidth - 8){ tx = window.innerWidth - tipRect.width - 8; }
        if(ty < 0){ ty = e.clientY + 12; }
        tooltip.style.left = tx + 'px';
        tooltip.style.top  = ty + 'px';
        tooltip.style.display = 'block';
      }
    }else{
      if(currentHover){ currentHover = null; redraw(); }
      tooltip.style.display = 'none';
    }
  }
  function onLeave(){
    if(currentHover){ currentHover = null; redraw(); }
    tooltip.style.display = 'none';
  }
  // Remove any existing handlers before attaching new ones to avoid duplicate listeners
  if(canvas._moveHandler){ canvas.removeEventListener('mousemove', canvas._moveHandler); }
  if(canvas._leaveHandler){ canvas.removeEventListener('mouseleave', canvas._leaveHandler); }
  canvas.addEventListener('mousemove', onMove);
  canvas.addEventListener('mouseleave', onLeave);
  // Store references to handlers on the canvas so they can be removed on next call
  canvas._moveHandler = onMove;
  canvas._leaveHandler = onLeave;
  // Redraw function: clears canvas and draws bars, highlighting the current
  // hover bar by darkening its colour
  function redraw(){
    ctx.clearRect(0, 0, width, height);
    // Draw grid lines again for reference
    ctx.strokeStyle = lighten(rs.getPropertyValue('--line').trim() || '#d7ded9', 0.25);
    ctx.lineWidth = 1;
    for(let i=0; i<=5; i++){
      const yPos = chartHeight - (chartHeight/5) * i;
      ctx.beginPath();
      ctx.moveTo(marginX/2, yPos);
      ctx.lineTo(width - marginX/2, yPos);
      ctx.stroke();
      const perc = Math.round(i * 25);
      ctx.fillStyle = rs.getPropertyValue('--muted') || '#6b7a70';
      ctx.fillText(perc + '%', marginX/2 - 4, yPos - 6);
    }
    // Draw bars, values and labels.  Highlight the hovered bar by darkening colour
    categories.forEach((cat, i) => {
      const val = counts[cat.key] || 0;
      const barHeight = (val / maxVal) * chartHeight;
      const x = marginX + i * (barWidth + barSpacing);
      const y = chartHeight - barHeight;
      let fill = cat.color;
      if(currentHover && currentHover.label === cat.label){
        fill = lighten(cat.color, -0.15);
      }
      ctx.fillStyle = fill;
      ctx.fillRect(x, y, barWidth, barHeight);
      // Value above bar
      ctx.fillStyle = rs.getPropertyValue('--text') || '#122018';
      ctx.textBaseline = 'bottom';
      ctx.fillText(val, x + barWidth/2, y - 4);
      // Label below bar
      ctx.textBaseline = 'top';
      ctx.fillText(cat.label, x + barWidth/2, chartHeight + 8);
    });
  }

  // Populate legend beneath the chart.  Use the sorted categories and current counts
  // to create items showing colour swatches, labels and values with percentages.
  const legend = document.getElementById('chart-legend');
  if(legend){
    let legendHtml = '';
    categories.forEach(cat => {
      const val = counts[cat.key] || 0;
      const percentVal = Math.round((val / totalVal) * 100);
      legendHtml += `<div class="legend-item"><span class="legend-color" style="background:${cat.color}"></span><span>${cat.label}: ${val} (${percentVal}%)</span></div>`;
    });
    legend.innerHTML = legendHtml;
  }
}

/*
 * Override summary chart rendering with a line chart.  The original
 * drawSummaryChart renders a bar chart.  We redefine drawSummaryChart
 * as a new function that plots per-day occurrences for each category
 * (absences, part shifts, me days, AWOL and late return to work) over
 * the selected dashboard range.  The x-axis shows dates and the y-axis
 * shows counts.  Colours correspond to each category.  A tooltip
 * appears when hovering over markers, and the legend shows totals and
 * percentages across the selected range.  The chart remains
 * responsive and redraws on window resize using _summaryCounts.
 */
drawSummaryChart = function(counts = null){
  // Persist for resize redraw
  _summaryCounts = counts;
  const canvas = document.getElementById('summary-chart');
  const tooltip = document.getElementById('chart-tooltip');
  if(!canvas || !tooltip) return;
  const container = canvas.parentElement;
  const rect = container.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(rect.width * dpr);
  canvas.height = Math.floor(parseInt(getComputedStyle(canvas).height) * dpr);
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const width = canvas.width / dpr;
  const height = canvas.height / dpr;
  // Colour helpers
  function hexToRgb(hex){
    hex = hex.replace(/^#/, '');
    if(hex.length === 3){ hex = hex.split('').map(x => x + x).join(''); }
    const val = parseInt(hex, 16);
    return [ (val >> 16) & 255, (val >> 8) & 255, val & 255 ];
  }
  function lighten(hex, factor){
    const [r,g,b] = hexToRgb(hex);
    const f = Math.max(-1, Math.min(1, factor));
    let r2, g2, b2;
    if(f >= 0){
      r2 = Math.round(r + (255 - r) * f);
      g2 = Math.round(g + (255 - g) * f);
      b2 = Math.round(b + (255 - b) * f);
    } else {
      const amt = -f;
      r2 = Math.round(r * (1 - amt));
      g2 = Math.round(g * (1 - amt));
      b2 = Math.round(b * (1 - amt));
    }
    return '#' + [r2,g2,b2].map(x => x.toString(16).padStart(2,'0')).join('');
  }
  const rs = getComputedStyle(document.documentElement);
  const colDanger = rs.getPropertyValue('--danger').trim() || '#c93a3a';
  const colWarn   = rs.getPropertyValue('--warn').trim()   || '#b07a00';
  const colOk     = rs.getPropertyValue('--ok').trim()     || '#0b7a3a';
  // Determine range
  let rangeDays = 7;
  if(ui.dashRange === '28d') rangeDays = 28;
  else if(ui.dashRange === '90d') rangeDays = 90;
  // Build date array
  const today = new Date();
  today.setHours(0,0,0,0);
  const start = new Date(today);
  start.setDate(start.getDate() - (rangeDays - 1));
  const dates = [];
  for(let i=0; i<rangeDays; i++){
    const d = new Date(start);
    d.setDate(start.getDate() + i);
    dates.push(d);
  }
  // Department filter helper
  function matchDept(colId){ return (ui.dept === 'ALL' || deptPass(colId)); }
  // Initialise series
  const categories = [
    { key:'absences',  label:'Absence',    color: lighten(colDanger, 0.1),  data:new Array(rangeDays).fill(0) },
    { key:'partShifts',label:'Part shift', color: lighten(colWarn,   0.1),  data:new Array(rangeDays).fill(0) },
    { key:'meDays',    label:'Me day',     color: lighten(colOk,     0.1),  data:new Array(rangeDays).fill(0) },
    { key:'awol',      label:'AWOL',       color: lighten(colDanger, 0.25), data:new Array(rangeDays).fill(0) },
    { key:'lateRTW',   label:'Late RTW',   color: lighten(colWarn,   0.25), data:new Array(rangeDays).fill(0) }
  ];
  function addToSeries(name, dateStr){
    if(!dateStr) return;
    const dt = new Date(dateStr);
    dt.setHours(0,0,0,0);
    const diff = Math.round((dt - start) / 86400000);
    if(diff >= 0 && diff < rangeDays){
      const cat = categories.find(c => c.key === name);
      if(cat) cat.data[diff]++;
    }
  }
  // Populate from state
  state.absences.forEach(a => {
    if(!matchDept(a.colleagueId)) return;
    (a.events || []).forEach(e => addToSeries('absences', e.dateStart || e.date || ''));
  });
  state.partShifts.forEach(r => { if(matchDept(r.colleagueId)) addToSeries('partShifts', r.date); });
  state.meDays.forEach(r => { if(matchDept(r.colleagueId)) addToSeries('meDays', r.date); });
  state.awol.forEach(r => { if(matchDept(r.colleagueId)) addToSeries('awol', r.startDate || r.date); });
  state.lateRTW.forEach(r => { if(matchDept(r.colleagueId)) addToSeries('lateRTW', r.date || r.startDate); });
  // Determine max
  let maxVal = 0;
  categories.forEach(cat => { cat.data.forEach(v => { if(v > maxVal) maxVal = v; }); });
  if(maxVal === 0) maxVal = 1;
  categories.forEach(cat => { cat.total = cat.data.reduce((s,v)=>s+v,0); });
  const totalAcross = categories.reduce((s,c)=>s+c.total,0) || 1;
  // Chart layout
  const marginLeft = 40;
  const marginRight= 20;
  const marginTop  = 20;
  const marginBottom = 40;
  const chartWidth  = width - marginLeft - marginRight;
  const chartHeight = height - marginTop - marginBottom;
  const xStep = (rangeDays > 1) ? chartWidth / (rangeDays - 1) : chartWidth;
  const xPositions = [];
  for(let i=0; i<rangeDays; i++) xPositions[i] = marginLeft + i * xStep;
  // Markers
  const markers = [];
  categories.forEach(cat => {
    cat.data.forEach((v, idx) => {
      const x = xPositions[idx];
      const y = marginTop + chartHeight - (v / maxVal) * chartHeight;
      markers.push({ x:x, y:y, category:cat, value:v, dateIndex:idx });
    });
  });
  // Draw grid and labels
  function drawGrid(){
    ctx.clearRect(0,0,width,height);
    ctx.strokeStyle = lighten(rs.getPropertyValue('--line').trim() || '#d7ded9', 0.25);
    ctx.lineWidth = 1;
    ctx.fillStyle = rs.getPropertyValue('--muted') || '#6b7a70';
    let yStep = 1;
    if(maxVal > 5) yStep = Math.ceil(maxVal / 4);
    const yTicks = [];
    for(let val = 0; val <= maxVal; val += yStep) yTicks.push(val);
    if(yTicks[yTicks.length-1] < maxVal) yTicks.push(maxVal);
    yTicks.forEach(val => {
      const y = marginTop + chartHeight - (val / maxVal) * chartHeight;
      ctx.beginPath(); ctx.moveTo(marginLeft, y); ctx.lineTo(width - marginRight, y); ctx.stroke();
      ctx.textAlign = 'right'; ctx.textBaseline = 'middle'; ctx.fillText(String(val), marginLeft - 6, y);
    });
    let labelStep = 1;
    if(rangeDays > 30) labelStep = Math.ceil(rangeDays / 10);
    else if(rangeDays > 20) labelStep = 3;
    else if(rangeDays > 14) labelStep = 2;
    ctx.textAlign = 'center'; ctx.textBaseline = 'top';
    for(let i=0; i<rangeDays; i++){
      const x = xPositions[i];
      ctx.beginPath(); ctx.moveTo(x, marginTop); ctx.lineTo(x, marginTop + chartHeight); ctx.stroke();
      if(i % labelStep === 0 || i === rangeDays - 1){
        const d = dates[i];
        const label = d.toLocaleDateString('en-GB',{ day:'2-digit', month:'short' });
        ctx.fillText(label, x, marginTop + chartHeight + 6);
      }
    }
    ctx.beginPath(); ctx.moveTo(marginLeft, marginTop + chartHeight); ctx.lineTo(width - marginRight, marginTop + chartHeight); ctx.stroke();
  }
  let currentMarker = null;
  function drawLines(){
    drawGrid();
    categories.forEach(cat => {
      ctx.strokeStyle = cat.color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      cat.data.forEach((v, idx) => {
        const x = xPositions[idx];
        const y = marginTop + chartHeight - (v / maxVal) * chartHeight;
        if(idx === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
      cat.data.forEach((v, idx) => {
        const x = xPositions[idx];
        const y = marginTop + chartHeight - (v / maxVal) * chartHeight;
        ctx.beginPath();
        ctx.fillStyle = cat.color;
        let radius = 3;
        if(currentMarker && currentMarker.category === cat && currentMarker.dateIndex === idx) radius = 5;
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fill();
      });
    });
  }
  function onMove(e){
    const br = canvas.getBoundingClientRect();
    const px = (e.clientX - br.left) * (canvas.width / br.width) / dpr;
    const py = (e.clientY - br.top)  * (canvas.height / br.height)/ dpr;
    let found = null;
    for(const m of markers){
      const dx = px - m.x; const dy = py - m.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist <= 6){ found = m; break; }
    }
    if(found){
      if(currentMarker !== found){ currentMarker = found; drawLines(); }
      const dateLbl = dates[found.dateIndex].toLocaleDateString('en-GB',{ day:'2-digit', month:'short', year:'numeric' });
      tooltip.textContent = `${found.category.label} on ${dateLbl}: ${found.value}`;
      const tipRect = tooltip.getBoundingClientRect();
      let tx = e.clientX + 10;
      let ty = e.clientY - tipRect.height - 8;
      if(tx + tipRect.width > window.innerWidth - 8) tx = window.innerWidth - tipRect.width - 8;
      if(ty < 0) ty = e.clientY + 12;
      tooltip.style.left = tx + 'px';
      tooltip.style.top  = ty + 'px';
      tooltip.style.display = 'block';
    } else {
      if(currentMarker){ currentMarker = null; drawLines(); }
      tooltip.style.display = 'none';
    }
  }
  function onLeave(){ if(currentMarker){ currentMarker = null; drawLines(); } tooltip.style.display = 'none'; }
  if(canvas._moveHandler) canvas.removeEventListener('mousemove', canvas._moveHandler);
  if(canvas._leaveHandler) canvas.removeEventListener('mouseleave', canvas._leaveHandler);
  canvas.addEventListener('mousemove', onMove);
  canvas.addEventListener('mouseleave', onLeave);
  canvas._moveHandler = onMove;
  canvas._leaveHandler = onLeave;
  drawLines();
  // Legend
  const legend = document.getElementById('chart-legend');
  if(legend){
    let html = '';
    categories.forEach(cat => {
      const perc = Math.round((cat.total / totalAcross) * 100);
      html += `<div class="legend-item"><span class="legend-color" style="background:${cat.color}"></span><span>${escapeHtml(cat.label)}: ${cat.total} (${perc}%)</span></div>`;
    });
    legend.innerHTML = html;
  }
};
// Redraw the chart on window resize using the last counts provided
window.addEventListener('resize', () => {
  if(_summaryCounts){
    drawSummaryChart(_summaryCounts);
  }
});

// Global click handler for colleague names.  When a user clicks on any element with
// the class `col-link`, find the closest ancestor with that class and open
// the colleague history modal using the embedded data-col-id attribute.  This
// enables quick access to a colleague's full history from anywhere in the app.
document.addEventListener('click', function(ev){
  const target = ev.target.closest && ev.target.closest('.col-link');
  if(target){
    const colId = target.getAttribute('data-col-id');
    if(colId){
      // Open the new colleague profile modal instead of the simple history modal
      openColProfileModal(colId);
    }
  }
});

/* ---------- State ---------- */
function defaultState(){
  return {
    version: 1,
    __localUpdatedAt: 0,
    session: { loggedIn:false, username:null, role:null, canDelete:false, canAdmin:false, adminUnlocked:false },
    colleagues: [
      { id:"C001", name:"Jamie Smith", department:"Retail", contact:"", teamManagerId: undefined },
      { id:"C002", name:"Taylor Brown", department:"Dot Com", contact:"", teamManagerId: undefined },
      { id:"C003", name:"Jordan Lee", department:"Transport", contact:"", teamManagerId: undefined }
    ],
    managers: [
      { id:uid(), name:"Alex Johnson", department:"Retail" }
    ],

    // Attendance & Welfare data
    absences: [],          // {id,colleagueId,createdAt,events:[{id,dateStart,sickness,nextAction,nextActionDT,sickNoteExpiry,expectedReturn,cspStopped,notes}]}
    partShifts: [],        // {id,colleagueId,managerId,dateAbsence,expectedReturn,leftSite,shiftStart,shiftEnd,details,fileNoteCompleted}
    medicalReports: [],    // {id,colleagueId,managerId,dateStart,reviewDate,details,workdayUpdated}
    restrictions: [],      // {id,colleagueId,managerId,restriction,startDate,reviewDate,ochStatus,reviewState,details}
    flexibleLeave: [],     // {id,colleagueId,managerId,date,requestedHours,approvedHours,reason,details}
    ihc: [],               // {id,colleagueId,latest:{...}, history:[...]}
    rehab: [],             // {id,colleagueId,latest:{...}, history:[...]}
    illHealth: [],         // {id,colleagueId,startDate,endDate,details}
    bereavement: [],       // {id,colleagueId,managerId,date,relationship,days,nextActionDate,details}
    awol: [],              // {id,colleagueId,managerId,dateAwol,gitSent,gitSentDate,callBackAttempted,nextAction,nextActionDate,details}
    meDays: [],            // {id,colleagueId,managerId,date,reason,details,nextAction,nextActionDate}
    lateRTW: [],           // {id,colleagueId,managerId,dateExpected,dateReturned,reason,details,nextAction,nextActionDate}

    // Conduct
    investigations: [],    // {id,colleagueId,managerId,caseRef,date,time,outcome,details,createdAt}
    warnings: [],          // {id,colleagueId,managerId,action,reason,createdAt}

    // Drug & Alcohol tests
    daTests: [],           // {id, colleagueId, managerId, dateTest, timeStart, timeFinish, testResult, sanction, details, createdAt}
    // Positive ROC logs
    positiveRocs: [],      // {id, colleagueId, managerId, dateIssued, timeIssued, raffleTicket, reason, createdAt}
    // Completed absences (Return to Work)
    completedAbsences: [], // {id, colleagueId, managerId, dateReturn, timeReturn, details, completedAt, events: [...], sanction}

    // Completed logs from various tabs (excluding absences and upcoming actions)
    completedLogs: [],      // array of {type, record, completedAt} objects used to store completed records from attendance & conduct tabs
    // Completed upcoming actions
    completedUpcoming: [],  // array of {category, colleagueId, due} objects used to hide completed items from the upcoming actions tab
    // Global configuration for thresholds and other settings.  These values may be customised
    // by administrators from the Settings tab.  Absence/warning thresholds and windows determine
    // how risk flags are computed.
    config: {
      absenceThreshold: 3,
      absenceDaysWindow: 60,
      warningThreshold: 2,
      warningDaysWindow: 365
    },
    // Recently viewed colleagues for quick navigation in the sidebar
    recentColleagues: [],
    users: [],           // custom user accounts {username,password,canDelete,canAdmin}
    // Audit trail of actions performed within the system.
    // Each entry is an object { ts, user, action, entity, recordId, colleagueId, details }.
    // The logAudit() helper manages the size of this array.
    auditTrail: []
  };
}

let state = loadState();
ensureAuditIds();
function loadState(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return defaultState();
    const parsed = JSON.parse(raw);
    // minimal migration safety
    const base = defaultState();
    // merge known keys to avoid undefined arrays
    const loaded = Object.assign(base, parsed, {
      __localUpdatedAt: (typeof parsed.__localUpdatedAt === 'number') ? parsed.__localUpdatedAt : 0,
      session: Object.assign({}, base.session, parsed.session||{}),
      colleagues: Array.isArray(parsed.colleagues)?parsed.colleagues:base.colleagues,
      managers: Array.isArray(parsed.managers)?parsed.managers:base.managers,
      absences: Array.isArray(parsed.absences)?parsed.absences:[],
      partShifts: Array.isArray(parsed.partShifts)?parsed.partShifts:[],
      medicalReports: Array.isArray(parsed.medicalReports)?parsed.medicalReports:[],
      restrictions: Array.isArray(parsed.restrictions)?parsed.restrictions:[],
      flexibleLeave: Array.isArray(parsed.flexibleLeave)?parsed.flexibleLeave:[],
      ihc: Array.isArray(parsed.ihc)?parsed.ihc:[],
      rehab: Array.isArray(parsed.rehab)?parsed.rehab:[],
      illHealth: Array.isArray(parsed.illHealth)?parsed.illHealth:[],
      bereavement: Array.isArray(parsed.bereavement)?parsed.bereavement:[],
      awol: Array.isArray(parsed.awol)?parsed.awol:[],
      meDays: Array.isArray(parsed.meDays)?parsed.meDays:[],
      lateRTW: Array.isArray(parsed.lateRTW)?parsed.lateRTW:[],
      investigations: Array.isArray(parsed.investigations)?parsed.investigations:[],
      warnings: Array.isArray(parsed.warnings)?parsed.warnings:[],
      daTests: Array.isArray(parsed.daTests)?parsed.daTests:[],
      positiveRocs: Array.isArray(parsed.positiveRocs)?parsed.positiveRocs:[],
      completedAbsences: Array.isArray(parsed.completedAbsences)?parsed.completedAbsences:[],
      completedLogs: Array.isArray(parsed.completedLogs)?parsed.completedLogs:[],
      completedUpcoming: Array.isArray(parsed.completedUpcoming)?parsed.completedUpcoming:[],
      // Recently viewed colleagues
      recentColleagues: Array.isArray(parsed.recentColleagues)?parsed.recentColleagues:[],
      // custom user accounts stored in state
      users: Array.isArray(parsed.users)?parsed.users:[],
      auditTrail: Array.isArray(parsed.auditTrail)?parsed.auditTrail:[]
    });

    // Ensure colleague objects have a status property so we can track suspensions and resignations.  If a colleague
    // record from an older save does not include the status property, initialise it to undefined so that
    // downstream code can safely read and write it.  We avoid overriding any existing status values.
    if(Array.isArray(loaded.colleagues)){
      loaded.colleagues = loaded.colleagues.map(c => {
        if(typeof c.status === "undefined"){
          c.status = undefined;
        }
        // ensure teamManagerId property exists on old colleagues
        if(typeof c.teamManagerId === "undefined"){
          c.teamManagerId = undefined;
        }
        return c;
      });
    }
    // Override the session state with sessionStorage if present. We store
    // session in sessionStorage so it persists across page refreshes but
    // clears when the tab is closed. If no session storage is present
    // (e.g. on a brand new tab), we fall back to whatever was in
    // localStorage.
    try{
      const sessRaw = sessionStorage.getItem(LS_SESSION);
      if(sessRaw){
        loaded.session = Object.assign({}, loaded.session, JSON.parse(sessRaw));
      }
    }catch(e){
      console.warn("Failed to load session from sessionStorage", e);
    }
    // If the loaded session belongs to the special ACETEST account, force
    // administrative and deletion permissions.  A custom user record or prior
    // session storage may override these flags unintentionally, so explicitly
    // reset them here.  This ensures the ACETEST user always retains admin
    // rights regardless of saved state.  See also the login overrides below.
    if (loaded.session && loaded.session.username === 'ACETEST') {
      loaded.session.canDelete = true;
      loaded.session.canAdmin  = true;
      // Also keep the adminUnlocked flag on so the Admin and Settings tabs do
      // not prompt for a secondary login.  Without this, the ACETEST user
      // would still see the admin login modal despite having admin privileges.
      loaded.session.adminUnlocked = true;
    }
    return loaded;
  }catch(e){
    console.warn("State load failed, resetting.", e);
    return defaultState();
  }
}



// Ensure audit log entries have stable ids so individual entries can be deleted.
// Older saved states may not include an id on audit entries.
function ensureAuditIds(){
  try{
    if(!state || !Array.isArray(state.auditTrail)) return;
    let changed = false;
    state.auditTrail.forEach(e => {
      if(e && !e.id){
        e.id = uid();
        changed = true;
      }
    });
    if(changed) saveState();
  }catch(e){
    console.warn('Failed to ensure audit ids', e);
  }
}

let saveTimer = null;
function saveState(){
  // debounce to avoid write-storm, but still guaranteed
  try{ state.__localUpdatedAt = Date.now(); }catch(e){}
  if(saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(() => {
    try{
      // When saving the state, persist non-session data to localStorage and
      // persist the session portion separately into sessionStorage. The
      // session data lives only for the life of the tab and will be cleared
      // automatically when the browser window or tab is closed.
      // Clone the state so we can strip out the session when writing to
      // localStorage. We keep everything else identical.
      const clone = JSON.parse(JSON.stringify(state));
      // Remove the session before writing to localStorage.  Session data
      // should not persist across browser closures to comply with GDPR
      // requirements that users must log in again when reopening the app.  A
      // clean object is written so that loadState will merge default
      // session values rather than using an old session.
      clone.session = {};
      localStorage.setItem(LS_KEY, JSON.stringify(clone));
      // Persist only the session portion into sessionStorage.  This retains
      // the login across page refreshes within the same tab but clears
      // when the tab is closed.
      sessionStorage.setItem(LS_SESSION, JSON.stringify(state.session));
      // Sync to Firestore (shared cloud state) if Firebase is signed in.
      try{
        if(typeof saveStateToCloud === 'function'){
          saveStateToCloud(clone).catch(err => console && console.error && console.error("Cloud save failed", err));
        }
      }catch(e){
        console && console.warn && console.warn('Cloud save failed', e);
      }
    }catch(e){
      console.error("Save failed", e);
      alert("Storage is full or blocked. Data may not save.");
    }
  }, 40);
}
// Note: previously we attempted to log out the user on window close while
// retaining login on page refresh by inspecting the navigation type in
// the beforeunload event. However this proved unreliable across browsers
// and environments. Instead we now store the session (loggedIn, username,
// role) in `sessionStorage` (see LS_SESSION above). sessionStorage is
// automatically cleared when the browser tab or window is closed, but
// persists during a page refresh. Consequently we no longer need to
// inspect the navigation type or manually clear the session in a
// beforeunload handler. The user will remain logged in across refreshes
// and will be logged out when the tab is closed.

/* ---------- UI State ---------- */
function defaultUI(){
  // Include the new "dataadmin" group by default so the Data & Admin section is expanded on first load
  // On first load, default to the dashboard tab instead of the absence tab.  This
  // ensures that after logging in the user lands on the Dashboard rather than
  // the Absence page.
  // Add dashRange and dashFocus to store dashboard preferences (range and focus filters)
  // Include the new 'profile' group in default groups so it's visible on first load.
  return {
    tab: "dashboard",
    dept: "ALL",
    dashRange: "28d",
    dashFocus: "all",
    // When true, only actions for the selected manager will show on the dashboard.  The
    // managerFilter field stores the id of the selected manager (or "ALL" for no filter).
    managerFilter: "ALL",
    // Colleague tab filters.  colManagerFilter stores the selected manager id (or "ALL"),
    // and colSearch stores the current search string for the Colleagues tab.
    colManagerFilter: "ALL",
    colSearch: "",
    // Store the current search string for the Upcoming actions tab.  This value
    // persists across re-renders within a session so typing in the search box
    // does not immediately reset when the tab updates.  It is not persisted
    // across page reloads.
    upcomingSearch: "",
    // The 'recent' group controls the collapsible state of the recently viewed colleagues
    // section.  Setting it to true by default expands the list on first load, matching
    // other nav sections.  You can collapse it and the state will persist in local storage.
    groups: { attendance: true, conduct: true, people: true, dataadmin: true, profile: true, recent: true }
  };
}
let ui = loadUI();
function loadUI(){
  try{
    const raw = localStorage.getItem(LS_UI);
    if(!raw) return defaultUI();
    const parsed = JSON.parse(raw);
    const base = defaultUI();
    return Object.assign(base, parsed, { groups: Object.assign(base.groups, parsed.groups||{}) });
  }catch(e){
    return defaultUI();
  }
}
function saveUI(){
  // Persist the UI state to localStorage.  Wrap in a try-catch to
  // gracefully handle errors (e.g. storage blocked by browser security
  // settings or quota exceeded).  Without this wrapper, any exception
  // would interrupt navigation logic such as openTab().
  try {
    localStorage.setItem(LS_UI, JSON.stringify(ui));
  } catch (e) {
    console && console.error && console.error('UI save failed', e);
    // Silently ignore to keep the app functional.  The UI state will
    // persist only in memory for this session.
  }
}


/* ---------- Firebase (Auth Gate + Cloud Sync) ---------- */
// Single shared workspace (one team) setup.
// NOTE: This keeps the existing in-app username/password login for audit identity,
// while Firebase Auth provides cross-device authentication and database security.
const CLOUD_DOC_PATH = ["apps", "ace", "state", "main"]; // apps/ace/state/main

function hasFirebase(){
  return !!(window.__aceFirebase && window.__aceFirebase.auth && window.__aceFirebase.db);
}

function getFirebaseUser(){
  try{ return window.__aceFirebase?.auth?.currentUser || null; }catch(e){ return null; }
}

async function loadStateFromCloud(){
  if(!hasFirebase()) return null;
  const { db, doc, getDoc } = window.__aceFirebase;
  const ref = doc(db, ...CLOUD_DOC_PATH);
  try{
    const snap = await getDoc(ref);
    if(!snap.exists()) return null;
    const data = snap.data() || {};
    return {
      state: data.state || null,
      updatedAtMs: (typeof data.updatedAtMs === 'number') ? data.updatedAtMs : 0
    };
  }catch(e){
    console && console.error && console.error('Cloud load failed', e);
    return null;
  }
}

async function saveStateToCloud(stateObj){
  if(!hasFirebase()) return;
  const user = getFirebaseUser();
  if(!user) return;
  const { db, doc, setDoc, serverTimestamp } = window.__aceFirebase;
  const ref = doc(db, ...CLOUD_DOC_PATH);
  try{
    await setDoc(ref, {
      state: stateObj,
      updatedAt: serverTimestamp(),
      updatedAtMs: Date.now(),
      updatedByUid: user.uid,
      updatedByEmail: user.email || null
    }, { merge: true });
  }catch(e){
    console && console.error && console.error('Cloud save failed', e);
    throw e;
  }
}

let __aceCloudUnsub = null;
function startCloudSync(){
  if(!hasFirebase()) return;
  if(__aceCloudUnsub) return; // already running
  const user = getFirebaseUser();
  if(!user) return;

  const { db, doc, onSnapshot } = window.__aceFirebase;
  const ref = doc(db, ...CLOUD_DOC_PATH);

  __aceCloudUnsub = onSnapshot(ref, (snap) => {
    try{
      if(!snap.exists()) return;
      const raw = (snap.data()||{});
      const cloud = raw.state;
      const cloudUpdatedAtMs = (typeof raw.updatedAtMs === 'number') ? raw.updatedAtMs : 0;
      if(!cloud) return;

      // If local is newer than cloud, ignore this snapshot to prevent data resets
      const localUpdatedAtMs = (state && typeof state.__localUpdatedAt === 'number') ? state.__localUpdatedAt : 0;
      if(localUpdatedAtMs && cloudUpdatedAtMs && cloudUpdatedAtMs < localUpdatedAtMs){
        return;
      }
      if(localUpdatedAtMs && !cloudUpdatedAtMs){
        return;
      }

      // Merge cloud state with defaults; preserve current session (tab-scoped)
      // and keep any in-memory session flags.
      const base = defaultState();
      const loaded = Object.assign(base, cloud, {
        session: Object.assign({}, base.session, state.session || {}),
        colleagues: Array.isArray(cloud.colleagues)?cloud.colleagues:base.colleagues,
        managers: Array.isArray(cloud.managers)?cloud.managers:base.managers,
        absences: Array.isArray(cloud.absences)?cloud.absences:[],
        partShifts: Array.isArray(cloud.partShifts)?cloud.partShifts:[],
        medicalReports: Array.isArray(cloud.medicalReports)?cloud.medicalReports:[],
        restrictions: Array.isArray(cloud.restrictions)?cloud.restrictions:[],
        flexibleLeave: Array.isArray(cloud.flexibleLeave)?cloud.flexibleLeave:[],
        ihc: Array.isArray(cloud.ihc)?cloud.ihc:[],
        rehab: Array.isArray(cloud.rehab)?cloud.rehab:[],
        illHealth: Array.isArray(cloud.illHealth)?cloud.illHealth:[],
        bereavement: Array.isArray(cloud.bereavement)?cloud.bereavement:[],
        awol: Array.isArray(cloud.awol)?cloud.awol:[],
        meDays: Array.isArray(cloud.meDays)?cloud.meDays:[],
        lateRTW: Array.isArray(cloud.lateRTW)?cloud.lateRTW:[],
        investigations: Array.isArray(cloud.investigations)?cloud.investigations:[],
        warnings: Array.isArray(cloud.warnings)?cloud.warnings:[],
        daTests: Array.isArray(cloud.daTests)?cloud.daTests:[],
        positiveRocs: Array.isArray(cloud.positiveRocs)?cloud.positiveRocs:[],
        completedAbsences: Array.isArray(cloud.completedAbsences)?cloud.completedAbsences:[],
        completedLogs: Array.isArray(cloud.completedLogs)?cloud.completedLogs:[],
        completedUpcoming: Array.isArray(cloud.completedUpcoming)?cloud.completedUpcoming:[],
        recentColleagues: Array.isArray(cloud.recentColleagues)?cloud.recentColleagues:[],
        users: Array.isArray(cloud.users)?cloud.users:[],
        auditTrail: Array.isArray(cloud.auditTrail)?cloud.auditTrail:[]
      });

      loaded.__localUpdatedAt = cloudUpdatedAtMs || Date.now();

      state = loaded;

      // Stamp Firebase identity into the session for audit traceability.
      try{
        state.session.firebaseUid = user.uid;
        state.session.firebaseEmail = user.email || null;
      }catch(e){}

      // Re-render current UI safely.
      try{ applySession(); }catch(e){}
      try{ renderCurrentTab(); }catch(e){}
    }catch(e){
      console && console.error && console.error('Cloud sync apply failed', e);
    }
  }, (err) => {
    console && console.error && console.error('Cloud sync error', err);
  });
}

function stopCloudSync(){
  try{ if(__aceCloudUnsub) __aceCloudUnsub(); }catch(e){}
  __aceCloudUnsub = null;
}

function ensureFirebaseGate(){
  // Simple full-screen gate to require Firebase sign-in before using the app.
  const existing = document.getElementById('fb-gate');
  if(existing) return existing;

  const gate = document.createElement('div');
  gate.id = 'fb-gate';
  gate.style.position = 'fixed';
  gate.style.inset = '0';
  gate.style.zIndex = '9999';
  gate.style.background = 'linear-gradient(180deg, var(--green2) 0%, var(--green) 100%)';
  gate.style.display = 'flex';
  gate.style.alignItems = 'center';
  gate.style.justifyContent = 'center';
  gate.style.padding = '18px';

  gate.innerHTML = `
    <div style="width:min(420px, 100%); background:#ffffff; border-radius:18px; padding:18px; box-shadow:0 16px 40px rgba(0,0,0,.22); border:1px solid rgba(0,0,0,.08)">
      <div style="font-weight:900; font-size:18px; color:#0b2b19; margin-bottom:6px; text-align:center;">Sign in to access ACE</div>
      <div style="font-size:13px; color:#6b7a70; margin-bottom:14px; text-align:center;">This step secures the database and enables cross-device sync.</div>
      <label style="display:block; font-size:12px; color:#163021; font-weight:800; margin:10px 0 6px;">Email</label>
      <input id="fb-email" type="email" autocomplete="email" style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid #d7ded9; outline:none;" />
      <label style="display:block; font-size:12px; color:#163021; font-weight:800; margin:10px 0 6px;">Password</label>
      <input id="fb-pass" type="password" autocomplete="current-password" style="width:100%; padding:10px 12px; border-radius:12px; border:1px solid #d7ded9; outline:none;" />
      <div id="fb-err" style="display:none; margin-top:10px; padding:10px 12px; border-radius:12px; background:rgba(201,58,58,.12); color:#8c2020; font-size:13px; border:1px solid rgba(201,58,58,.20)"></div>
      <div style="display:flex; gap:10px; margin-top:14px;">
        <button id="fb-signin" style="flex:1; border:0; cursor:pointer; padding:10px 12px; border-radius:12px; font-weight:900; background:var(--green); color:#fff;">Sign in</button>
        <button id="fb-create" style="flex:1; border:1px solid #cfe2d6; cursor:pointer; padding:10px 12px; border-radius:12px; font-weight:900; background:#e3f0e7; color:#0b2b19;">Create account</button>
      </div>
      <div style="margin-top:10px; font-size:12px; color:#6b7a70; text-align:center;">After this, you'll still log into the ACE app with your app username/password.</div>
    </div>
  `;

  document.body.appendChild(gate);
  return gate;
}

function showFirebaseGate(){
  const gate = ensureFirebaseGate();
  gate.style.display = 'flex';
}

function hideFirebaseGate(){
  const gate = document.getElementById('fb-gate');
  if(gate) gate.style.display = 'none';
}

async function initFirebaseAuthAndSync(){
  // Wait for module script to initialise
  try{
    if(window.__aceFirebaseReady) await window.__aceFirebaseReady;
  }catch(e){}
  if(!hasFirebase()) return;

  showFirebaseGate();

  const { auth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword } = window.__aceFirebase;

  // Wire buttons once
  const gate = ensureFirebaseGate();
  const emailEl = gate.querySelector('#fb-email');
  const passEl = gate.querySelector('#fb-pass');
  const errEl  = gate.querySelector('#fb-err');
  const btnIn  = gate.querySelector('#fb-signin');
  const btnCr  = gate.querySelector('#fb-create');

  const setErr = (msg)=>{
    if(!errEl) return;
    if(msg){ errEl.textContent = msg; errEl.style.display='block'; }
    else { errEl.style.display='none'; errEl.textContent=''; }
  };

  if(btnIn && !btnIn.__wired){
    btnIn.__wired = true;
    btnIn.addEventListener('click', async ()=>{
      setErr('');
      const email = (emailEl?.value||'').trim();
      const pass  = (passEl?.value||'').trim();
      if(!email || !pass) return setErr('Enter email and password.');
      try{
        await signInWithEmailAndPassword(auth, email, pass);
      }catch(e){
        setErr(e?.message || 'Sign-in failed.');
      }
    });
  }

  if(btnCr && !btnCr.__wired){
    btnCr.__wired = true;
    btnCr.addEventListener('click', async ()=>{
      setErr('');
      const email = (emailEl?.value||'').trim();
      const pass  = (passEl?.value||'').trim();
      if(!email || !pass) return setErr('Enter email and password.');
      try{
        await createUserWithEmailAndPassword(auth, email, pass);
      }catch(e){
        setErr(e?.message || 'Account creation failed.');
      }
    });
  }

  // React to auth changes
  onAuthStateChanged(auth, async (user)=>{
    try{
      if(user){
        hideFirebaseGate();
        // Stamp identity into session for audit traceability.
        state.session.firebaseUid = user.uid;
        state.session.firebaseEmail = user.email || null;

        // Start realtime sync.
        startCloudSync();

        // Reconcile local vs cloud state on sign-in.
        // If cloud is newer, adopt it. If local is newer (or cloud missing), push local to cloud.
        try{
          const payload = await loadStateFromCloud();
          const localTs = (state && typeof state.__localUpdatedAt === 'number') ? state.__localUpdatedAt : 0;
          const cloudState = payload ? payload.state : null;
          const cloudTs = payload ? (payload.updatedAtMs || 0) : 0;

          if(cloudState && cloudTs && (!localTs || cloudTs > localTs)){
            // Apply cloud
            const base = defaultState();
            const loaded = Object.assign(base, cloudState, {
              session: Object.assign({}, base.session, state.session || {}),
              colleagues: Array.isArray(cloudState.colleagues)?cloudState.colleagues:base.colleagues,
              managers: Array.isArray(cloudState.managers)?cloudState.managers:base.managers,
              absences: Array.isArray(cloudState.absences)?cloudState.absences:[],
              partShifts: Array.isArray(cloudState.partShifts)?cloudState.partShifts:[],
              medicalReports: Array.isArray(cloudState.medicalReports)?cloudState.medicalReports:[],
              restrictions: Array.isArray(cloudState.restrictions)?cloudState.restrictions:[],
              flexibleLeave: Array.isArray(cloudState.flexibleLeave)?cloudState.flexibleLeave:[],
              ihc: Array.isArray(cloudState.ihc)?cloudState.ihc:[],
              rehab: Array.isArray(cloudState.rehab)?cloudState.rehab:[],
              illHealth: Array.isArray(cloudState.illHealth)?cloudState.illHealth:[],
              bereavement: Array.isArray(cloudState.bereavement)?cloudState.bereavement:[],
              awol: Array.isArray(cloudState.awol)?cloudState.awol:[],
              meDays: Array.isArray(cloudState.meDays)?cloudState.meDays:[],
              lateRTW: Array.isArray(cloudState.lateRTW)?cloudState.lateRTW:[],
              investigations: Array.isArray(cloudState.investigations)?cloudState.investigations:[],
              warnings: Array.isArray(cloudState.warnings)?cloudState.warnings:[],
              daTests: Array.isArray(cloudState.daTests)?cloudState.daTests:[],
              positiveRocs: Array.isArray(cloudState.positiveRocs)?cloudState.positiveRocs:[],
              completedAbsences: Array.isArray(cloudState.completedAbsences)?cloudState.completedAbsences:[],
              completedLogs: Array.isArray(cloudState.completedLogs)?cloudState.completedLogs:[],
              completedUpcoming: Array.isArray(cloudState.completedUpcoming)?cloudState.completedUpcoming:[],
              recentColleagues: Array.isArray(cloudState.recentColleagues)?cloudState.recentColleagues:[],
              users: Array.isArray(cloudState.users)?cloudState.users:[],
              auditTrail: Array.isArray(cloudState.auditTrail)?cloudState.auditTrail:[]
            });
            loaded.__localUpdatedAt = cloudTs;
            state = loaded;
            ensureAuditIds();
            try{ applySession(); }catch(e){}
            try{ renderCurrentTab(); }catch(e){}
          }else{
            // Push local (bootstrap or overwrite stale cloud)
            const clone = JSON.parse(JSON.stringify(state));
            clone.session = {}; // never store session in cloud
            await saveStateToCloud(clone);
          }
        }catch(e){}
      }else{
        // Signed out; stop syncing and gate access.
        stopCloudSync();
        showFirebaseGate();
      }
    }catch(e){
      console && console.error && console.error(e);
    }
  });
}

/* ---------- Session ---------- */
const loginView = document.getElementById("login-screen");
const appView = document.getElementById("app-view");

function applySession(){
  if(state.session.loggedIn){
    loginView.style.display = "none";
    appView.style.display = "block";
    document.getElementById("whoami").textContent = state.session.username;
    document.getElementById("dept-filter").value = ui.dept || "ALL";
    // Initialise enhanced UI features once after successful login.  Guard against
    // re-initialising on subsequent applySession calls by checking a flag on
    // the window object.
    if(!window.__aceEnhancementsInit){
      if(typeof setupEnhancements === 'function'){
        setupEnhancements();
        window.__aceEnhancementsInit = true;
      }
    }
  }else{
    loginView.style.display = "flex";
    appView.style.display = "none";
  }
}
applySession();

// Require Firebase sign-in and start cloud sync.
try{ initFirebaseAuthAndSync(); }catch(e){ console && console.error && console.error(e); }

/* ---------- Login handlers (rewritten for reliability) ---------- */
function initLogin(){
  const form = document.getElementById("login-form");
  const uEl = document.getElementById("username");
  const pEl = document.getElementById("password");
  const err = document.getElementById("login-error");
  if(!form || !uEl || !pEl) return;

  const clearErr = ()=>{ if(err) err.style.display = "none"; };
  uEl.addEventListener("input", clearErr);
  pEl.addEventListener("input", clearErr);

  form.addEventListener("submit", async (e)=>{
    // Hard stop any default navigation (prevents "fields clear" behaviour)
    e.preventDefault();
    e.stopPropagation();
    await doLogin();
    return false;
  }, true);
}

async function doLogin(){
  const u = (document.getElementById("username").value || "").trim();
  const p = (document.getElementById("password").value || "");
  const candidate = USERS.find(x => x.username === u);
  const ok = candidate ? await verifyPassword(candidate, p) : false;
  const match = ok ? candidate : null;
  const err = document.getElementById("login-error");
  if(!match){
    if(err) err.style.display = "block";
    return;
  }
  if(err) err.style.display = "none";

  // Persist session
  state.session.loggedIn = true;
  state.session.username = match.username;
  state.session.role = match.role;
  // Grant full privileges to the ACETEST user regardless of role.  This ensures
  // that ACETEST retains deletion and admin rights even if defined as a
  // non-admin role in the USERS array.  Without this override, the user
  // would inherit the role from the USERS definition which defaults to
  // 'user'.
  if(match.username === 'ACETEST'){
    state.session.canDelete = true;
    state.session.canAdmin  = true;
    state.session.adminUnlocked = true;
  }
  saveState();

  // Swap views + render
  applySession();
  renderNav();
  openTab(ui.tab || "absence");
}

// Bind login after script load
initLogin();

document.getElementById("logout-btn").addEventListener("click", ()=>{
  state.session.loggedIn = false;
  state.session.username = null;
  state.session.role = null;
  saveState();
  applySession();
});

/* ---------- Navigation ---------- */
document.querySelectorAll(".navHeader").forEach(btn=>{
  const group = btn.dataset.group;
  btn.addEventListener("click", ()=>{
    ui.groups[group] = !ui.groups[group];
    saveUI();
    renderNav();
  });
});
document.querySelectorAll(".navList button[data-tab]").forEach(btn=>{
  btn.addEventListener("click", ()=>openTab(btn.dataset.tab));
});

document.getElementById("dept-filter").addEventListener("change", (e)=>{
  ui.dept = e.target.value;
  saveUI();
  renderCurrentTab();
});

function renderNav(){
  // show/hide lists + arrow
  document.querySelectorAll(".navHeader").forEach(h=>{
    const g = h.dataset.group;
    const open = !!ui.groups[g];
    const list = document.querySelector(`.navList[data-list="${g}"]`);
    if(list) list.style.display = open ? "block" : "none";
    // Only update the arrow indicator if a span exists.  Some nav headers
    // like the Recents section are plain divs without a <span> for the
    // arrow, so h.querySelector("span") may return null.  Guard
    // against null before updating textContent.
    const arrowEl = h.querySelector('span');
    if(arrowEl) arrowEl.textContent = open ? '▾' : '▸';
  });
  // active tab
  document.querySelectorAll(".navList button[data-tab]").forEach(b=>{
    b.classList.toggle("active", b.dataset.tab === ui.tab);
  });

  // Hide or show the Admin navigation tab based on user permissions.  Users
  // must have the canAdmin permission (or role 'admin') to see the Admin tab.
  const adminBtn = document.querySelector('button[data-tab="admin"]');
  let canSeeAdmin = false;
  if (state.session) {
    // Determine whether the current session should reveal admin-only tabs.  A session
    // may view admin areas if the user is flagged canAdmin, has an admin role, or
    // has unlocked admin mode for the current session.  Store this in a single
    // variable so Settings can reuse the same logic.  Boolean coercion ensures a
    // clean true/false value.
    canSeeAdmin = !!(state.session.canAdmin || state.session.role === 'admin' || state.session.adminUnlocked);
  }
  if(adminBtn){
    adminBtn.style.display = canSeeAdmin ? '' : 'none';
  }
  // Hide or show the Settings navigation tab based on the same criteria as the
  // Admin tab.  Do not recalculate the permission separately to avoid drift; reuse
  // the canSeeAdmin value computed above.
  const settingsBtn = document.querySelector('button[data-tab="settings"]');
  if(settingsBtn){
    settingsBtn.style.display = canSeeAdmin ? '' : 'none';
  }

  // After adjusting nav and permissions, update the recently viewed colleagues list.
  // updateRecentColsNav is defined later in the script; guard against errors if not yet defined.
  try {
    if (typeof updateRecentColsNav === 'function') {
      updateRecentColsNav();
    }
  } catch (err) {
    /* ignore */
  }
}
function openTab(tab){
  // Wrap navigation rendering in a try-catch.  If an error occurs during
  // renderNav or renderCurrentTab, show an alert to diagnose the problem.
  // from either the Admin tab or the Settings tab, prompt to confirm logging out
  // of admin mode.  A cancellation cancels the tab switch.  When confirmed,
  // clear the adminUnlocked flag and persist state before continuing.
  if(state.session && state.session.adminUnlocked && tab !== 'admin' && tab !== 'settings'){
    // Never prompt ACETEST to exit admin mode; the special user remains in
    // admin mode across navigation.  For other users, confirm and reset the
    // adminUnlocked flag upon leaving Admin or Settings.
    if(state.session.username !== 'ACETEST'){
      if(!confirm('Admin mode will be logged out, would you like to continue?')){
        return;
      }
      state.session.adminUnlocked = false;
      saveState();
      // When leaving admin mode, renderNav will hide admin/settings tabs if
      // appropriate.  Continue to open the requested tab.
    }
  }
  // Intercept opening of the Admin or Settings tab.  If the admin area has not been
  // unlocked in this session, prompt for credentials.  The session flag
  // adminUnlocked is set when the correct admin credentials are entered
  // via openAdminLoginModal.  If not unlocked, show the modal and abort
  // changing tabs.  After successful login, open the requested tab.
  if((tab === 'admin' || tab === 'settings') && !(state.session && state.session.adminUnlocked)){
    openAdminLoginModal(() => {
      ui.tab = tab;
      saveUI();
      renderNav();
      renderCurrentTab();
    });
    return;
  }
  ui.tab = tab;
  saveUI();
  renderNav();
  renderCurrentTab();
}

// Expose openTab to the global scope so it can be called from inline
// onclick handlers in the navigation markup.  Without this assignment
// openTab may not be available on the window object depending on
// script scoping and bundling.  Assigning here ensures that
// `window.openTab('someTab')` will invoke the tab switching logic.
window.openTab = openTab;

// Attach sidebar navigation handler outside of setupEnhancements so it
// always registers, regardless of whether enhancements initialise
// correctly.  This delegated click listener intercepts any button
// within the sidebar with a data-tab attribute and opens the
// corresponding tab.  By registering here, after openTab has been
// declared, we ensure the handler can call openTab safely.  We use
// preventDefault to avoid unexpected form submissions or button
// behaviours, and do not call stopPropagation so built‑in handlers
// (e.g. for groups collapsing) can also run.
(function(){
  const sidebarEl = document.querySelector('.sidebar');
  if(sidebarEl){
    sidebarEl.addEventListener('click', function(e){
      // Determine which navigation button was clicked.  Users often click
      // on the list item itself rather than the button element, so we
      // search both up and down the DOM tree to find a button with a
      // data-tab attribute.  First check if the event target or any of
      // its ancestors up to the sidebar is a button with data-tab.
      let btnEl = e.target.closest && e.target.closest('button[data-tab]');
      // If not found, look for a button inside the closest list item
      // container.  This makes the entire list item clickable even if
      // spacing or margins extend beyond the button element.
      if(!btnEl){
        const liEl = e.target.closest && e.target.closest('li');
        if(liEl){
          btnEl = liEl.querySelector('button[data-tab]');
        }
      }
      if(!btnEl) return;
      e.preventDefault();
      const tabName = btnEl.getAttribute('data-tab');
      if(tabName){
        openTab(tabName);
      }
    });
  }
})();
function renderCurrentTab(){
  const host = document.getElementById("tab-host");
  host.innerHTML = "";
  // Always update breadcrumb and last-updated indicators when changing
  // tabs.  Because renderCurrentTab is called after ui.tab has been
  // assigned (typically via openTab), we can rely on ui.tab here.  Guard
  // against undefined functions if the enhancements script has not
  // initialised yet (for example on first page load before setup).
  if (typeof updateBreadcrumb === 'function') {
    updateBreadcrumb(ui.tab);
  }
  if (typeof updateLastUpdated === 'function') {
    updateLastUpdated();
  }

  const tab = ui.tab;
  const map = {
    absence: renderAbsence,
    partshift: renderPartShift,
    medical: renderMedical,
    restrictions: renderRestrictions,
    flexible: renderFlexible,
    ihc: renderIHC,
    rehab: renderRehab,
    illhealth: renderIllHealth,
    bereavement: renderBereavement,
    awol: renderAWOL,
    medays: renderMeDays,
    latertw: renderLateRTW,
    colleagues: renderColleagues,
    investigations: renderInvestigations,
    warnings: renderWarnings,
    da: renderDA,
    positiveRoc: renderPositiveRoc,
    // New tabs for people and admin
    upcoming: renderUpcoming,
    completed: renderCompleted,
    dashboard: renderDashboard,
    admin: renderAdmin,
    profile: renderProfile
    ,settings: renderSettings
  };
  (map[tab] || renderAbsence)(host);
}

/* ---------- Lookups ---------- */
function deptPass(colleagueId){
  const dept = ui.dept || "ALL";
  if(dept === "ALL") return true;
  const c = state.colleagues.find(x=>x.id===colleagueId);
  return c && c.department === dept;
}
function colleagueOptions(selectedId=""){
  const list = state.colleagues
    .filter(c => (ui.dept==="ALL" || c.department===ui.dept))
    .map(c => `<option value="${escapeHtml(c.id)}" ${c.id===selectedId?"selected":""}>${escapeHtml(c.name)} (${escapeHtml(c.id)})</option>`)
    .join("");
  return `<option value="">-- Select colleague --</option>${list}`;
}
function managerOptions(selectedId=""){
  const list = state.managers
    .filter(m => (ui.dept==="ALL" || m.department===ui.dept))
    .map(m => `<option value="${escapeHtml(m.id)}" ${m.id===selectedId?"selected":""}>${escapeHtml(m.name)} - ${escapeHtml(m.department)}</option>`)
    .join("");
  return `<option value="">-- Select manager --</option>${list}`;
}
function colleagueName(id){
  const c = state.colleagues.find(x=>x.id===id);
  return c ? c.name : id;
}
function managerName(id){
  const m = state.managers.find(x=>x.id===id);
  return m ? `${m.name} (${m.department})` : id;
}

// Helper functions to compute colleague status, live warnings and restrictions
// Determine if a colleague is currently absent based on their absence records.
function isCurrentlyAbsent(colId){
  const today = new Date().toISOString().split("T")[0];
  for(const rec of state.absences || []){
    if(rec.colleagueId !== colId) continue;
    const events = rec.events || [];
    if(events.length){
      const ev = events[0];
      const expected = ev.expectedReturn;
      // Consider absent if no expectedReturn or expectedReturn is today or later
      if(!expected) return true;
      if(expected >= today) return true;
    }
  }
  return false;
}
// Determine if a colleague has any live warnings
function hasWarnings(colId){
  return (state.warnings || []).some(w => w.colleagueId === colId);
}
// Determine if a colleague is on any restrictions
function hasRestrictions(colId){
  return (state.restrictions || []).some(r => r.colleagueId === colId);
}

// Return the action of the most recent warning for a colleague. If there
// are no warnings this returns an empty string. Warnings are unshifted
// when created so index 0 is the latest.
function latestWarningAction(colId){
  const list = (state.warnings || []).filter(w => w.colleagueId === colId);
  return list.length ? (list[0].action || "") : "";
}

// Determine the restriction type for a colleague. If they have any
// permanent restrictions, return "Permanent". Otherwise if they have
// temporary restrictions, return "Temporary". If none, return empty
// string.
function restrictionTypeFor(colId){
  const list = (state.restrictions || []).filter(r => r.colleagueId === colId);
  if(list.some(r => r.restriction === "Permanent")) return "Permanent";
  if(list.some(r => r.restriction === "Temporary")) return "Temporary";
  return "";
}

// Export the current modal contents to a print-friendly page. This
// function collects all labelled fields in the modal body and prints
// them in a simple list. The user can then save or print to PDF from
// the browser's print dialog. It is invoked by the PDF button added
// in openModal().
function exportModalToPDF(){
  // Grab the modal title and body
  const title = modalTitle.textContent || "Details";
  const lines = [];
  // For each field container, capture its label and current value. We
  // specifically target .field elements to avoid accidental capture of
  // decorative text. Within each field, we look for the first label
  // element for the label, and the first input/select/textarea for
  // the value. If the field contains none of these, we fall back to
  // the element's text content.
  modalBody.querySelectorAll('.field').forEach(field => {
    const labelEl = field.querySelector('label');
    const inputEl = field.querySelector('input, select, textarea');
    const label = labelEl ? labelEl.textContent.trim() : '';
    let value = '';
    if(inputEl){
      if(inputEl.tagName === 'SELECT'){
        const sel = inputEl.selectedIndex;
        if(sel >= 0) value = inputEl.options[sel].textContent.trim();
        else value = inputEl.value || '';
      }else{
        value = inputEl.value || inputEl.textContent || '';
      }
    }else{
      value = field.textContent.trim();
    }
    if(label || value){
      lines.push(`${label}${label?': ':''}${value}`);
    }
  });
  // Fallback: if no field elements were found, attempt to export plain text
  if(lines.length === 0){
    lines.push(modalBody.innerText || '');
  }
  const text = lines.join('\n');
  // Create a new window with simple HTML and print
  const w = window.open('', '_blank');
  const escapedTitle = escapeHtml(title);
  const escapedText = escapeHtml(text).replace(/\n/g, '<br>');
  w.document.write(`<!doctype html><html><head><title>${escapedTitle}</title></head><body>`);
  w.document.write(`<h2>${escapedTitle}</h2><p style="white-space:pre-wrap;font-family:inherit;">${escapedText}</p>`);
  w.document.write('</body></html>');
  w.document.close();
  // trigger print after slight delay to allow rendering
  setTimeout(() => { w.print(); w.close(); }, 100);
}

// Generic helper to validate times in HH:MM format.  Returns true for
// empty strings (optional fields).  Otherwise ensures hours are 00–23
// and minutes are 00–59.  Leading zeros are required.
function isValidTimeString(val){
  if(!val) return true;
  // Trim surrounding whitespace before validation
  const t = String(val).trim();
  return /^([01]\d|2[0-3]):[0-5]\d$/.test(t);
}

// Helper to compare two time strings (HH:MM) and return minutes since midnight.
// Returns NaN if the format is invalid.  Used for range checks.
function timeToMinutes(t){
  if(!isValidTimeString(t)) return NaN;
  const [hh, mm] = t.split(":");
  return parseInt(hh,10) * 60 + parseInt(mm,10);
}

// Helper to convert a Date or ISO string to a YYYY‑MM‑DD string for
// duplicate detection.  Accepts either a Date object or a string and
// falls back to empty string on invalid input.
function toISODatePart(d){
  try{
    if(!d) return "";
    const date = (d instanceof Date) ? d : new Date(d);
    if(!date || isNaN(date)) return "";
    return date.toISOString().split("T")[0];
  }catch(e){
    return "";
  }
}

// Export a colleague's profile to a print friendly page.  This
// function gathers summary metrics, history entries and audit log
// entries for the given colleague and opens a printable window.  It
// formats the data into simple HTML tables to preserve structure in
// the printed output.  See openColProfileModal() for the
// corresponding UI button.
function exportProfileToPDF(colId){
  if(!colId) return;
  const name = colleagueName(colId) || colId;
  // Build summary metrics
  const stats = calculateColStats(colId);
  const summaryRows = [];
  /*
     Compose the list of summary rows for the profile export.  We no
     longer display absences counts over 4, 8 and 52 weeks in the
     colleague profile – those metrics are still calculated by
     calculateColStats() but are not shown here.  Instead we show
     absences over the last 26 weeks along with other event types
     (Late return to work, Part shift and Me days) and the usual
     counts for warnings, investigations and restrictions.  These
     labels mirror those shown in the interactive colleague profile
     cards.  See calculateColStats() for definitions of the
     corresponding values (abs26, late26, part26, me52).  */
  [
    ['Absences (last 26 weeks)', stats.abs26],
    ['Late RTW (last 26 weeks)', stats.late26],
    ['Part shift (last 26 weeks)', stats.part26],
    ['Me days (last 52 weeks)', stats.me52],
    ['Warnings', stats.warnings],
    ['Investigations', stats.investigations],
    ['Restrictions', stats.restrictions],
    ['Restrictions overdue', stats.restrictionsDue]
  ].forEach(([label, value]) => {
    summaryRows.push(`<tr><th style="text-align:left; padding:4px 8px;">${escapeHtml(label)}</th><td style="padding:4px 8px;">${escapeHtml(String(value))}</td></tr>`);
  });
  // Build history entries.  Use buildColHistoryEntries() to get
  // timeline entries sorted newest first.  Each entry contains date,
  // description and the category name.  We reuse the logic from
  // buildColHistoryHTML() but produce a simple table instead of
  // interactive timeline items.
  const histEntries = buildColHistoryEntries(colId) || [];
  // Convert history entries into table rows.  buildColHistoryEntries
  // returns objects with properties {date: Date, label: string, details: string}.
  // Use these rather than non‑existent timestamp/description properties.
  const histRows = histEntries.map(e => {
    const dateStr = escapeHtml(toUKDate(e.date));
    return `<tr><td style="padding:4px 8px; white-space:nowrap;">${dateStr}</td><td style="padding:4px 8px;">${escapeHtml(e.details || '')}</td><td style="padding:4px 8px;">${escapeHtml(e.label || '')}</td></tr>`;
  });
  // Build audit entries.  Filter the global audit trail for this
  // colleague.  Each entry contains a date/time, action, entity and
  // details.  We'll build rows accordingly.
  const auditRows = [];
  const audit = (state.auditTrail || []).filter(a => a.colleagueId === colId);
  // Sort newest first by timestamp property 'ts'.  Fall back to raw string if not a valid date.
  audit.sort((a,b) => new Date(b.ts) - new Date(a.ts));
  audit.forEach(a => {
    const d = new Date(a.ts);
    const dateStr = isNaN(d) ? escapeHtml(String(a.ts)) : escapeHtml(toUKDateTime(d));
    auditRows.push(`<tr><td style="padding:4px 8px; white-space:nowrap;">${dateStr}</td><td style="padding:4px 8px;">${escapeHtml(a.action)}</td><td style="padding:4px 8px;">${escapeHtml(a.entity)}</td><td style="padding:4px 8px;">${escapeHtml(a.details || '')}</td></tr>`);
  });
  // Compose HTML for print
  const w = window.open('', '_blank');
  const escapedName = escapeHtml(name);
  w.document.write(`<!doctype html><html><head><title>Profile — ${escapedName}</title>`);
  // Basic styles for print tables and headings
  w.document.write(`<style>
    body { font-family: sans-serif; margin:20px; }
    h2 { margin:0 0 10px; }
    table { border-collapse: collapse; width:100%; margin-bottom:20px; }
    th, td { border:1px solid #ddd; padding:4px 6px; }
    th { background:#f5f5f5; text-align:left; }
    caption { text-align:left; font-weight:bold; margin-bottom:4px; }
  </style></head><body>`);
  w.document.write(`<h2>Colleague Profile — ${escapedName}</h2>`);
  // Summary table
  w.document.write(`<table><caption>Summary metrics</caption><tbody>${summaryRows.join('')}</tbody></table>`);
  // History table
  if(histRows.length){
    w.document.write(`<table><caption>History</caption><thead><tr><th>Date</th><th>Description</th><th>Category</th></tr></thead><tbody>${histRows.join('')}</tbody></table>`);
  }else{
    w.document.write(`<p>No history records.</p>`);
  }
  // Audit table
  if(auditRows.length){
    w.document.write(`<table><caption>Audit log</caption><thead><tr><th>Date</th><th>Action</th><th>Entity</th><th>Details</th></tr></thead><tbody>${auditRows.join('')}</tbody></table>`);
  }else{
    w.document.write(`<p>No audit log entries.</p>`);
  }
  w.document.write('</body></html>');
  w.document.close();
  setTimeout(() => { w.print(); w.close(); }, 200);
}

/* ---------- Modal helpers ---------- */
const backdrop = document.getElementById("modal-backdrop");
const modalTitle = document.getElementById("modal-title");
const modalBody = document.getElementById("modal-body");
const modalFooter = document.getElementById("modal-footer");
document.getElementById("modal-close").addEventListener("click", closeModal);
// Disable closing modal when clicking outside. The user must use the close/cancel buttons.
backdrop.addEventListener("click", (e)=>{ /* clicking the backdrop no longer closes the modal */ });
window.addEventListener("keydown", (e)=>{ if(e.key==="Escape" && backdrop.classList.contains("show")) closeModal(); });

function openModal(title, bodyHTML, footerButtons){
  modalTitle.textContent = title;
  modalBody.innerHTML = bodyHTML;
  modalFooter.innerHTML = "";
  // Insert a PDF export button on every modal. This will collect the
  // current field values and open a print preview allowing the user to
  // save as PDF. Placed before other footer buttons for visibility.
  const pdfBtn = document.createElement("button");
  pdfBtn.className = "btn";
  pdfBtn.textContent = "Export PDF";
  pdfBtn.addEventListener("click", exportModalToPDF);
  modalFooter.appendChild(pdfBtn);

  // Render supplied footer buttons (e.g. Save/Cancel) after the PDF button
  footerButtons.forEach(b=>{
    const btn = document.createElement("button");
    btn.className = "btn " + (b.kind||"");
    btn.textContent = b.label;
    btn.addEventListener("click", b.onClick);
    modalFooter.appendChild(btn);
  });
  backdrop.classList.add("show");

  // Automatically show native date/time pickers on focus or click within modals.
  //
  // Many users expected to open the calendar or time selection by clicking
  // directly on the input.  Previously the built‑in pickers only appeared
  // when using the keyboard (e.g. Alt+Down) which was not intuitive and
  // caused confusion.  To improve usability, attach listeners to any
  // <input> elements of type date, time or datetime‑local inside the
  // modal body.  When the field receives a focus or click event the
  // native picker is triggered via the showPicker() method if it exists.
  // Checking for showPicker prevents errors in browsers that do not
  // support this API.  These listeners are added after the modal
  // content is inserted to ensure the inputs exist in the DOM.
  try {
    // Use a short timeout so the DOM has rendered before querying.
    setTimeout(() => {
      // Only automatically open native pickers for date and datetime-local inputs.
      // We deliberately exclude time inputs so users can manually type times without
      // the picker immediately popping open on focus. Time inputs will still
      // present the native picker when the user clicks on the clock icon.
      const inputs = modalBody.querySelectorAll('input[type="date"], input[type="datetime-local"]');
      inputs.forEach(inp => {
        const handler = () => {
          if (typeof inp.showPicker === 'function') {
            try {
              inp.showPicker();
            } catch (e) {
              // Some browsers may throw if picker cannot be shown; ignore.
            }
          }
        };
        // Bind both focus and click events.  focus captures keyboard tabbing,
        // click captures mouse interactions.
        inp.addEventListener('focus', handler);
        inp.addEventListener('click', handler);
      });
    }, 0);
  } catch (e) {
    // In case modalBody isn't available yet or other unexpected error
    // occurs, fail silently without blocking modal functionality.
  }
}
function closeModal(){
  backdrop.classList.remove("show");
  modalBody.innerHTML = "";
  modalFooter.innerHTML = "";
}


/* ---- Conduct: Investigations ---- */
function renderInvestigations(host){
  // Build rows for each investigation for the table
  const rows = (state.investigations || [])
    .filter(r => deptPass(r.colleagueId))
    .map(r => [
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(r.caseRef || ""),
      escapeHtml(toUKDate(r.date)),
      escapeHtml(r.time || ""),
      escapeHtml(r.outcome || ""),
      escapeHtml(r.details || ""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Build main investigations table
  let invTable = `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Conducting manager</th>
          <th>Case reference</th>
          <th>Date of investigation</th>
          <th>Time</th>
          <th>Outcome</th>
          <th>Details</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="8" class="muted">No investigations logged yet. Use + Add investigation to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `;
  // Build upcoming investigations (investigation dates in future) for this tab
  const upcomingItems = [];
  // We no longer display upcoming investigation actions within the Investigations tab itself.
  // Any future investigation dates will still appear in the global Upcoming Actions tab via gatherUpcoming.
  // Initialise upcomingTable to an empty string so nothing is appended below the main table.
  let upcomingTable = "";
  // Render card with filter bar
  renderShell(host, "Investigations", "Log investigation cases and outcomes.", `
    <button class="btn primary" id="inv-add">+ Add investigation</button>
    <button class="btn" id="inv-export">Export CSV</button>
  `, `${filterUI('investigations', false)}`, invTable + upcomingTable);

  // Add button handlers for adding and exporting
  const addBtn = document.getElementById("inv-add");
  if(addBtn) addBtn.addEventListener("click", () => openInvestigationModal());
  const exportBtn = document.getElementById("inv-export");
  if(exportBtn) exportBtn.addEventListener("click", () => {
    const csv = [[
      "Colleague","Colleague ID","Conducting Manager","Case Reference Number","Date of investigation","Time of investigation","Outcome","Details"
    ]];
    (state.investigations || []).filter(r => deptPass(r.colleagueId)).forEach(r => {
      csv.push([
        colleagueName(r.colleagueId),
        r.colleagueId,
        managerName(r.managerId),
        r.caseRef || "",
        toUKDate(r.date),
        r.time || "",
        r.outcome || "",
        r.details || ""
      ]);
    });
    downloadCSV("Investigations.csv", csv);
  });

  // Table action handlers for complete/edit/delete
  host.querySelectorAll("button[data-act]").forEach(b => {
    b.addEventListener("click", () => {
      const rec = (state.investigations || []).find(x => x.id === b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Investigations", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Check delete permissions before confirming deletion
        if(!(state.session && (state.session.canDelete || state.session.role === 'admin'))){
          alert("You do not have permission to delete.");
          return;
        }
        if(!confirm("Delete this investigation record?")) return;
        // Store index for undo
        const idx = (state.investigations || []).findIndex(x => x.id === rec.id);
        const removed = rec;
        state.investigations = (state.investigations || []).filter(x => x.id !== rec.id);
        saveState();
        renderCurrentTab();
        // Show toast with undo option
        showToast('Investigation deleted', () => {
          if(idx >= 0){
            state.investigations.splice(idx, 0, removed);
            saveState();
            renderCurrentTab();
          }
        });
      } else {
        openInvestigationModal(rec);
      }
    });
  });
  // Handler for completing upcoming investigation actions
  host.querySelectorAll('button[data-act="completeInv"]').forEach(() => {});

  // Highlight rows based on investigation due dates.  Open investigations
  // with dates in the past are marked overdue; those today as due-today;
  // and those within 7 days as due-soon.  Completed investigations are ignored.
  (function(){
    const rows = host.querySelectorAll('tbody tr');
    const today = new Date();
    today.setHours(0,0,0,0);
    const soon = new Date(today.getTime() + 7 * 24 * 3600 * 1000);
    rows.forEach(row => {
      const cells = row.children;
      if(!cells || cells.length < 6) return;
      // Date is in fourth cell (index 3) and outcome in sixth cell (index 5)
      const dateText = cells[3].innerText.trim();
      const outcomeText = cells[5].innerText.trim().toLowerCase();
      // Ignore completed investigations (outcome provided)
      if(outcomeText && outcomeText !== 'to be conducted') return;
      if(!dateText) return;
      // dateText in DD/MM/YYYY format
      const parts = dateText.split('/');
      if(parts.length !== 3) return;
      const d = new Date(parts[2], parts[1]-1, parts[0]);
      if(isNaN(d.getTime())) return;
      let cls = '';
      if(d < today) cls = 'overdue';
      else if(d.getTime() === today.getTime()) cls = 'due-today';
      else if(d <= soon) cls = 'due-soon';
      if(cls) row.classList.add(cls);
    });
  })();

  // ----------------------------------------------------------------------
  // Enable filtering and sorting for the investigations table.  Previously
  // the Investigations tab rendered a filter/search bar via filterUI but
  // never wired up any event listeners to actually apply those controls.
  // As a result, typing in the search box or changing the sort order had
  // no effect on the investigations table.  To fix this we register
  // handlers on both the sort dropdown and the search input.  Whenever
  // either control changes, applyTableFilters is invoked with the
  // investigations prefix and the correct date column index (3), which
  // sorts and filters visible rows.  The initial call to applyFilters
  // ensures the table is sorted on first render.
  {
    const applyFilters = () => applyTableFilters(host, 'investigations', 3);
    ['investigations-filter', 'investigations-search'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openInvestigationModal(rec = null){
  // Determine if new or editing
  const isNew = !rec;
  const r = rec || {
    id: uid(),
    colleagueId: "",
    managerId: "",
    caseRef: "",
    date: "",
    time: "",
    outcome: "To be conducted",
    createdAt: new Date().toISOString()
    ,details: ""
  };

  const outcomeOptions = [
    "To be conducted",
    "Ongoing",
    "No further action",
    "Counselling",
    "Forward to Disciplinary Hearing"
  ];

  const body = `
    <div class="grid">
      <div class="field">
        <label>Colleague</label>
        <select id="inv-col">${colleagueOptions(r.colleagueId)}</select>
      </div>
      <div class="field">
        <label>Conducting Manager</label>
        <select id="inv-man">${managerOptions(r.managerId)}</select>
      </div>

      <div class="field">
        <label>Case Reference Number</label>
        <input id="inv-case" value="${escapeHtml(r.caseRef || "")}" placeholder="e.g. INV-12345" />
      </div>
      <div class="field">
        <label>Date of investigation</label>
        <input id="inv-date" type="date" value="${escapeHtml(r.date || "")}" />
      </div>

      <div class="field">
        <label>Time of investigation</label>
        <input id="inv-time" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.time || "")}" />
      </div>
      <div class="field">
        <label>Investigation outcome</label>
        <select id="inv-outcome">
          ${outcomeOptions.map(v => `<option value="${escapeHtml(v)}" ${v === (r.outcome || "") ? "selected" : ""}>${escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
      <div class="field" style="grid-column:1 / -1">
        <label>Details</label>
        <textarea id="inv-details" rows="4" placeholder="Add any additional investigation details...">${escapeHtml(r.details || "")}</textarea>
      </div>
    </div>
  `;

  openModal(isNew ? "Add Investigation" : "Edit Investigation", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save investigation", kind:"primary", onClick: () => {
      // Capture previous copy for undo when editing
      const prevCopy = rec ? { ...rec } : null;
      // Read user input
      r.colleagueId = document.getElementById("inv-col").value;
      r.managerId   = document.getElementById("inv-man").value;
      r.caseRef     = document.getElementById("inv-case").value.trim();
      // convert date input (yyyy-mm-dd) to string; fromDateInput returns blank if empty
      r.date        = fromDateInput(document.getElementById("inv-date").value);
      // For time we simply read the input string. We do not force a value – optional times
      r.time        = document.getElementById("inv-time").value;
      r.outcome     = document.getElementById("inv-outcome").value;
      r.details     = document.getElementById("inv-details").value.trim();

      // Validate required fields
      if(!r.colleagueId) return alert("Please select a colleague.");
      if(!r.managerId) return alert("Please select a conducting manager.");
      if(!r.caseRef) return alert("Please enter a case reference number.");
      if(!r.date) return alert("Please select a date of investigation.");
      // Time is optional – no validation here
      if(!r.outcome) return alert("Please select an investigation outcome.");

      // Validate time format if provided
      if(r.time && !isValidTimeString(r.time)){
        return alert("Please enter a valid time in HH:MM format.");
      }

      // Save record
      if(isNew){
        (state.investigations || (state.investigations = [])).unshift(r);
      }else{
        state.investigations = state.investigations.map(x => x.id === r.id ? r : x);
      }
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'investigation', r.id, r.colleagueId, r.outcome || '');
      }catch(e){}
      closeModal();
      renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Investigation added', () => {
          state.investigations = state.investigations.filter(x => x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      }else{
        showToast('Investigation updated', () => {
          if(prevCopy){
            const target = state.investigations.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}

// Open modal for adding/editing a warning record
function openWarningModal(rec = null){
  const isNew = !rec;
  const r = rec || {
    id: uid(),
    colleagueId: "",
    managerId: "",
    action: "RWRT",
    reason: "",
    // optional hearing date and time for scheduling a hearing on this warning
    hearingDate: "",
    hearingTime: "",
    createdAt: new Date().toISOString()
  };
  const actionOptions = [
    "RWRT",
    "Counselling",
    "2nd Counselling - Forward to investigation",
    "Verbal Warning",
    "Written Warning",
    "Final Written Warning",
    "Suspended",
    "Dismissed",
    // allow a warning to be created when the hearing is still to be scheduled
    "To be conducted"
  ];
  const body = `
    <div class="grid">
      <div class="field">
        <label>Colleague</label>
        <select id="warn-col">${colleagueOptions(r.colleagueId)}</select>
      </div>
      <div class="field">
        <label>Conducting Manager</label>
        <select id="warn-man">${managerOptions(r.managerId)}</select>
      </div>
      <div class="field">
        <label>Action</label>
        <select id="warn-action">
          ${actionOptions.map(v => `<option value="${escapeHtml(v)}" ${v === (r.action || "") ? "selected" : ""}>${escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
      <div class="field">
        <label>Hearing Date</label>
        <input id="warn-hearing" type="date" value="${escapeHtml(r.hearingDate || "")}" />
      </div>
      <div class="field">
        <label>Time of Hearing</label>
        <input id="warn-hearing-time" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.hearingTime || "")}" />
      </div>
      <div class="field" style="grid-column:1 / -1">
        <label>Reason</label>
        <textarea id="warn-reason" rows="4" placeholder="Add further details...">${escapeHtml(r.reason || "")}</textarea>
      </div>
    </div>
  `;
  openModal(isNew ? "Add Warning" : "Edit Warning", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save warning", kind:"primary", onClick: () => {
      // Capture previous copy for undo
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("warn-col").value;
      r.managerId   = document.getElementById("warn-man").value;
      r.action      = document.getElementById("warn-action").value;
      r.reason      = document.getElementById("warn-reason").value.trim();
      // read optional hearing date and time
      r.hearingDate = document.getElementById("warn-hearing").value || "";
      r.hearingTime = document.getElementById("warn-hearing-time").value || "";
      // Validate required fields
      if(!r.colleagueId) return alert("Please select a colleague.");
      if(!r.managerId) return alert("Please select a conducting manager.");
      if(!r.action) return alert("Please select an action.");
      // Reason is optional

      // Validate hearing time format if provided
      if(r.hearingTime && !isValidTimeString(r.hearingTime)){
        return alert("Please enter a valid hearing time in HH:MM format.");
      }
      if(isNew){
        (state.warnings || (state.warnings = [])).unshift(r);
      }else{
        state.warnings = state.warnings.map(x => x.id === r.id ? r : x);
      }
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'warning', r.id, r.colleagueId, r.action || '');
      }catch(e){}
      closeModal();
      renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Warning added', () => {
          state.warnings = state.warnings.filter(x => x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      }else{
        showToast('Warning updated', () => {
          if(prevCopy){
            const target = state.warnings.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}

/* ---- Conduct: Warnings ---- */
function renderWarnings(host){
  // Build rows for the warnings table
  const rows = (state.warnings || [])
    .filter(r => deptPass(r.colleagueId))
    .map(r => [
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(r.action || ""),
      // display hearing date in UK format if provided
      escapeHtml(r.hearingDate ? toUKDate(r.hearingDate) : ""),
      // display hearing time if provided
      escapeHtml(r.hearingTime || ""),
      escapeHtml(r.reason || ""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);
  // Render using shell helper
  // Main warnings table markup
  let warningsTable = `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Conducting manager</th>
          <th>Action</th>
          <th>Hearing date</th>
          <th>Hearing time</th>
          <th>Reason</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="7" class="muted">No warnings logged yet. Use + Add warning to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `;

  // We no longer display upcoming warning actions within the Warnings tab itself.
  // Any hearing dates will still appear in the global Upcoming Actions tab via the gatherUpcoming logic.
  // Simply initialise upcomingTable to an empty string so nothing is appended below the main table.
  let upcomingTable = "";
  // Render with filter bar
  renderShell(host, "Warnings", "Log disciplinary warnings and actions.", `
    <button class="btn primary" id="warn-add">+ Add warning</button>
    <button class="btn" id="warn-export">Export CSV</button>
  `, `${filterUI('warnings', false)}`, warningsTable + upcomingTable);
  // Add button handlers
  const addBtn = document.getElementById("warn-add");
  if(addBtn) addBtn.addEventListener("click", () => openWarningModal());
  const exportBtn = document.getElementById("warn-export");
  if(exportBtn) exportBtn.addEventListener("click", () => {
    const csv = [[
      "Colleague","Colleague ID","Conducting Manager","Action","Hearing Date","Hearing Time","Reason"
    ]];
    (state.warnings || []).filter(r => deptPass(r.colleagueId)).forEach(r => {
      csv.push([
        colleagueName(r.colleagueId),
        r.colleagueId,
        managerName(r.managerId),
        r.action || "",
        r.hearingDate ? toUKDate(r.hearingDate) : "",
        r.hearingTime || "",
        r.reason || ""
      ]);
    });
    downloadCSV("Warnings.csv", csv);
  });
  // Table action handlers for complete/edit/delete
  host.querySelectorAll("button[data-act]").forEach(b => {
    b.addEventListener("click", () => {
      const rec = (state.warnings || []).find(x => x.id === b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Warnings", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('warnings', rec, 'warning record', renderCurrentTab);
      } else {
        openWarningModal(rec);
      }
    });
  });

  // Add search and sort for warnings.  Use the hearing date column (index 3) for sorting.
  {
    const applyFilters = () => applyTableFilters(host, 'warnings', 3);
    ['warnings-filter','warnings-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
    // After filtering, apply row highlighting based on the hearing date column (index 3).
    const highlightRows = () => {
      const now = new Date();
      host.querySelectorAll('tbody tr').forEach(tr => {
        const cells = tr.querySelectorAll('td');
        if(!cells.length) return;
        const text = cells[3].textContent.trim();
        // Reset classes
        tr.classList.remove('overdue','due-today','due-soon');
        if(!text) return;
        const parts = text.split('/');
        if(parts.length === 3){
          const dueDate = new Date(`${parts[2]}-${parts[1]}-${parts[0]}T00:00:00`);
          if(!isNaN(dueDate.getTime())){
            const diff = dueDate - now;
            if(diff <= 0) tr.classList.add('overdue');
            else if(dueDate.toDateString() === now.toDateString()) tr.classList.add('due-today');
            else if(diff <= 2*24*3600*1000) tr.classList.add('due-soon');
          }
        }
      });
    };
    // Run once on initial render and also when filters change (delayed via event listener)
    highlightRows();
    ['warnings-filter','warnings-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, () => {
          setTimeout(highlightRows, 0);
        });
      }
    });
  }
}

/* ---- Conduct: D&A ---- */
function renderDA(host){
  // Build rows for the D&A table
  const rows = (state.daTests || [])
    .filter(r => deptPass(r.colleagueId))
    .map(r => [
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(toUKDate(r.dateTest) || ""),
      escapeHtml(r.timeStart || ""),
      escapeHtml(r.timeFinish || ""),
      escapeHtml(r.testResult || ""),
      escapeHtml(r.sanction || ""),
      escapeHtml(r.details || ""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Render with filter bar for D&A logs
  renderShell(host, "D&A", "Log drug and alcohol tests.", `
    <button class="btn primary" id="da-add">+ Add D&amp;A</button>
    <button class="btn" id="da-export">Export CSV</button>
  `, `${filterUI('da', false)}`, `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Conducting manager</th>
          <th>Date of test</th>
          <th>Time started</th>
          <th>Time finished</th>
          <th>Test result</th>
          <th>Sanction</th>
          <th>Details</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="9" class="muted">No D&amp;A logs yet.</td></tr>`}
      </tbody>
    </table>
  `);
  // Button handlers
  document.getElementById("da-add")?.addEventListener("click", () => openDATestModal());
  document.getElementById("da-export")?.addEventListener("click", () => {
    const csv = [[
      "Colleague","Colleague ID","Conducting Manager","Date of test","Time started","Time finished","Test result","Sanction","Details"
    ]];
    (state.daTests || []).filter(r=>deptPass(r.colleagueId)).forEach(r => {
      csv.push([
        colleagueName(r.colleagueId),
        r.colleagueId,
        managerName(r.managerId),
        toUKDate(r.dateTest) || "",
        r.timeStart || "",
        r.timeFinish || "",
        r.testResult || "",
        r.sanction || "",
        r.details || ""
      ]);
    });
    downloadCSV("DA_Tests.csv", csv);
  });
  host.querySelectorAll("button[data-act]").forEach(b => {
    b.addEventListener("click", () => {
      const rec = (state.daTests || []).find(x => x.id === b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("D&A", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('daTests', rec, 'D&A record', renderCurrentTab);
      } else {
        openDATestModal(rec);
      }
    });
  });

  // Add filtering and sorting to the D&A table.  Uses the test date column (index 2).
  {
    const applyFilters = () => applyTableFilters(host, 'da', 2);
    ['da-filter','da-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openDATestModal(rec=null){
  const isNew = !rec;
  const r = rec || { id: uid(), colleagueId: "", managerId: "", dateTest: "", timeStart: "", timeFinish: "", testResult: "", sanction: "", details: "", createdAt: new Date().toISOString() };
  const testResultOptions = [
    "Negative for Drugs and Alcohol",
    "Non-Negative - Drugs",
    "Non-Negative - Alcohol",
    "Non-Negative Drugs & Alcohol"
  ];
  const sanctionOptions = [
    "No further action",
    "Suspended pending investigation",
    "Resignation"
  ];
  const body = `
    <div class="grid">
      <div class="field"><label>Conducting manager</label><select id="da-mgr">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Colleague</label><select id="da-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Date of Test</label><input id="da-date" type="date" value="${escapeHtml(r.dateTest||"")}"></div>
      <div class="field"><label>Time Started</label><input id="da-start" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.timeStart||"")}"></div>
      <div class="field"><label>Time Finished</label><input id="da-finish" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.timeFinish||"")}"></div>
      <div class="field"><label>Test result</label><select id="da-result">
        ${testResultOptions.map(opt => `<option value="${escapeHtml(opt)}" ${opt === r.testResult ? "selected" : ""}>${escapeHtml(opt)}</option>`).join("")}
      </select></div>
      <div class="field"><label>Sanction</label><select id="da-sanction">
        ${sanctionOptions.map(opt => `<option value="${escapeHtml(opt)}" ${opt === r.sanction ? "selected" : ""}>${escapeHtml(opt)}</option>`).join("")}
      </select></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="da-details" placeholder="Additional details...">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;
  openModal(isNew ? "Add D&A" : "Edit D&A", body, [
    { label: "Cancel", onClick: closeModal },
    { label: "Save", kind: "primary", onClick: () => {
      const mgr = document.getElementById("da-mgr").value;
      const col = document.getElementById("da-col").value;
      const date = document.getElementById("da-date").value;
      const start = document.getElementById("da-start").value;
      const finish = document.getElementById("da-finish").value;
      const result = document.getElementById("da-result").value;
      const sanction = document.getElementById("da-sanction").value;
      const details = document.getElementById("da-details").value.trim();
      if(!mgr){ alert("Please select a manager"); return; }
      if(!col){ alert("Please select a colleague"); return; }
      if(!date){ alert("Please select a test date"); return; }
      if(!start){ alert("Please enter a start time"); return; }
      if(!finish){ alert("Please enter a finish time"); return; }
      if(!result){ alert("Please select a test result"); return; }
      if(!sanction){ alert("Please select a sanction"); return; }

      // Validate time formats and order
      if(start && !isValidTimeString(start)){
        alert("Please enter a valid start time in HH:MM format.");
        return;
      }
      if(finish && !isValidTimeString(finish)){
        alert("Please enter a valid finish time in HH:MM format.");
        return;
      }
      // Ensure finish time is not earlier than start time if both provided
      if(isValidTimeString(start) && isValidTimeString(finish)){
        const sm = timeToMinutes(start);
        const fm = timeToMinutes(finish);
        if(!isNaN(sm) && !isNaN(fm) && fm < sm){
          alert("Finish time cannot be earlier than start time.");
          return;
        }
      }
      // Reminder prompt about escorting/suspension/resignation
      alert("Please ensure if colleague is suspended that Clock Card is taken and colleague is escorted safely off site. If resignation occurs, please ensure the relevant parties are informed and separation processes take place");
      r.managerId = mgr;
      r.colleagueId = col;
      r.dateTest = date;
      r.timeStart = start;
      r.timeFinish = finish;
      r.testResult = result;
      r.sanction = sanction;
      r.details = details;
      r.createdAt = r.createdAt || new Date().toISOString();
      // Save or update
      if(isNew){
        state.daTests = state.daTests || [];
        state.daTests.unshift(r);
      }else{
        state.daTests = (state.daTests || []).map(x => x.id === r.id ? r : x);
      }
      // Update colleague status if necessary
      const colRec = state.colleagues.find(c => c.id === col);
      if(colRec){
        if(sanction === "Suspended pending investigation"){
          colRec.status = "Suspended";
        }else if(sanction === "Resignation"){
          colRec.status = "Resigned";
        }
      }
      saveState();
      closeModal();
      renderCurrentTab();
    } }
  ]);
}

/* ---- Conduct: Positive ROC ---- */
function renderPositiveRoc(host){
  // Build rows including raffle ticket number.  Undefined values are shown as empty strings.
  const rows = (state.positiveRocs || [])
    .filter(r => deptPass(r.colleagueId))
    .map(r => [
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(toUKDate(r.dateIssued) || ""),
      escapeHtml(r.timeIssued || ""),
      escapeHtml(r.raffleTicket || ""),
      escapeHtml(r.reason || ""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);
  // Include filter bar for Positive ROC logs
  renderShell(host, "Positive ROC", "Log positive ROCs.", `
    <button class="btn primary" id="pr-add">+ Add Positive ROC</button>
    <button class="btn" id="pr-export">Export CSV</button>
  `, `${filterUI('positiveroc', false)}`, `
    <table>
      <thead><tr><th>Colleague</th><th>Conducting manager</th><th>Date issued</th><th>Time issued</th><th>Raffle ticket</th><th>Reason</th><th>Actions</th></tr></thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="7" class="muted">No Positive ROC logs yet.</td></tr>`}
      </tbody>
    </table>
  `);
  document.getElementById("pr-add")?.addEventListener("click", () => openPositiveRocModal());
  document.getElementById("pr-export")?.addEventListener("click", () => {
    // Export includes raffle ticket number
    const csv = [["Colleague","Colleague ID","Conducting Manager","Date issued","Time issued","Raffle ticket","Reason"]];
    (state.positiveRocs || []).filter(r => deptPass(r.colleagueId)).forEach(r => {
      csv.push([
        colleagueName(r.colleagueId),
        r.colleagueId,
        managerName(r.managerId),
        toUKDate(r.dateIssued) || "",
        r.timeIssued || "",
        r.raffleTicket || "",
        r.reason || ""
      ]);
    });
    downloadCSV("PositiveROC.csv", csv);
  });
  host.querySelectorAll("button[data-act]").forEach(b => {
    b.addEventListener("click", () => {
      const rec = (state.positiveRocs || []).find(x => x.id === b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Positive ROC", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('positiveRocs', rec, 'Positive ROC record', renderCurrentTab);
      } else {
        openPositiveRocModal(rec);
      }
    });
  });

  // Enable filtering and sorting for Positive ROC logs.  Uses date issued column (index 2) for sorting.
  {
    const applyFilters = () => applyTableFilters(host, 'positiveroc', 2);
    ['positiveroc-filter','positiveroc-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

/* ---- Profile / Change Password ---- */
function renderProfile(host){
  // Build the change password form
  const formHTML = `
    <form id="change-password-form" class="grid" style="padding:16px">
      <div class="field"><label>Current Password</label><input id="change-cur" type="password" autocomplete="current-password" placeholder="Enter current password"></div>
      <div class="field"><label>New Password</label><input id="change-new" type="password" autocomplete="new-password" placeholder="Enter new password"></div>
      <div class="field"><label>Retype New Password</label><input id="change-new2" type="password" autocomplete="new-password" placeholder="Retype new password"></div>
      <div class="field" style="grid-column:1/-1"><button type="submit" class="btn primary">Change Password</button></div>
    </form>
  `;
  // Render the form inside a shell card
  renderShell(host, "Profile", "Change your account password.", "", "", formHTML);
  // Attach handler after rendering
  const form = host.querySelector("#change-password-form");
  if(form){
    form.addEventListener("submit", (e) => {
      e.preventDefault();
      const cur = (form.querySelector("#change-cur")?.value || "");
      const np  = (form.querySelector("#change-new")?.value || "");
      const np2 = (form.querySelector("#change-new2")?.value || "");
      if(!cur || !np || !np2){
        alert("Please complete all fields");
        return;
      }
      if(np !== np2){
        alert("New passwords do not match");
        return;
      }
      const username = state.session && state.session.username;
      if(!username){
        alert("Not logged in");
        return;
      }
      // Attempt to find custom user account
      let customIndex = -1;
      if(Array.isArray(state.users)){
        customIndex = state.users.findIndex(u => u.username === username);
      }
      if(customIndex >= 0){
        const rec = state.users[customIndex];
        if(rec.password !== cur){
          alert("Current password is incorrect");
          return;
        }
        // update password in custom account
        state.users[customIndex] = Object.assign({}, rec, { password: np });
      } else {
        // fallback to built-in account
        const built = USERS.find(u => u.username === username);
        if(!built || built.password !== cur){
          alert("Current password is incorrect");
          return;
        }
        // Override by adding a custom user record to state.users. Copy permissions.
        const canDel = !!built.canDelete;
        const canAdm = !!(built.canAdmin || built.role === 'admin');
        state.users = state.users || [];
        // If a previous override exists (should not), remove it
        state.users = state.users.filter(u => u.username !== username);
        state.users.push({ username: built.username, password: np, canDelete: canDel, canAdmin: canAdm, persistent: true });
      }
      saveState();
      alert("Password changed successfully.");
      form.reset();
    });
  }
}

function openPositiveRocModal(rec=null){
  // If editing, merge existing record; otherwise create a new empty record with all fields
  const isNew = !rec;
  const r = rec || {
    id: uid(),
    colleagueId: "",
    managerId: "",
    dateIssued: "",
    timeIssued: "",
    reason: "",
    raffleTicket: "",
    createdAt: new Date().toISOString()
  };
  // Build the modal body including a raffle ticket number field.  The grid layout
  // keeps fields aligned in two columns.  The raffle ticket input is a simple
  // text box suitable for numeric values.
  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="pr-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Conducting Manager</label><select id="pr-mgr">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Date issued</label><input id="pr-date" type="date" value="${escapeHtml(r.dateIssued||"")}"></div>
      <div class="field"><label>Time issued</label><input id="pr-time" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.timeIssued||"")}"></div>
      <div class="field"><label>Raffle Ticket Number</label><input id="pr-ticket" type="text" value="${escapeHtml(r.raffleTicket||"")}" placeholder="Ticket #"></div>
      <div class="field" style="grid-column:1/-1"><label>Reason</label><textarea id="pr-reason" placeholder="Reason...">${escapeHtml(r.reason||"")}</textarea></div>
    </div>
  `;
  openModal(isNew ? "Add Positive ROC" : "Edit Positive ROC", body, [
    { label: "Cancel", onClick: closeModal },
    { label: "Save", kind: "primary", onClick: () => {
      const col = document.getElementById("pr-col").value;
      const mgr = document.getElementById("pr-mgr").value;
      const date = document.getElementById("pr-date").value;
      const time = document.getElementById("pr-time").value;
      const ticket = document.getElementById("pr-ticket").value.trim();
      const reason = document.getElementById("pr-reason").value.trim();
      if(!col){ alert("Please select a colleague"); return; }
      if(!mgr){ alert("Please select a manager"); return; }
      if(!date){ alert("Please select a date issued"); return; }
      if(!time){ alert("Please select a time issued"); return; }
      if(!reason){ alert("Please enter a reason"); return; }
      // Persist fields back to record
      r.colleagueId = col;
      r.managerId = mgr;
      r.dateIssued = date;
      r.timeIssued = time;
      r.raffleTicket = ticket;
      r.reason = reason;
      r.createdAt = r.createdAt || new Date().toISOString();
      if(isNew){
        state.positiveRocs = state.positiveRocs || [];
        state.positiveRocs.unshift(r);
      }else{
        state.positiveRocs = (state.positiveRocs || []).map(x => x.id === r.id ? r : x);
      }
      saveState();
      closeModal();
      renderCurrentTab();
    } }
  ]);
}

function renderShell(host, title, hint, actionsHTML, filtersHTML, tableHTML){
  host.innerHTML = `
    <div class="card">
      <div class="cardHeader">
        <div class="header-text">
          <h2>${escapeHtml(title)}</h2>
          <div class="hint">${hint||""}</div>
        </div>
        <div class="actionsRow">${actionsHTML||""}</div>
      </div>
      ${filtersHTML||""}
      <div style="overflow:auto;max-height:68vh;border:1px solid var(--line);border-radius:12px">
        ${tableHTML}
      </div>
    </div>
  `;
}

/* ==========================
   Attendance & Welfare Tabs
   ========================== */

/* ---- Absence (with history/events) ---- */
function renderAbsence(host){
  const rows = state.absences
    .filter(r => deptPass(r.colleagueId))
    .map(r => {
      const latest = (r.events||[])[0];
      return [
        `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
        latest ? escapeHtml(toUKDate(latest.dateStart)) : "",
        latest ? escapeHtml(latest.reason||"") : "",
        latest ? escapeHtml(latest.nextActionType||"") : "",
        latest ? escapeHtml(latest.nextActionDT ? toUKDate(latest.nextActionDT.split("T")[0]) + " " + (latest.nextActionDT.split("T")[1]||"") : "") : "",
        latest ? escapeHtml(toUKDate(latest.sickNoteExpiry)) : "",
        latest ? escapeHtml(toUKDate(latest.expectedReturn)) : "",
        latest ? escapeHtml(latest.cspStopped||"") : "",
        latest ? escapeHtml(latest.sanction||"") : "",
        latest ? escapeHtml(latest.notes||"") : "",
        `<div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn small primary" data-act="addEvent" data-id="${r.id}">Add</button>
          <button class="btn small" data-act="history" data-id="${r.id}">History</button>
          <button class="btn small" data-act="editLatest" data-id="${r.id}">Edit</button>
          <button class="btn small" data-act="rtw" data-id="${r.id}">RTW</button>
          <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
        </div>`
      ];
    });

  const actions = `
    <button class="btn primary" id="add-absence-btn">+ Add absence</button>
    <button class="btn" id="export-absence-btn">Export CSV</button>
  `;
  // Use the shared filter bar for absence.  The prefix 'absence' is used so
  // filterUI generates elements with IDs 'absence-filter' and 'absence-search'.
  const filters = `${filterUI('absence', false)}`;

  const table = `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Absence start</th>
          <th>Reason</th>
          <th>Next action</th>
          <th>Next action date/time</th>
          <th>Sick note expiry</th>
          <th>Expected return</th>
          <th>CSP stopped</th>
          <th>Sanction</th>
          <th>Absence details / notes</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="abs-tbody">
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="11" class="muted">No absences logged yet. Use + Add absence to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `;

  renderShell(host, "Absence", "Log absences with per-absence event history (latest shown).", actions, filters, table);

  const btnAdd = document.getElementById("add-absence-btn");
  btnAdd.addEventListener("click", ()=>openAbsenceModal());

  document.getElementById("export-absence-btn").addEventListener("click", ()=>{
    const csvRows = [["Colleague","Colleague ID","Absence start","Reason","Next action","Next action date/time","Sick note expiry","Expected return","CSP stopped","Sanction","Notes"]];
    state.absences.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      const e = (r.events||[])[0] || {};
      csvRows.push([colleagueName(r.colleagueId), r.colleagueId, toUKDate(e.dateStart), e.reason||"", e.nextActionType||"", e.nextActionDT||"", toUKDate(e.sickNoteExpiry), toUKDate(e.expectedReturn), e.cspStopped||"", e.sanction||"", e.notes||""]);
    });
    downloadCSV("Absences.csv", csvRows);
  });

  // table actions
  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const id = b.dataset.id;
      const act = b.dataset.act;
      const rec = state.absences.find(x=>x.id===id);
      if(!rec) return;
      if(act==="del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('absences', rec, 'absence record', renderCurrentTab);
      }
      if(act==="history"){
        openAbsenceHistory(rec);
      }
      if(act==="addEvent"){
        openAbsenceModal(rec, null, true);
      }
      if(act==="editLatest"){
        const latest = (rec.events||[])[0];
        openAbsenceModal(rec, latest ? latest.id : null, false);
      }
      if(act==="rtw"){
        // Trigger the return to work modal for this absence
        openReturnToWorkModal(rec);
      }
    });
  });

  // Apply search and age filtering for absences using the shared filter controls.  The
  // date column is index 1 (Absence start).  Filtering is performed client-side
  // via applyTableFilters, which interprets the selected range and search term.
  {
    const applyFilters = () => applyTableFilters(host, 'absence', 1);
    ['absence-filter','absence-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openAbsenceModal(existingRecord=null, eventId=null, forceNewEvent=false){
  const isNewAbsence = !existingRecord;
  const record = existingRecord || { id:uid(), colleagueId:"", createdAt:new Date().toISOString(), events:[] };
  const latest = record.events[0] || {};
  let editingEvent = null;

  if(forceNewEvent){
    editingEvent = null;
  }else if(eventId){
    editingEvent = record.events.find(e=>e.id===eventId) || null;
  }else{
    editingEvent = record.events[0] || null;
  }

  const data = editingEvent || latest || {};

  const reasonOptions = [
    "","Abdominal or Intestinal","Accident at work","Asthma Related","Back Related","Blood Related","Cancer Related",
    "Chest or Lung related","Cold and Flu","Dental Related","Ear, Nose or Throat Related","Epilepsy","Gynecological",
    "Headache or Migraine","Heart Related","Mental Health","MSK","Operation or Recovery","Pregnancy Related","Virus",
    "Stomach Related","S&D"
  ];
  const sanctionOptions = [
    "","1st occasion","2nd occasion","3rd Occasion – Forward to Stage 1","Stage 1 First occasion",
    "Stage 1 Second Occasion – Forward to Stage 3","Stage 3 absence – Forward to Senior Team"
  ];
  const nowDT = new Date().toISOString().slice(0,16);
  const body = `
    <div class="grid">
      <div class="field">
        <label>Colleague</label>
        <select id="abs-colleague">${colleagueOptions(record.colleagueId)}</select>
      </div>
      <div class="field">
        <label>Manager</label>
        <select id="abs-manager">${managerOptions(data.managerId||"")}</select>
      </div>

      <div class="field">
        <label>Date of absence</label>
        <input id="abs-dateStart" type="date" value="${escapeHtml((data.dateStart||""))}"/>
      </div>
      <div class="field">
        <label>Expected return date</label>
        <input id="abs-expectedReturn" type="date" value="${escapeHtml(data.expectedReturn||"")}"/>
        <!-- Inline validation error for expected return -->
        <div id="abs-return-error" style="color:#e00;font-size:0.85em;display:none;">Return date can’t be before start date</div>
      </div>

      <div class="field" style="grid-column:1/-1">
        <label>Reason</label>
        <select id="abs-reason">
          ${reasonOptions.map(v=>`<option value="${escapeHtml(v)}" ${v===(data.reason||"")?"selected":""}>${v===""?"-- Select reason --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>

      <div class="field" style="grid-column:1/-1">
        <label>Absence Details</label>
        <textarea id="abs-notes" placeholder="Add any relevant details...">${escapeHtml(data.notes||"")}</textarea>
      </div>

      <div class="field" style="grid-column:1/-1">
        <label>Updated on</label>
        <input id="abs-updated" type="datetime-local" value="${escapeHtml(data.updated||nowDT)}"/>
        <div class="muted" style="margin-top:6px">Defaults to now, but you can edit it.</div>
      </div>

      <div class="field">
        <label>Next Action</label>
        <select id="abs-nextAction">
          ${["","Callback","Depot Visit","Home Visit","IHC process meeting","Phased RTW","RTW"].map(v=>`<option value="${escapeHtml(v)}" ${v===(data.nextAction||"")?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
      <div class="field">
        <label>Time / Date of next action</label>
        <input id="abs-nextActionDT" type="datetime-local" value="${escapeHtml(data.nextActionDT||"")}"/>
      </div>

      <div class="field">
        <label>Share absence with GMB</label>
        <select id="abs-shareGmb">
          ${["","Yes","No"].map(v=>`<option value="${v}" ${v===(data.shareGmb||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}
        </select>
      </div>
      <div class="field">
        <label>Patterns Identified</label>
        <select id="abs-patterns">
          ${["","Yes","No"].map(v=>`<option value="${v}" ${v===(data.patterns||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}
        </select>
      </div>

      <div class="field">
        <label>D&A Required for sporadic / for cause?</label>
        <select id="abs-da">
          ${["","No","Yes – Sporadic","Yes – For Cause"].map(v=>`<option value="${escapeHtml(v)}" ${v===(data.daRequired||"")?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
      <div class="field">
        <label>Sick note Expiry</label>
        <input id="abs-sickNote" type="date" value="${escapeHtml(data.sickNoteExpiry||"")}"/>
      </div>

      <div class="field">
        <label>CSP Stopped</label>
        <select id="abs-csp">
          ${["","Yes","No"].map(v=>`<option value="${v}" ${v===(data.cspStopped||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}
        </select>
      </div>
      <div class="field">
        <label>Sanction Imposed</label>
        <select id="abs-sanction">
          ${sanctionOptions.map(v=>`<option value="${escapeHtml(v)}" ${v===(data.sanction||"")?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
    </div>
  `;

  openModal(isNewAbsence ? "Add Absence" : (forceNewEvent ? "Add Absence Event" : "Edit Absence"),
    body,
    [
      {label:"Cancel", kind:"", onClick: closeModal},
      {label:"Save", kind:"primary", onClick: ()=>{
        // Capture previous state for undo if editing
        const prevRecordCopy = existingRecord ? JSON.parse(JSON.stringify(existingRecord)) : null;
        const colleagueId = document.getElementById("abs-colleague").value;
        if(!colleagueId){ alert("Please select a colleague."); return; }
        const managerId = document.getElementById("abs-manager").value;
        if(!managerId){ alert("Please select a manager."); return; }
        const dateStart = fromDateInput(document.getElementById("abs-dateStart").value);
        if(!dateStart){ alert("Please choose an absence start date."); return; }
        const reason = document.getElementById("abs-reason").value;
        if(!reason){ alert("Please select a reason."); return; }
        const sanction = document.getElementById("abs-sanction").value;
        if(!sanction){ alert("Please select a sanction."); return; }

        // Validate return date ordering: must not be before start date.
        const expectedReturnDT = fromDateInput(document.getElementById("abs-expectedReturn").value);
        if(expectedReturnDT && dateStart && expectedReturnDT < dateStart){
          alert("Expected return date cannot be before the start date.");
          return;
        }

        // Prevent duplicate absences for the same colleague on the same start date when creating a new record
        if(isNewAbsence){
          const isoStart = toISODatePart(dateStart);
          const dup = (state.absences || []).find(r => r.colleagueId === colleagueId && (r.events || []).some(e => toISODatePart(e.dateStart) === isoStart));
          if(dup){
            alert("An absence for this colleague on this start date already exists.");
            return;
          }
        }

        const evt = {
          id: editingEvent?.id || uid(),
          dateStart,
          managerId,
          reason,
          notes: document.getElementById("abs-notes").value.trim(),
          updated: document.getElementById("abs-updated").value || nowDT,
          nextActionType: document.getElementById("abs-nextAction").value,
          nextActionDT: document.getElementById("abs-nextActionDT").value,
          shareGmb: document.getElementById("abs-shareGmb").value,
          patterns: document.getElementById("abs-patterns").value,
          daRequired: document.getElementById("abs-da").value,
          sickNoteExpiry: fromDateInput(document.getElementById("abs-sickNote").value),
          expectedReturn: fromDateInput(document.getElementById("abs-expectedReturn").value),
          cspStopped: document.getElementById("abs-csp").value,
          sanction,
          createdAt: new Date().toISOString()
        };

        // update record
        record.colleagueId = colleagueId;

        // remove existing event if editing
        if(editingEvent){
          record.events = record.events.filter(e=>e.id!==editingEvent.id);
        }
        // add and sort newest first by createdAt
        record.events.unshift(evt);
        record.events.sort((a,b)=>(b.createdAt||"").localeCompare(a.createdAt||""));

        if(isNewAbsence){
          state.absences.unshift(record);
        }else{
          state.absences = state.absences.map(r=>r.id===record.id?record:r);
        }
        saveState();
        // Record audit trail entry
        try{
          logAudit(isNewAbsence ? 'create' : 'update', 'absence', record.id, record.colleagueId, evt.reason || '');
        }catch(e){}
        // Clear draft notes on successful save
        try{ localStorage.removeItem('draftAbsDetails'); }catch(e){}
        closeModal();
        renderCurrentTab();
        // Show toast with undo option
        if(isNewAbsence){
          showToast('Absence added', () => {
            state.absences = state.absences.filter(r=>r.id !== record.id);
            saveState();
            renderCurrentTab();
          });
        }else{
          showToast('Absence updated', () => {
            if(prevRecordCopy){
              state.absences = state.absences.map(r => r.id === prevRecordCopy.id ? prevRecordCopy : r);
              saveState();
              renderCurrentTab();
            }
          });
        }
      }}
    ]
  );

  // Attach inline validation, autosave and keyboard handling after modal renders
  setTimeout(() => {
    const startInput = document.getElementById('abs-dateStart');
    const returnInput = document.getElementById('abs-expectedReturn');
    const errorDiv = document.getElementById('abs-return-error');
    // Find the save button within the modal
    const modal = document.querySelector('.modal');
    const saveBtn = modal ? modal.querySelector('button.primary') : null;
    const validateDates = () => {
      const startVal = fromDateInput(startInput.value);
      const returnVal = fromDateInput(returnInput.value);
      if(returnVal && startVal && returnVal < startVal){
        if(errorDiv) errorDiv.style.display = '';
        if(saveBtn) saveBtn.disabled = true;
      }else{
        if(errorDiv) errorDiv.style.display = 'none';
        if(saveBtn) saveBtn.disabled = false;
      }
    };
    if(startInput && returnInput){
      startInput.addEventListener('change', validateDates);
      returnInput.addEventListener('change', validateDates);
      validateDates();
    }
    // Autosave notes
    const notes = document.getElementById('abs-notes');
    const draftKey = 'draftAbsDetails';
    if(notes){
      try {
        // Load draft if new absence and no existing notes
        if(!existingRecord){
          const draft = localStorage.getItem(draftKey);
          if(draft && !notes.value) notes.value = draft;
        }
        notes.addEventListener('input', () => {
          try{ localStorage.setItem(draftKey, notes.value); }catch(e){}
        });
      }catch(e){}
    }
    // Keyboard shortcut: Enter to save (avoid when in textarea)
    if(modal){
      modal.addEventListener('keydown', (ev) => {
        if(ev.key === 'Enter' && ev.target && ev.target.id !== 'abs-notes'){
          // Prevent default to avoid form submission duplicates
          ev.preventDefault();
          if(saveBtn && !saveBtn.disabled) saveBtn.click();
        }
      });
    }
  }, 0);
}

function openAbsenceHistory(record){
  const items = (record.events||[]).map(e=>{
    // helper to format datetime strings into UK date and 24h time
    const fmtDT = (dt) => {
      if(!dt) return "-";
      // Use toUKDateTime for consistent UK date and 24h time formatting
      return escapeHtml(toUKDateTime(dt));
    };
    return `
    <div style="border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;background:#fff">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <b>${escapeHtml(toUKDate(e.dateStart))}</b>
        <span class="tag">${escapeHtml(e.nextActionType||"No next action")}</span>
      </div>
      <div class="muted" style="margin-top:6px;white-space:pre-wrap">
        <div><b>Manager:</b> ${escapeHtml(managerName(e.managerId||"") || "-")}</div>
        <div><b>Reason:</b> ${escapeHtml(e.reason||"-")}</div>
        <div><b>Next action:</b> ${escapeHtml(e.nextActionType||"-")}</div>
        <div><b>Time / Date of next action:</b> ${fmtDT(e.nextActionDT)}</div>
        <div><b>Sick note expiry:</b> ${escapeHtml(toUKDate(e.sickNoteExpiry)||"-")}</div>
        <div><b>Expected return date:</b> ${escapeHtml(toUKDate(e.expectedReturn)||"-")}</div>
        <div><b>CSP stopped:</b> ${escapeHtml(e.cspStopped||"-")}</div>
        <div><b>Sanction imposed:</b> ${escapeHtml(e.sanction||"-")}</div>
        <div><b>Share absence with GMB:</b> ${escapeHtml(e.shareGmb||"-")}</div>
        <div><b>Patterns identified:</b> ${escapeHtml(e.patterns||"-")}</div>
        <div><b>D&amp;A Required:</b> ${escapeHtml(e.daRequired||"-")}</div>
        <div><b>Updated on:</b> ${fmtDT(e.updated)}</div>
        <div><b>Absence details:</b> ${escapeHtml(e.notes||"-")}</div>
      </div>
    </div>
    `;
  }).join("") || `<div class="muted">No history yet.</div>`;

  openModal(`Absence History — ${colleagueName(record.colleagueId)}`, items, [
    {label:"Close", kind:"primary", onClick: closeModal}
  ]);
}

/*
 * Launch a Return to Work modal for an existing absence record.  This allows the
 * user to log a colleague returning to work directly from the Absence list,
 * without having to open and edit the absence event itself.  When the RTW is
 * saved the absence is removed from the active absences list and placed into
 * the completedAbsences array along with the original absence history and the
 * return details.  The user is reminded to ensure that the RTW meeting and
 * paperwork are complete before saving.
 */
function openReturnToWorkModal(record){
  // Prepopulate defaults: manager set to the latest event manager if present
  const latestEvent = (record.events || [])[0] || {};
  const nowDate = new Date().toISOString().split("T")[0];
  const nowTime = new Date().toISOString().split("T")[1]?.slice(0,5) || "";
  const body = `
    <div class="grid">
      <div class="field"><label>Conducting manager</label><select id="rtw-mgr">${managerOptions(latestEvent.managerId||"")}</select></div>
      <div class="field"><label>Date of return</label><input id="rtw-date" type="date" value="${escapeHtml(nowDate)}"></div>
      <div class="field"><label>Time of return</label><input id="rtw-time" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(nowTime)}"></div>
      <div class="field" style="grid-column:1/-1"><label>Additional details</label><textarea id="rtw-details" placeholder="Add any relevant details..."></textarea></div>
    </div>
  `;
  openModal(`Return to work — ${escapeHtml(colleagueName(record.colleagueId))}`, body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Return colleague", kind:"primary", onClick: ()=>{
      const managerId = document.getElementById("rtw-mgr").value;
      const dateReturn = document.getElementById("rtw-date").value;
      const timeReturn = document.getElementById("rtw-time").value;
      const details = document.getElementById("rtw-details").value.trim();
      if(!managerId){ alert("Please select a conducting manager."); return; }
      if(!dateReturn){ alert("Please choose a return date."); return; }
      if(!timeReturn){ alert("Please choose a return time."); return; }
      // prompt to ensure user has completed RTW meeting and paperwork
      // Use confirm so the user has the option to cancel if the meeting and paperwork
      // are not yet complete.  confirm shows an OK/Cancel dialog, returning true
      // if the user chooses OK and false if they click Cancel.
      if(!confirm("Please make sure RTW meeting has taken place and all paperwork is up to date")){
        return;
      }
      // Move absence to completedAbsences
      const completed = {
        id: record.id,
        colleagueId: record.colleagueId,
        managerId,
        dateReturn,
        timeReturn,
        details,
        completedAt: new Date().toISOString(),
        events: (record.events || []).slice(),
        sanction: (record.events || [])[0] ? (record.events[0].sanction || "") : ""
      };
      // Remove from active absences
      state.absences = state.absences.filter(a => a.id !== record.id);
      // Add to completedAbsences at the beginning
      state.completedAbsences = state.completedAbsences || [];
      state.completedAbsences.unshift(completed);
      saveState();
      closeModal();
      renderCurrentTab();
    }}
  ]);
}

// Display the history of a completed absence record, including the original absence events and the
// return-to-work details.  This is similar to openAbsenceHistory but also includes the RTW
// information at the top.  The record parameter should be an object from state.completedAbsences.
function openCompletedAbsenceHistory(record){
  // Build the history for the absence events.  Use the same formatting as openAbsenceHistory
  const eventItems = (record.events || []).map(e => {
    const fmtDT = (dt) => {
      if(!dt) return "-";
      // Use toUKDateTime for consistent UK date and 24h time formatting
      return escapeHtml(toUKDateTime(dt));
    };
    return `
    <div style="border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;background:#fff">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <b>${escapeHtml(toUKDate(e.dateStart))}</b>
        <span class="tag">${escapeHtml(e.nextActionType || "No next action")}</span>
      </div>
      <div class="muted" style="margin-top:6px;white-space:pre-wrap">
        <div><b>Manager:</b> ${escapeHtml(managerName(e.managerId || "") || "-")}</div>
        <div><b>Reason:</b> ${escapeHtml(e.reason || "-")}</div>
        <div><b>Next action:</b> ${escapeHtml(e.nextActionType || "-")}</div>
        <div><b>Time / Date of next action:</b> ${fmtDT(e.nextActionDT)}</div>
        <div><b>Sick note expiry:</b> ${escapeHtml(toUKDate(e.sickNoteExpiry) || "-")}</div>
        <div><b>Expected return date:</b> ${escapeHtml(toUKDate(e.expectedReturn) || "-")}</div>
        <div><b>CSP stopped:</b> ${escapeHtml(e.cspStopped || "-")}</div>
        <div><b>Sanction imposed:</b> ${escapeHtml(e.sanction || "-")}</div>
        <div><b>Share absence with GMB:</b> ${escapeHtml(e.shareGmb || "-")}</div>
        <div><b>Patterns identified:</b> ${escapeHtml(e.patterns || "-")}</div>
        <div><b>D&amp;A Required:</b> ${escapeHtml(e.daRequired || "-")}</div>
        <div><b>Updated on:</b> ${fmtDT(e.updated)}</div>
        <div><b>Absence details:</b> ${escapeHtml(e.notes || "-")}</div>
      </div>
    </div>
    `;
  }).join("") || `<div class="muted">No history yet.</div>`;
  // Build the RTW summary
  const returnSummary = `
    <div style="border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:20px;background:#fff">
      <b>Return to work summary</b>
      <div class="muted" style="margin-top:6px;white-space:pre-wrap">
        <div><b>Conducting manager:</b> ${escapeHtml(managerName(record.managerId) || "-")}</div>
        <div><b>Date of return:</b> ${escapeHtml(toUKDate(record.dateReturn) || "-")}</div>
        <div><b>Time of return:</b> ${escapeHtml(toUKTime(record.timeReturn) || "-")}</div>
        <div><b>Sanction imposed:</b> ${escapeHtml(record.sanction || "-")}</div>
        <div><b>Logged at:</b> ${escapeHtml(record.completedAt ? toUKDateTime(record.completedAt) : '-') }</div>
        <div><b>Additional details:</b> ${escapeHtml(record.details || "-")}</div>
      </div>
    </div>
  `;
  openModal(`Completed Absence History — ${colleagueName(record.colleagueId)}`, returnSummary + eventItems, [
    {label:"Close", kind:"primary", onClick: closeModal}
  ]);
}

// Display the details of a completed log from the attendance/conduct tabs.  The
// completed log record is stored in state.completedLogs with a type and the
// original record.  This function finds the entry by type and record id,
// then shows a modal with all of the record's fields formatted in a simple
// key/value list.  Because each category has different fields, we simply
// iterate through the record's own properties.
function openCompletedLogHistory(type, id){
  const item = (state.completedLogs || []).find(x => x.type === type && (x.record || {}).id === id);
  if(!item) return;
  const rec = item.record || {};
  // Build a user-friendly details panel. Include category and completed time first.
  let html = '<div style="border:1px solid var(--line);border-radius:12px;padding:10px;background:#fff">';
  html += `<div><b>Category:</b> ${escapeHtml(type)}</div>`;
  html += `<div><b>Completed at:</b> ${escapeHtml(item.completedAt ? toUKDateTime(item.completedAt) : '-')}</div>`;
  // Show colleague name when available
  if(rec.colleagueId){
    const colName = colleagueName(rec.colleagueId) || rec.colleagueId;
    html += `<div><b>Colleague:</b> ${escapeHtml(colName)}</div>`;
  }
  // Show manager name when available
  if(rec.managerId){
    const mgrName = managerName(rec.managerId) || rec.managerId;
    html += `<div><b>Manager:</b> ${escapeHtml(mgrName)}</div>`;
  }
  // Helper to convert camelCase or keys with numeric suffixes into human-friendly labels
  const humanize = (str) => {
    let s = String(str);
    // Remove trailing digits
    s = s.replace(/\d+$/, '');
    // Insert space before uppercase letters
    s = s.replace(/([a-z])([A-Z])/g, '$1 $2');
    // Capitalize first letter
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  // Iterate through remaining fields and format values appropriately
  Object.keys(rec).forEach(key => {
    if(key === 'history' || key === 'latest' || key === 'colleagueId' || key === 'managerId' || key === 'id') return;
    const val = rec[key];
    let displayVal = '';
    if(val === null || val === undefined || val === '') {
      displayVal = '';
    } else if(typeof val === 'string'){
      // ISO date/time strings
      if(/^\d{4}-\d{2}-\d{2}T/.test(val)){
        displayVal = toUKDateTime(val);
      } else if(/^\d{4}-\d{2}-\d{2}$/.test(val)){
        displayVal = toUKDate(val);
      } else if(/^\d{2}:\d{2}/.test(val)){
        // time-only, strip seconds if present
        displayVal = val.slice(0,5);
      } else {
        displayVal = val;
      }
    } else {
      // Fallback to string conversion
      displayVal = String(val);
    }
    html += `<div><b>${escapeHtml(humanize(key))}:</b> ${escapeHtml(displayVal)}</div>`;
  });
  html += '</div>';
  openModal('Completed Log History — ' + escapeHtml(type), html, [
    {label:'Close', kind:'primary', onClick: closeModal}
  ]);
}

/*
 * Open a colleague history modal.  When the user clicks a colleague name anywhere
 * in the application, this function gathers all attendance and conduct records
 * associated with that colleague and displays them in a single modal.  The
 * history is sorted by date descending and shows the category and a brief
 * description for each entry.  The modal automatically includes an Export
 * PDF button (handled by openModal).
 */
function openColHistoryModal(colId){
  if(!colId) return;
  const entries = [];
  // helper to add entries.  dateStr should be ISO or yyyy-mm-dd; label is
  // category; details is a string summary
  function addEntry(dateStr, label, details){
    if(!dateStr) return;
    const dt = new Date(dateStr);
    if(isNaN(dt.getTime())) return;
    entries.push({ date: dt, label: label, details: details||'' });
  }
  // Absences: each event counts.  Include the user supplied notes where available
  state.absences.forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.events || []).forEach(e => {
      // Build a more descriptive details string combining reason and notes
      let det = '';
      const reason = e.reason || '';
      const notes  = e.notes || '';
      if(reason && notes) det = `${reason} — ${notes}`;
      else if(reason) det = reason;
      else if(notes) det = notes;
      addEntry(e.dateStart || e.date || '', 'Absence', det);
    });
  });
  // Completed absences (return to work)
  (state.completedAbsences || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.events || []).forEach(e => {
      addEntry(e.dateStart || e.date || '', 'Absence', e.reason || '');
    });
    addEntry(r.dateReturn || '', 'Return to work', r.sanction || '');
  });
  // Part shifts
  state.partShifts.forEach(r => { if(r.colleagueId === colId) addEntry(r.date, 'Part shift', (r.hours ? `Hours: ${r.hours}` : (r.shiftStart && r.shiftEnd ? `${r.shiftStart}-${r.shiftEnd}` : '')) ); });
  // Me days
  state.meDays.forEach(r => { if(r.colleagueId === colId) addEntry(r.date, 'Me day', (r.hours ? `Hours: ${r.hours}` : '')); });
  // AWOL
  state.awol.forEach(r => { if(r.colleagueId === colId) addEntry(r.startDate || r.date, 'AWOL', r.details || ''); });
  // Late RTW
  state.lateRTW.forEach(r => { if(r.colleagueId === colId) addEntry(r.date || r.startDate, 'Late RTW', r.reason || ''); });
  // Warnings: show user-provided reason first, then action if no reason
  state.warnings.forEach(r => {
    if(r.colleagueId !== colId) return;
    const details = (r.reason && r.reason.trim()) ? r.reason.trim() : (r.action || '');
    addEntry(r.createdAt || r.date || '', 'Warning', details);
  });
  // Investigations: show details first, then case reference, then outcome
  state.investigations.forEach(r => {
    if(r.colleagueId !== colId) return;
    let details = '';
    if(r.details && r.details.trim()) details = r.details.trim();
    else if(r.caseRef && r.caseRef.trim()) details = r.caseRef.trim();
    else if(r.outcome && r.outcome.trim()) details = r.outcome.trim();
    addEntry(r.createdAt || r.dateRaised || '', 'Investigation', details);
  });
  // Restrictions: prioritise details over restriction type/ochStatus
  state.restrictions.forEach(r => {
    if(r.colleagueId !== colId) return;
    let details = '';
    if(r.details && r.details.trim()) details = r.details.trim();
    else if(r.restriction && r.restriction.trim()) details = r.restriction.trim();
    else if(r.ochStatus && r.ochStatus.trim()) details = r.ochStatus.trim();
    addEntry(r.startDate, 'Restriction', details);
  });
  // Medical reports: details already holds the narrative
  state.medicalReports.forEach(r => { if(r.colleagueId === colId) addEntry(r.dateStart || r.date, 'Medical', r.details || ''); });
  // Flexible leave: prioritise details over reason
  state.flexibleLeave.forEach(r => {
    if(r.colleagueId !== colId) return;
    let details = '';
    if(r.details && r.details.trim()) details = r.details.trim();
    else if(r.reason && r.reason.trim()) details = r.reason.trim();
    addEntry(r.date || r.startDate, 'Flexible leave', details);
  });
  // IHC history
  state.ihc.forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.history || []).forEach(h => addEntry(h.datetime || h.date || h.meetingDate, 'IHC', h.details || h.meeting || h.stage || ''));
    if(r.latest && r.latest.datetime) addEntry(r.latest.datetime, 'IHC', r.latest.details || r.latest.meeting || r.latest.stage || '');
  });
  // Rehab history
  state.rehab.forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.history || []).forEach(h => addEntry(h.datetime || h.date || h.meetingDate || h.rehabStart, 'Rehabilitation', h.details || h.meeting || h.stage || ''));
    if(r.latest && (r.latest.date || r.latest.datetime)) addEntry(r.latest.date || r.latest.datetime, 'Rehabilitation', r.latest.details || '');
  });
  // Ill health
  state.illHealth.forEach(r => { if(r.colleagueId === colId) addEntry(r.startDate, 'Ill health', r.details || ''); });
  // Bereavement
  state.bereavement.forEach(r => { if(r.colleagueId === colId) addEntry(r.startDate || r.date, 'Bereavement', r.details || ''); });
  // Completed logs
  (state.completedLogs || []).forEach(item => {
    const rec = item.record || {};
    if(rec.colleagueId === colId) addEntry(item.completedAt, `Completed ${item.type}`, '');
  });
  // Sort entries by date descending
  entries.sort((a,b) => b.date - a.date);
  let html = '';
  if(entries.length === 0){
    html = '<div class="muted">No history available.</div>';
  } else {
    html = entries.map(e => {
      const dateStr = toUKDate(e.date.toISOString().split('T')[0]);
      const safeDetails = escapeHtml(e.details);
      return `<div style="border:1px solid var(--line);border-radius:12px;padding:8px;margin-bottom:8px;background:#fff">
        <div style="display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap">
          <b>${escapeHtml(dateStr)}</b>
          <span class="tag">${escapeHtml(e.label)}</span>
        </div>
        <div class="muted" style="margin-top:6px;white-space:pre-wrap">${safeDetails || '-'}</div>
      </div>`;
    }).join('');
  }
  openModal(`Colleague History — ${escapeHtml(colleagueName(colId) || colId)}`, html, [ {label:'Close', kind:'primary', onClick: closeModal} ]);
}

// Delete a completed log from the completedLogs array.  This is used by the
// Completed actions tab when the user clicks the Delete button.  A confirmation
// prompt is shown before removing the entry.  After deletion the state is saved
// and the current tab is re-rendered.
function deleteCompletedLog(type, id){
  // Locate the completed log entry
  const rec = (state.completedLogs || []).find(x => x.type === type && (x.record || {}).id === id);
  if(!rec) return;
  // Use generic deletion helper. Label includes the type for clarity.
  handleDeleteRecord('completedLogs', rec, type + ' completed log', renderCurrentTab);
}

// Delete a completed absence return.  Similar to deleteCompletedLog but operates
// on state.completedAbsences.  Shows a confirmation prompt before removal.
function deleteCompletedAbsence(id){
  const rec = (state.completedAbsences || []).find(x => x.id === id);
  if(!rec) return;
  // Use generic deletion helper with audit and undo
  handleDeleteRecord('completedAbsences', rec, 'completed absence', renderCurrentTab);
}

// ========================= Colleague Profile & Reporting =========================
// Compute key statistics for a given colleague.  Returns counts of absence events
// over various lookback windows (4, 8, 26, 52 weeks) as well as counts of
// warnings, open investigations and restrictions.  Also counts restrictions
// whose review date has already passed.
function calculateColStats(colId){
  try{
    const now = new Date();
    const weeksAgo = (w) => new Date(now.getTime() - w*7*24*60*60*1000);
    const counts = { abs4:0, abs8:0, abs26:0, abs52:0 };
    // Additional counters for extended colleague stats.  We count late
    // return‑to‑work logs (last 26 weeks), part shifts (last 26 weeks)
    // and Me Days (last 52 weeks).  These counters are populated below.
    let late26 = 0;
    let part26 = 0;
    let me52  = 0;
    (state.absences || []).forEach(rec => {
      if(rec.colleagueId !== colId) return;
      (rec.events || []).forEach(ev => {
        const ds = ev.dateStart || ev.date || '';
        if(!ds) return;
        const dt = new Date(ds);
        if(isNaN(dt)) return;
        if(dt >= weeksAgo(4)) counts.abs4++;
        if(dt >= weeksAgo(8)) counts.abs8++;
        if(dt >= weeksAgo(26)) counts.abs26++;
        if(dt >= weeksAgo(52)) counts.abs52++;
      });
    });
    const warnings = (state.warnings || []).filter(r => r.colleagueId === colId).length;
    const investigations = (state.investigations || []).filter(r => r.colleagueId === colId).length;
    const restrictions = (state.restrictions || []).filter(r => r.colleagueId === colId);
    let restrictionsDue = 0;
    restrictions.forEach(r => {
      const rd = r.reviewDate;
      if(rd){
        const d = new Date(rd);
        if(!isNaN(d) && d < now) restrictionsDue++;
      }
    });

    // Count Late RTW events within the last 26 weeks.  Late RTW
    // records may store their date in different fields depending on the
    // modal used to create them.  We prefer a date property if
    // available, otherwise fall back to dateExpected, dateReturned or
    // startDate.  If no valid date is found the record is ignored.
    (state.lateRTW || []).forEach(r => {
      if(r.colleagueId !== colId) return;
      const cand = r.date || r.dateExpected || r.dateReturned || r.startDate;
      if(!cand) return;
      const dt = new Date(cand);
      if(isNaN(dt)) return;
      if(dt >= weeksAgo(26)) late26++;
    });
    // Count part shift absences within the last 26 weeks.  The date may
    // be stored in r.dateAbsence or r.date depending on the schema.
    (state.partShifts || []).forEach(r => {
      if(r.colleagueId !== colId) return;
      const cand = r.dateAbsence || r.date;
      if(!cand) return;
      const dt = new Date(cand);
      if(isNaN(dt)) return;
      if(dt >= weeksAgo(26)) part26++;
    });
    // Count Me Days within the last 52 weeks.  These records
    // typically store their date in the `date` field.
    (state.meDays || []).forEach(r => {
      if(r.colleagueId !== colId) return;
      const cand = r.date;
      if(!cand) return;
      const dt = new Date(cand);
      if(isNaN(dt)) return;
      if(dt >= weeksAgo(52)) me52++;
    });
    return {
      abs4: counts.abs4,
      abs8: counts.abs8,
      abs26: counts.abs26,
      abs52: counts.abs52,
      warnings: warnings,
      investigations: investigations,
      restrictions: restrictions.length,
      restrictionsDue: restrictionsDue,
      late26: late26,
      part26: part26,
      me52: me52
    };
  }catch(e){
    return { abs4:0, abs8:0, abs26:0, abs52:0, warnings:0, investigations:0, restrictions:0, restrictionsDue:0 };
  }
}

// Compute a list of status chips for the colleague profile.  Each chip
// has a label, a colour (CSS variable) and an optional subtitle.
function computeStatusChips(colId){
  const chips = [];
  const now = new Date();
  // Check for overdue restriction review dates
  let maxOverdue = 0;
  (state.restrictions || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    const rd = r.reviewDate;
    if(rd){
      const d = new Date(rd);
      if(!isNaN(d) && d < now){
        const diffDays = Math.floor((now - d) / (1000*60*60*24));
        if(diffDays > maxOverdue) maxOverdue = diffDays;
      }
    }
  });
  if(maxOverdue > 0){
    chips.push({ label:'Review overdue', colour:'var(--cat-restrictions)', subtitle: maxOverdue + ' days overdue' });
  }
  // Check for open or ongoing investigations
  const invList = (state.investigations || []).filter(r => r.colleagueId === colId);
  if(invList.some(i => !i.outcome || (i.outcome + '').toLowerCase().includes('ongoing') || (i.outcome + '').toLowerCase().includes('open'))){
    chips.push({ label:'Open investigation', colour:'var(--cat-conduct)', subtitle:'' });
  }
  // High absence if more than or equal to 3 absences in last 26 weeks
  try{
    const stats = calculateColStats(colId);
    if(stats.abs26 >= 3){
      chips.push({ label:'High absence', colour:'var(--cat-attendance)', subtitle: stats.abs26 + ' in 26 weeks' });
    }
    // Active restrictions
    const hasRestr = (state.restrictions || []).some(r => r.colleagueId === colId);
    if(hasRestr){
      chips.push({ label:'Restriction active', colour:'var(--cat-restrictions)', subtitle:'' });
    }
  }catch(e){}
  return chips;
}

// Compute insight data for the colleague profile.  Returns an object
// with a trend string, most common reason and recommended next
// action.  The trend compares absences in the last 26 weeks to the
// previous 26 week period.  The top reason is the most frequent
// absence reason for this colleague.  The recommendation is a simple
// heuristic based on overdue reviews, open investigations and high
// absence counts.
function computeProfileInsights(colId){
  const now = new Date();
  const weeksAgo = (w) => new Date(now.getTime() - w*7*24*60*60*1000);
  let current = 0;
  let prev = 0;
  // Count absences in current and previous 26 week windows
  (state.absences || []).forEach(rec => {
    if(rec.colleagueId !== colId) return;
    (rec.events || []).forEach(ev => {
      const cand = ev.dateStart || ev.date || '';
      if(!cand) return;
      const dt = new Date(cand);
      if(isNaN(dt)) return;
      if(dt >= weeksAgo(26)) current++;
      else if(dt >= weeksAgo(52)) prev++;
    });
  });
  let trendStr = '';
  const diff = current - prev;
  if(diff > 0) trendStr = '+' + diff + ' vs prior 26 weeks';
  else if(diff < 0) trendStr = diff + ' vs prior 26 weeks';
  else trendStr = 'No change vs prior 26 weeks';
  // Most common absence reason
  const reasonCounts = {};
  (state.absences || []).forEach(rec => {
    if(rec.colleagueId !== colId) return;
    (rec.events || []).forEach(ev => {
      const reason = (ev.reason || '').trim();
      if(!reason) return;
      reasonCounts[reason] = (reasonCounts[reason] || 0) + 1;
    });
  });
  let topReason = '';
  let maxCount = 0;
  Object.keys(reasonCounts).forEach(reason => {
    if(reasonCounts[reason] > maxCount){ maxCount = reasonCounts[reason]; topReason = reason; }
  });
  if(!topReason) topReason = '–';
  // Recommended next action
  let recommendation = '';
  // Use stats and statuses to propose next action
  const stats = calculateColStats(colId);
  const openInv = (state.investigations || []).some(r => r.colleagueId === colId && (!r.outcome || (r.outcome + '').toLowerCase().includes('ongoing') || (r.outcome + '').toLowerCase().includes('open')));
  const overdue = stats.restrictionsDue > 0;
  if(overdue) recommendation = 'Review restrictions';
  else if(openInv) recommendation = 'Complete investigation';
  else if(stats.warnings === 0 && stats.abs26 >= 3) recommendation = 'Consider warning';
  else recommendation = 'Keep monitoring';
  return { trend: trendStr, reason: topReason, recommendation: recommendation };
}

// Build a sorted list of history entries for a colleague.  Each entry contains
// a date, label and details.  The list is sorted descending by date.
function buildColHistoryEntries(colId){
  const entries = [];
  function addEntry(dateStr, label, details){
    if(!dateStr) return;
    const dt = new Date(dateStr);
    if(isNaN(dt)) return;
    entries.push({ date: dt, label: label, details: details || '' });
  }
  // Absences
  (state.absences || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.events || []).forEach(e => {
      let det = '';
      const reason = e.reason || '';
      const notes  = e.notes || '';
      if(reason && notes) det = `${reason} — ${notes}`;
      else if(reason) det = reason;
      else if(notes) det = notes;
      addEntry(e.dateStart || e.date || '', 'Absence', det);
    });
  });
  // Completed absences (return to work)
  (state.completedAbsences || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.events || []).forEach(e => {
      addEntry(e.dateStart || e.date || '', 'Absence', e.reason || '');
    });
    addEntry(r.dateReturn || '', 'Return to work', r.sanction || '');
  });
  // Part shifts
  (state.partShifts || []).forEach(r => {
    if(r.colleagueId === colId) addEntry(r.date, 'Part shift', (r.hours ? `Hours: ${r.hours}` : (r.shiftStart && r.shiftEnd ? `${r.shiftStart}-${r.shiftEnd}` : '')) );
  });
  // Me days
  (state.meDays || []).forEach(r => {
    if(r.colleagueId === colId) addEntry(r.date, 'Me day', (r.hours ? `Hours: ${r.hours}` : ''));
  });
  // AWOL
  (state.awol || []).forEach(r => {
    if(r.colleagueId === colId) addEntry(r.startDate || r.date, 'AWOL', r.details || '');
  });
  // Late RTW
  (state.lateRTW || []).forEach(r => {
    if(r.colleagueId === colId) addEntry(r.date || r.startDate, 'Late RTW', r.reason || '');
  });
  // Warnings
  (state.warnings || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    const details = (r.reason && r.reason.trim()) ? r.reason.trim() : (r.action || '');
    addEntry(r.createdAt || r.date || '', 'Warning', details);
  });
  // Investigations
  (state.investigations || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    let details = '';
    if(r.details && r.details.trim()) details = r.details.trim();
    else if(r.caseRef && r.caseRef.trim()) details = r.caseRef.trim();
    else if(r.outcome && r.outcome.trim()) details = r.outcome.trim();
    addEntry(r.createdAt || r.dateRaised || '', 'Investigation', details);
  });
  // Restrictions
  (state.restrictions || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    let details = '';
    if(r.details && r.details.trim()) details = r.details.trim();
    else if(r.restriction && r.restriction.trim()) details = r.restriction.trim();
    else if(r.ochStatus && r.ochStatus.trim()) details = r.ochStatus.trim();
    addEntry(r.startDate, 'Restriction', details);
  });
  // Medical reports
  (state.medicalReports || []).forEach(r => { if(r.colleagueId === colId) addEntry(r.dateStart || r.date, 'Medical', r.details || ''); });
  // Flexible leave
  (state.flexibleLeave || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    let details = '';
    if(r.details && r.details.trim()) details = r.details.trim();
    else if(r.reason && r.reason.trim()) details = r.reason.trim();
    addEntry(r.date || r.startDate, 'Flexible leave', details);
  });
  // IHC history
  (state.ihc || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.history || []).forEach(h => addEntry(h.datetime || h.date || h.meetingDate, 'IHC', h.details || h.meeting || h.stage || ''));
    if(r.latest && r.latest.datetime) addEntry(r.latest.datetime, 'IHC', r.latest.details || r.latest.meeting || r.latest.stage || '');
  });
  // Rehabilitation
  (state.rehab || []).forEach(r => {
    if(r.colleagueId !== colId) return;
    (r.history || []).forEach(h => addEntry(h.datetime || h.date || h.meetingDate || h.rehabStart, 'Rehabilitation', h.details || h.meeting || h.stage || ''));
    if(r.latest && (r.latest.date || r.latest.datetime)) addEntry(r.latest.date || r.latest.datetime, 'Rehabilitation', r.latest.details || '');
  });
  // Ill health
  (state.illHealth || []).forEach(r => { if(r.colleagueId === colId) addEntry(r.startDate, 'Ill health', r.details || ''); });
  // Bereavement
  (state.bereavement || []).forEach(r => { if(r.colleagueId === colId) addEntry(r.startDate || r.date, 'Bereavement', r.details || ''); });
  // Completed logs
  (state.completedLogs || []).forEach(item => {
    const rec = item.record || {};
    if(rec.colleagueId === colId) addEntry(item.completedAt, `Completed ${item.type}`, '');
  });
  entries.sort((a,b) => b.date - a.date);
  return entries;
}

// Build HTML for the colleague history tab.  Includes an export button.
function buildColHistoryHTML(colId, includeExport = true){
  // Build a grouped, filtered timeline for the colleague history.  The
  // timeline is organised by month and category and includes a
  // filter bar to toggle categories.  Each entry has a coloured dot
  // corresponding to its category.  If there are no history items
  // available for the colleague, an empty-state panel is shown with
  // suggested next actions.
  const entries = buildColHistoryEntries(colId);
  let html = '';
  // Insert export button if requested
  if(includeExport){
    html += '<div class="tab-actions"><button class="btn" id="col-hist-export">Export CSV</button></div>';
  }
  // If no entries, return empty-state panel with suggestions
  if(entries.length === 0){
    html += `<div class="empty-state">
      <p>No history yet for this colleague.</p>
      <p>Get started by logging an attendance or conduct event.</p>
      <div class="actions">
        <button class="btn" data-act="add-absence">+ Add absence</button>
        <button class="btn" data-act="add-late">+ Add late RTW</button>
        <button class="btn" data-act="add-part">+ Add part shift</button>
        <button class="btn" data-act="add-me">+ Add me day</button>
      </div>
    </div>`;
    return html;
  }
  // Create filter bar
  html += `<div class="timeline-filter">
    <button class="btn active" data-filter="all" type="button">All</button>
    <button class="btn" data-filter="attendance" type="button">Attendance</button>
    <button class="btn" data-filter="conduct" type="button">Conduct</button>
    <button class="btn" data-filter="restrictions" type="button">Restrictions</button>
    <button class="btn" data-filter="admin" type="button">Admin</button>
  </div>`;
  // Group entries by year-month key
  const groups = {};
  entries.forEach(e => {
    // Determine category based on label
    let cat = 'admin';
    const lbl = (e.label || '').toLowerCase();
    if(lbl.includes('absence') || lbl.includes('return to work') || lbl.includes('me day') || lbl.includes('part')) cat = 'attendance';
    else if(lbl.includes('warning') || lbl.includes('investigation') || lbl.includes('d&a') || lbl.includes('positive') || lbl.includes('conduct')) cat = 'conduct';
    else if(lbl.includes('restriction') || lbl.includes('restriction')) cat = 'restrictions';
    e.cat = cat;
    // Determine display month (e.g. Jan 2025)
    const dt = e.date;
    const monthName = dt.toLocaleString('en-GB', { month:'short' });
    const key = monthName + ' ' + dt.getFullYear();
    if(!groups[key]) groups[key] = [];
    groups[key].push(e);
  });
  // Sort months descending
  const monthKeys = Object.keys(groups).sort((a,b) => {
    const [ma, ya] = a.split(' ');
    const [mb, yb] = b.split(' ');
    const da = new Date(ma + ' 1, ' + ya);
    const db = new Date(mb + ' 1, ' + yb);
    return db - da;
  });
  monthKeys.forEach(monthKey => {
    html += `<div class="timeline-month">${escapeHtml(monthKey)}</div>`;
    // Sort entries within month descending by date
    groups[monthKey].sort((a,b) => b.date - a.date);
    groups[monthKey].forEach(e => {
      const dateStr = toUKDate(e.date.toISOString().split('T')[0]);
      const safeDetails = escapeHtml(e.details);
      // Determine icon colour based on category
      let iconVar = '--cat-other';
      if(e.cat === 'attendance') iconVar = '--cat-attendance';
      else if(e.cat === 'conduct') iconVar = '--cat-conduct';
      else if(e.cat === 'restrictions') iconVar = '--cat-restrictions';
      // Build entry HTML
      html += `<div class="timeline-entry" data-cat="${e.cat}">
        <div class="timeline-entry-head">
          <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
            <span class="timeline-icon" style="background:var(${iconVar})"></span>
            <b>${escapeHtml(dateStr)}</b>
          </div>
          <span class="tag">${escapeHtml(e.label)}</span>
        </div>
        <div class="timeline-entry-body">${safeDetails || '-'}</div>
      </div>`;
    });
  });
  return html;
}

// Build HTML for the colleague audit log tab.  Includes an export button.
function buildColAuditHTML(colId, includeExport = true){
  const list = (state.auditTrail || []).filter(e => e.colleagueId === colId);
  const allowDelete = !!(state.session && (state.session.canDelete || state.session.role === 'admin'));
  let html = '';
  if(includeExport){
    html += '<div class="tab-actions"><button class="btn" id="col-audit-export">Export CSV</button></div>';
  }
  if(list.length === 0){
    // Use empty-state pattern when no audit logs exist
    html += `<div class="empty-state"><p>No audit logs yet.</p><p>Once actions are taken, they will appear here.</p></div>`;
    return html;
  }
  // Ensure each entry has an id so it can be deleted individually.
  list.forEach(e => { if(e && !e.id) e.id = uid(); });
  list.sort((a,b) => new Date(b.ts) - new Date(a.ts));
  html += list.map(e => {
    const ts = e.ts || '';
    const datePart = ts.split('T')[0] || '';
    const timePart = ts.split('T')[1] ? ts.split('T')[1].split('.')[0] : '';
    const dateStr = toUKDate(datePart);
    const delBtn = allowDelete ? `<button class="btn small danger" type="button" data-audit-del="1" data-audit-id="${escapeHtml(e.id)}">Delete</button>` : '';
    return `<div class="col-audit-item" data-audit-id="${escapeHtml(e.id)}" style="border:1px solid var(--line);border-radius:12px;padding:8px;margin-bottom:8px;background:#fff">
      <div style="display:flex;justify-content:space-between;gap:8px;flex-wrap:wrap;align-items:center">
        <b>${escapeHtml(dateStr)} ${escapeHtml(timePart)}</b>
        <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
          <span class="tag">${escapeHtml(e.action)}</span>
          ${delBtn}
        </div>
      </div>
      <div class="muted" style="margin-top:4px"><b>${escapeHtml(e.user)}</b> — ${escapeHtml(e.entity)}</div>
      <div class="muted" style="margin-top:4px;white-space:pre-wrap">${escapeHtml(e.details || '')}</div>
    </div>`;
  }).join('');
  return html;
}


// Export the colleague's history to a CSV file.
function exportColHistoryCSV(colId){
  const entries = buildColHistoryEntries(colId);
  const csv = [[ 'Date', 'Type', 'Details' ]];
  entries.forEach(e => {
    const dateStr = toUKDate(e.date.toISOString().split('T')[0]);
    csv.push([ dateStr, e.label, e.details || '' ]);
  });
  const filename = 'Colleague-History-' + (colId || 'col') + '.csv';
  downloadCSV(filename, csv);
}

// Export the colleague's audit log to a CSV file.
function exportColAuditCSV(colId){
  const list = (state.auditTrail || []).filter(e => e.colleagueId === colId);
  list.sort((a,b) => new Date(b.ts) - new Date(a.ts));
  const csv = [[ 'Timestamp', 'User', 'Action', 'Entity', 'Record ID', 'Details' ]];
  list.forEach(e => {
    csv.push([ e.ts || '', e.user || '', e.action || '', e.entity || '', e.recordId || '', e.details || '' ]);
  });
  const filename = 'Colleague-Audit-' + (colId || 'col') + '.csv';
  downloadCSV(filename, csv);
}

// Open a colleague profile modal with summary, history and audit tabs.  Also
// attaches handlers for tab navigation and export buttons.
function openColProfileModal(colId){
  if(!colId) return;
  const stats = calculateColStats(colId);
  // Construct the list of summary fields for the colleague profile.
  // We have updated the first four boxes to show different metrics.  The
  // first card now shows absences over the last 26 weeks.  The second
  // card shows Late RTW events over the last 26 weeks.  The third card
  // counts part shift absences over the last 26 weeks.  The fourth
  // counts Me Days over the last 52 weeks.  The remaining fields
  // (warnings, investigations, restrictions and overdue restrictions)
  // remain unchanged.
  const summaryFields = [
    { label: 'Absences (last 26 weeks)', value: stats.abs26 },
    { label: 'Late RTW (last 26 weeks)', value: stats.late26 },
    { label: 'Part shift (last 26 weeks)', value: stats.part26 },
    { label: 'Me days (last 52 weeks)', value: stats.me52 },
    { label: 'Warnings', value: stats.warnings },
    { label: 'Investigations', value: stats.investigations },
    { label: 'Restrictions', value: stats.restrictions },
    { label: 'Restrictions overdue', value: stats.restrictionsDue, danger: stats.restrictionsDue > 0 }
  ];
  // Status chips summarise important conditions for this colleague
  const chips = computeStatusChips(colId);
  const chipsHTML = chips.length ? `<div class="status-strip">
    ${chips.map(c => `<span class="status-chip" style="background:${c.colour}">${escapeHtml(c.label)}${c.subtitle?` \u2014 <span style=\"font-weight:400;font-size:10px\">${escapeHtml(c.subtitle)}</span>`:''}</span>`).join('')}
  </div>` : '';
  // Build summary cards
  const summaryHTML = `
    <div class="profile-summary">
      ${summaryFields.map(f => `<div class="field${f.danger ? ' danger' : ''}"><label>${escapeHtml(f.label)}</label><input type="text" value="${escapeHtml(String(f.value))}" readonly /></div>`).join('')}
    </div>
  `;
  // Meta information: last updated and provenance
  let lastUpdated = '';
  try{
    const historyEntries = buildColHistoryEntries(colId);
    if(historyEntries.length){
      const latest = historyEntries.sort((a,b) => b.date - a.date)[0];
      const dt = latest.date;
      lastUpdated = toUKDate(dt.toISOString().split('T')[0]);
    }
    // If audit is more recent
    const auditList = (state.auditTrail || []).filter(e => e.colleagueId === colId);
    if(auditList.length){
      auditList.sort((a,b) => new Date(b.ts) - new Date(a.ts));
      const ad = new Date(auditList[0].ts);
      if(!isNaN(ad)){
        const adStr = toUKDate(ad.toISOString().split('T')[0]);
        // Compare by date; if audit is newer, use audit date
        if(!lastUpdated || new Date(ad) > new Date(lastUpdated)) lastUpdated = adStr;
      }
    }
  }catch(e){}
  const metaHTML = `<div class="profile-meta">
    <span>Last updated: ${escapeHtml(lastUpdated || '—')}</span>
    <span>Generated by ACE</span>
  </div>`;
  // Insights panel
  const insight = computeProfileInsights(colId);
  const insightsHTML = `<div class="profile-insights">
    <h4>Insights</h4>
    <p><strong>Absence trend:</strong> ${escapeHtml(insight.trend)}</p>
    <p><strong>Most common reason:</strong> ${escapeHtml(insight.reason)}</p>
    <p><strong>Next recommended action:</strong> ${escapeHtml(insight.recommendation)}</p>
  </div>`;
  // Generate history and audit content without export buttons (we'll add them below)
  const historyHTML = buildColHistoryHTML(colId, false);
  const auditHTML = buildColAuditHTML(colId, false);
  const bodyHTML = `
    ${chipsHTML}
    ${summaryHTML}
    ${metaHTML}
    ${insightsHTML}
    <div class="profile-section">
      <h3 class="sectionTitle">History</h3>
      <div class="tab-actions"><button class="btn" id="col-hist-export">Export CSV</button></div>
      ${historyHTML}
    </div>
    <div class="profile-section" style="margin-top:12px;">
      <h3 class="sectionTitle">Audit log</h3>
      <div class="tab-actions"><button class="btn" id="col-audit-export">Export CSV</button></div>
      <div id="col-audit-wrap">${auditHTML}</div>
    </div>
  `;
  openModal('Colleague Profile — ' + escapeHtml(colleagueName(colId) || colId), bodyHTML, [
    { label:'Export PDF', onClick: () => exportProfileToPDF(colId) },
    { label:'Close', kind:'primary', onClick: closeModal }
  ]);
  // After rendering, attach event handlers to export buttons, filter bar and empty-state actions
  setTimeout(() => {
    const modalEl = modalBody;
    if(!modalEl) return;
    const histBtn = modalEl.querySelector('#col-hist-export');
    if(histBtn) histBtn.addEventListener('click', () => exportColHistoryCSV(colId));
    const auditBtn = modalEl.querySelector('#col-audit-export');
    if(auditBtn) auditBtn.addEventListener('click', () => exportColAuditCSV(colId));


    // Allow permitted users to delete individual audit log entries from the colleague profile.
    const wireAuditDeletes = () => {
      const delButtons = modalEl.querySelectorAll('button[data-audit-del][data-audit-id]');
      delButtons.forEach(btn => {
        // Avoid double-binding
        if(btn.__wired) return;
        btn.__wired = true;
        btn.addEventListener('click', () => {
          if(!(state.session && (state.session.canDelete || state.session.role === 'admin'))){
            alert('You do not have permission to delete audit logs.');
            return;
          }
          const auditId = btn.getAttribute('data-audit-id');
          if(!auditId) return;
          if(!confirm('Delete this audit log entry? This cannot be undone.')) return;
          const arr = state.auditTrail || [];
          const idx = arr.findIndex(e => e && e.id === auditId);
          if(idx < 0) return;
          arr.splice(idx, 1);
          saveState();
          // Refresh the audit log section in the open modal
          const wrap = modalEl.querySelector('#col-audit-wrap');
          if(wrap){
            wrap.innerHTML = buildColAuditHTML(colId, false);
            wireAuditDeletes();
          }
        });
      });
    };
    wireAuditDeletes();
    // Filter buttons for timeline
    const filterButtons = modalEl.querySelectorAll('.timeline-filter .btn');
    filterButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        filterButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        const filt = btn.getAttribute('data-filter');
        modalEl.querySelectorAll('.timeline-entry').forEach(ent => {
          const cat = ent.getAttribute('data-cat');
          if(!filt || filt === 'all' || cat === filt){
            ent.style.display = '';
          } else {
            ent.style.display = 'none';
          }
        });
      });
    });
    // Empty state actions to open modals
    const emptyState = modalEl.querySelector('.empty-state');
    if(emptyState){
      const ab = emptyState.querySelector('[data-act="add-absence"]');
      const lt = emptyState.querySelector('[data-act="add-late"]');
      const pt = emptyState.querySelector('[data-act="add-part"]');
      const md = emptyState.querySelector('[data-act="add-me"]');
      if(ab) ab.addEventListener('click', () => openAbsenceModal());
      if(lt) lt.addEventListener('click', () => openLateRTWModal());
      if(pt) pt.addEventListener('click', () => openPartShiftModal());
      if(md) md.addEventListener('click', () => openMeDayModal());
    }
  }, 50);
}

/* ---- Part Shift ---- */
function renderPartShift(host){
  const rows = state.partShifts
    .filter(r=>deptPass(r.colleagueId))
    .map(r => [
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(toUKDate(r.dateAbsence)),
      escapeHtml(toUKDate(r.expectedReturn)),
      escapeHtml(r.leftSite||""),
      escapeHtml(r.shiftStart||""),
      escapeHtml(r.shiftEnd||""),
      escapeHtml(r.details||""),
      escapeHtml(r.fileNoteCompleted||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Use the shared filter bar for sorting and searching
  renderShell(host, "Part Shift", "Partial shift attendance", `
    <button class="btn primary" id="ps-add">+ Add part shift</button>
    <button class="btn" id="ps-export">Export CSV</button>
  `, `${filterUI('partshift', false)}`, `
    <table>
      <thead>
        <tr>
          <th>Colleague</th><th>Manager</th><th>Date of part shift absence</th><th>Expected return</th>
          <th>Time colleague left site</th><th>Shift start</th><th>Shift end</th><th>Details</th><th>File note completed?</th><th>Actions</th>
        </tr>
      </thead>
      <tbody id="ps-tbody">
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="10" class="muted">No part shifts logged yet. Use + Add part shift to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `);

  document.getElementById("ps-add").addEventListener("click", ()=>openPartShiftModal());
  document.getElementById("ps-export").addEventListener("click", ()=>{
    const csv = [["Colleague","Colleague ID","Manager","Date of part shift absence","Expected return","Left site","Shift start","Shift end","Details","File note completed"]];
    state.partShifts.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId), r.colleagueId, managerName(r.managerId), toUKDate(r.dateAbsence), toUKDate(r.expectedReturn), r.leftSite||"", r.shiftStart||"", r.shiftEnd||"", r.details||"", r.fileNoteCompleted||""]);
    });
    downloadCSV("PartShift.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.partShifts.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Part shift", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('partShifts', rec, 'part shift record', renderCurrentTab);
      } else {
        openPartShiftModal(rec);
      }
    });
  });

  // Apply filter/search behaviour to the part shift table.  When the user adjusts the dropdown or enters a search term,
  // the rows will be filtered and sorted accordingly without re-rendering the entire page.
  {
    const applyFilters = () => applyTableFilters(host, 'partshift', 2);
    ['partshift-filter','partshift-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openPartShiftModal(rec=null){
  const isNew = !rec;
  const r = rec || { id:uid(), colleagueId:"", managerId:"", dateAbsence:"", expectedReturn:"", leftSite:"", shiftStart:"", shiftEnd:"", details:"", fileNoteCompleted:"" };
  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="ps-colleague">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="ps-manager">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Date of part shift absence</label><input id="ps-date" type="date" value="${escapeHtml(r.dateAbsence||"")}"></div>
      <div class="field"><label>Expected return date</label><input id="ps-exp" type="date" value="${escapeHtml(r.expectedReturn||"")}">
        <!-- Inline validation error for expected return -->
        <div id="ps-return-error" style="color:#e00;font-size:0.85em;display:none;">Return date can’t be before absence date</div>
      </div>
      <div class="field"><label>Time colleague left site</label><input id="ps-left" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.leftSite||"")}"></div>
      <div class="field"><label>Shift start</label><input id="ps-start" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.shiftStart||"")}"></div>
      <div class="field"><label>Shift end</label><input id="ps-end" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.shiftEnd||"")}"></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="ps-details">${escapeHtml(r.details||"")}</textarea></div>
      <div class="field"><label>File note completed upon RTW?</label>
        <select id="ps-file">
          ${["","Yes","No"].map(v=>`<option ${v===(r.fileNoteCompleted||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}
        </select>
      </div>
    </div>
  `;
  openModal(isNew?"Add Part Shift":"Edit Part Shift", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save part shift", kind:"primary", onClick: ()=>{
      // Capture previous copy for undo when editing
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("ps-colleague").value;
      r.managerId = document.getElementById("ps-manager").value;
      r.dateAbsence = fromDateInput(document.getElementById("ps-date").value);
      r.expectedReturn = fromDateInput(document.getElementById("ps-exp").value);
      r.leftSite = document.getElementById("ps-left").value;
      r.shiftStart = document.getElementById("ps-start").value;
      r.shiftEnd = document.getElementById("ps-end").value;
      r.details = document.getElementById("ps-details").value.trim();
      r.fileNoteCompleted = document.getElementById("ps-file").value;

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.dateAbsence) return alert("Select date of part shift absence");
      if(!r.expectedReturn) return alert("Select expected return date");
      if(!r.leftSite) return alert("Select time colleague left site");
      if(!r.shiftStart) return alert("Select shift start");
      if(!r.shiftEnd) return alert("Select shift end");

      // Validate date ordering: expected return should not be before absence date
      if(r.dateAbsence && r.expectedReturn && r.expectedReturn < r.dateAbsence){
        alert("Expected return date cannot be before the absence date.");
        return;
      }
      // Validate time formats for left site, shift start and end
      if(r.leftSite && !isValidTimeString(r.leftSite)){
        alert("Please enter a valid time for when the colleague left site (HH:MM).");
        return;
      }
      if(r.shiftStart && !isValidTimeString(r.shiftStart)){
        alert("Please enter a valid shift start time (HH:MM).");
        return;
      }
      if(r.shiftEnd && !isValidTimeString(r.shiftEnd)){
        alert("Please enter a valid shift end time (HH:MM).");
        return;
      }
      // If shift start and end times are both valid, ensure end is not earlier than start
      if(isValidTimeString(r.shiftStart) && isValidTimeString(r.shiftEnd)){
        const sm = timeToMinutes(r.shiftStart);
        const em = timeToMinutes(r.shiftEnd);
        if(!isNaN(sm) && !isNaN(em) && em < sm){
          alert("Shift end time cannot be earlier than shift start time.");
          return;
        }
      }

      if(isNew) state.partShifts.unshift(r);
      else state.partShifts = state.partShifts.map(x=>x.id===r.id?r:x);
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'partShift', r.id, r.colleagueId, r.details || '');
      }catch(e){}
      // Clear part shift draft details on save
      try{ localStorage.removeItem('draftPsDetails'); }catch(e){}
      closeModal(); renderCurrentTab();
      // Toast with undo functionality
      if(isNew){
        showToast('Part shift added', () => {
          state.partShifts = state.partShifts.filter(x => x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      }else{
        showToast('Part shift updated', () => {
          if(prevCopy){
            // Restore previous values into original record
            const target = state.partShifts.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);

  // Attach inline validation, autosave and keyboard shortcuts after modal renders
  setTimeout(() => {
    const dateAbsence = document.getElementById('ps-date');
    const expectedReturn = document.getElementById('ps-exp');
    const errDiv = document.getElementById('ps-return-error');
    const modal = document.querySelector('.modal');
    const saveBtn = modal ? modal.querySelector('button.primary') : null;
    const validate = () => {
      const startVal = fromDateInput(dateAbsence.value);
      const returnVal = fromDateInput(expectedReturn.value);
      if(returnVal && startVal && returnVal < startVal){
        if(errDiv) errDiv.style.display = '';
        if(saveBtn) saveBtn.disabled = true;
      }else{
        if(errDiv) errDiv.style.display = 'none';
        if(saveBtn) saveBtn.disabled = false;
      }
    };
    if(dateAbsence && expectedReturn){
      dateAbsence.addEventListener('change', validate);
      expectedReturn.addEventListener('change', validate);
      validate();
    }
    // Autosave details
    const details = document.getElementById('ps-details');
    const draftKey2 = 'draftPsDetails';
    if(details){
      try{
        // Only populate draft if new record and no details
        if(!rec){
          const draft = localStorage.getItem(draftKey2);
          if(draft && !details.value) details.value = draft;
        }
        details.addEventListener('input', () => {
          try{ localStorage.setItem(draftKey2, details.value); }catch(e){}
        });
      }catch(e){}
    }
    // Enter key to save (avoid in textarea)
    if(modal){
      modal.addEventListener('keydown', (ev) => {
        if(ev.key === 'Enter' && ev.target && ev.target.id !== 'ps-details'){
          ev.preventDefault();
          if(saveBtn && !saveBtn.disabled) saveBtn.click();
        }
      });
    }
  }, 0);
}

/* ---- Medical Reports ---- */
function renderMedical(host){
  const rows = state.medicalReports
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(toUKDate(r.dateStart)),
      escapeHtml(toUKDate(r.reviewDate)),
      escapeHtml(r.details||""),
      escapeHtml(r.workdayUpdated||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Insert a unified filter bar for medical reports
  renderShell(host, "Medical Reports", "Occupational health & GP reports", `
    <button class="btn primary" id="med-add">+ Add medical report</button>
    <button class="btn" id="med-export">Export CSV</button>
  `, `${filterUI('medical', false)}`, `
    <table>
      <thead>
        <tr><th>Colleague</th><th>Manager</th><th>Date start</th><th>Review date</th><th>Details</th><th>Workday / Colleague File updated</th><th>Actions</th></tr>
      </thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="7" class="muted">No medical reports logged yet. Use + Add medical report to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `);

  document.getElementById("med-add").addEventListener("click", ()=>openMedicalModal());
  document.getElementById("med-export").addEventListener("click", ()=>{
    const csv = [["Colleague","Colleague ID","Manager","Date start","Review date","Details","Workday / Colleague File updated"]];
    state.medicalReports.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId), r.colleagueId, managerName(r.managerId), toUKDate(r.dateStart), toUKDate(r.reviewDate), r.details||"", r.workdayUpdated||""]);
    });
    downloadCSV("MedicalReports.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.medicalReports.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Medical reports", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('medicalReports', rec, 'medical report', renderCurrentTab);
      } else {
        openMedicalModal(rec);
      }
    });
  });

  // Attach sorting and search handlers for medical reports.  This will filter and sort the table
  // based on the selected criteria without fully re-rendering the tab.
  {
    const applyFilters = () => applyTableFilters(host, 'medical', 2);
    ['medical-filter','medical-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openMedicalModal(rec=null){
  const isNew = !rec;
  // Medical Reports popup (updated): replace File name with Workday / Colleague File updated (Yes/No)
  const r = rec || { id:uid(), colleagueId:"", managerId:"", dateStart:"", reviewDate:"", details:"", workdayUpdated:"" };
  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="med-col" required>${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="med-mgr" required>${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Date start</label><input id="med-start" type="date" value="${escapeHtml(r.dateStart||"")}" required></div>
      <div class="field"><label>Review date</label><input id="med-review" type="date" value="${escapeHtml(r.reviewDate||"")}" required></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="med-details" placeholder="Add details...">${escapeHtml(r.details||"")}</textarea></div>
      <div class="field" style="grid-column:1/-1"><label>Workday / Colleague File updated</label>
        <select id="med-workday" required>
          <option value="" ${!r.workdayUpdated?"selected":""}>Select...</option>
          <option value="Yes" ${r.workdayUpdated==="Yes"?"selected":""}>Yes</option>
          <option value="No" ${r.workdayUpdated==="No"?"selected":""}>No</option>
        </select>
      </div>
    </div>
  `;
  openModal(isNew?"Add Medical Report":"Edit Medical Report", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save medical report", kind:"primary", onClick: ()=>{
      // Capture previous copy for undo
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("med-col").value;
      r.managerId = document.getElementById("med-mgr").value;
      r.dateStart = fromDateInput(document.getElementById("med-start").value);
      r.reviewDate = fromDateInput(document.getElementById("med-review").value);
      r.details = document.getElementById("med-details").value.trim();
      r.workdayUpdated = document.getElementById("med-workday").value;

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.dateStart) return alert("Select date start");
      if(!r.reviewDate) return alert("Select review date");
      if(!r.details) return alert("Please enter details");
      if(!r.workdayUpdated) return alert("Please select if Workday / Colleague File was updated");

      if(isNew) state.medicalReports.unshift(r);
      else state.medicalReports = state.medicalReports.map(x=>x.id===r.id?r:x);
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'medicalReport', r.id, r.colleagueId, r.workdayUpdated || '');
      }catch(e){}
      closeModal(); renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Medical report added', () => {
          state.medicalReports = state.medicalReports.filter(x=>x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      }else{
        showToast('Medical report updated', () => {
          if(prevCopy){
            const target = state.medicalReports.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}

/* ---- Authorised restrictions ---- */
function renderRestrictions(host){
  const rows = state.restrictions
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(r.restriction||""),
      escapeHtml(toUKDate(r.startDate)),
      escapeHtml(toUKDate(r.reviewDate)),
      escapeHtml(r.ochStatus||""),
      escapeHtml(r.reviewState||""),
      escapeHtml(r.details||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Include a filter bar for authorised restrictions
  renderShell(host, "Authorised restrictions", "Permanent restrictions authorised by OCH / manager.", `
    <button class="btn primary" id="res-add">+ Add restriction</button>
    <button class="btn" id="res-export">Export CSV</button>
  `, `${filterUI('restrictions', false)}`, `
    <table>
      <thead>
        <tr>
          <th>Colleague</th><th>Manager</th><th>Restriction</th><th>Start date</th><th>Review date</th>
          <th>OCH Status</th><th>Review State</th><th>Details</th><th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="9" class="muted">No restrictions logged yet. Use + Add restriction to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `);

  document.getElementById("res-add").addEventListener("click", ()=>openRestrictionModal());
  document.getElementById("res-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Manager","Restriction","Start date","Review date","OCH Status","Review State","Details"]];
    state.restrictions.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId), r.colleagueId, managerName(r.managerId), r.restriction||"", toUKDate(r.startDate), toUKDate(r.reviewDate), r.ochStatus||"", r.reviewState||"", r.details||""]);
    });
    downloadCSV("AuthorisedRestrictions.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.restrictions.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Restrictions", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('restrictions', rec, 'restriction', renderCurrentTab);
      }else openRestrictionModal(rec);
    });
  });

  // Add filter and search behaviour for the restrictions table.  This uses the start date (column index 3) for sorting
  // and the search box to filter rows by colleague, manager or other text content.
  {
    const applyFilters = () => applyTableFilters(host, 'restrictions', 3);
    ['restrictions-filter','restrictions-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openRestrictionModal(rec=null){
  const isNew = !rec;
  const r = rec || { id:uid(), colleagueId:"", managerId:"", restriction:"", startDate:"", reviewDate:"", ochStatus:"", reviewState:"", details:"" };
  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="res-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="res-man">${managerOptions(r.managerId)}</select></div>
      <div class="field" style="grid-column:1/-1"><label>Restriction</label>
        <select id="res-text">
          <option value="">Select</option>
          <option value="Permanent" ${r.restriction==="Permanent"?"selected":""}>Permanent</option>
          <option value="Temporary" ${r.restriction==="Temporary"?"selected":""}>Temporary</option>
        </select></div>
      <div class="field"><label>Start date</label><input id="res-start" type="date" value="${escapeHtml(r.startDate||"")}"></div>
      <div class="field"><label>Review date</label><input id="res-review" type="date" value="${escapeHtml(r.reviewDate||"")}"></div>
      <div class="field"><label>OCH Status</label>
        <select id="res-och">${["","Open","Closed","Awaiting","Escalated"].map(v=>`<option ${v===(r.ochStatus||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}</select>
      </div>
      <div class="field"><label>Review State</label>
        <select id="res-state">${["","Active","Reviewed","Expired"].map(v=>`<option ${v===(r.reviewState||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}</select>
      </div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="res-details">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;
  openModal(isNew?"Add Restriction":"Edit Restriction", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save restriction", kind:"primary", onClick: ()=>{
      // Capture previous copy for undo
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("res-col").value;
      r.managerId = document.getElementById("res-man").value;
      r.restriction = document.getElementById("res-text").value.trim();
      r.startDate = fromDateInput(document.getElementById("res-start").value);
      r.reviewDate = fromDateInput(document.getElementById("res-review").value);
      r.ochStatus = document.getElementById("res-och").value;
      r.reviewState = document.getElementById("res-state").value;
      r.details = document.getElementById("res-details").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.restriction) return alert("Enter restriction");
      if(!r.startDate) return alert("Select start date");
      if(!r.reviewDate) return alert("Select review date");

      // Validate date ordering: review date should not be before start date
      if(r.startDate && r.reviewDate && r.reviewDate < r.startDate){
        alert("Review date cannot be before the start date.");
        return;
      }

      if(isNew) state.restrictions.unshift(r);
      else state.restrictions = state.restrictions.map(x=>x.id===r.id?r:x);
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'restriction', r.id, r.colleagueId, r.restriction || '');
      }catch(e){}
      closeModal(); renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Restriction added', () => {
          state.restrictions = state.restrictions.filter(x => x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      } else {
        showToast('Restriction updated', () => {
          if(prevCopy){
            const target = state.restrictions.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}

/* ---- Flexible leave ---- */
function renderFlexible(host){
  const rows = state.flexibleLeave
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(r.leaveType||""),
      escapeHtml(toUKDate(r.startDate)),
      escapeHtml(toUKDate(r.endDate)),
      escapeHtml(toUKDate(r.contactDate)),
      escapeHtml(r.details||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  renderShell(host, "Flexible leave", "Career / Lifestyle flexible leave logs.", `
    <button class="btn primary" id="fl-add">+ Add flexible leave</button>
    <button class="btn" id="fl-export">Export CSV</button>
  `, `${filterUI('flexible', false)}`, `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Manager</th>
          <th>Type of leave</th>
          <th>Start date</th>
          <th>End date</th>
          <th>Colleague contact date</th>
          <th>Details</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${rows.length ? rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") :
          `<tr><td colspan="8" class="muted">No flexible leave logged yet. Use + Add flexible leave to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `);

  document.getElementById("fl-add").addEventListener("click", ()=>openFlexibleModal());
  document.getElementById("fl-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Manager","Type of leave","Start date","End date","Colleague contact date","Details"]];
    state.flexibleLeave.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([
        colleagueName(r.colleagueId),
        r.colleagueId,
        managerName(r.managerId),
        r.leaveType||"",
        toUKDate(r.startDate),
        toUKDate(r.endDate),
        toUKDate(r.contactDate),
        r.details||""
      ]);
    });
    downloadCSV("FlexibleLeave.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.flexibleLeave.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      if(b.dataset.act==="del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('flexibleLeave', rec, 'flexible leave record', renderCurrentTab);
      } else if(b.dataset.act==="complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Flexible leave", rec.id);
        }
      } else{
        openFlexibleModal(rec);
      }
    });
  });

  // Enable filtering and sorting for flexible leave.  Sort uses the start date (column index 3).
  {
    const applyFilters = () => applyTableFilters(host, 'flexible', 3);
    ['flexible-filter','flexible-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openFlexibleModal(rec=null){
  const isNew = !rec;
  const r = rec || {
    id: uid(),
    colleagueId: "",
    managerId: "",
    leaveType: "",
    startDate: "",
    endDate: "",
    contactDate: "",
    details: ""
  };

  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="fl-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="fl-man">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Type of leave</label>
        <select id="fl-type">
          <option value="">Select</option>
          <option value="Career" ${r.leaveType==="Career"?"selected":""}>Career</option>
          <option value="Lifestyle" ${r.leaveType==="Lifestyle"?"selected":""}>Lifestyle</option>
          <option value="Maternity" ${r.leaveType==="Maternity"?"selected":""}>Maternity</option>
          <option value="Paternity" ${r.leaveType==="Paternity"?"selected":""}>Paternity</option>
        </select>
      </div>
      <div class="field"><label>Start date</label><input id="fl-start" type="date" value="${escapeHtml(r.startDate||"")}"></div>
      <div class="field"><label>End date</label><input id="fl-end" type="date" value="${escapeHtml(r.endDate||"")}"></div>
      <div class="field"><label>Colleague contact date</label><input id="fl-contact" type="date" value="${escapeHtml(r.contactDate||"")}"></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="fl-details" rows="3" placeholder="Add any additional details...">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;

  openModal(isNew?"Add Flexible leave":"Edit Flexible leave", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      // Capture previous copy for undo
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("fl-col").value;
      r.managerId = document.getElementById("fl-man").value;
      r.leaveType = document.getElementById("fl-type").value;
      r.startDate = document.getElementById("fl-start").value;
      r.endDate = document.getElementById("fl-end").value;
      r.contactDate = document.getElementById("fl-contact").value;
      r.details = document.getElementById("fl-details").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.leaveType) return alert("Select type of leave");
      if(!r.startDate) return alert("Select start date");
      if(!r.endDate) return alert("Select end date");
      if(!r.contactDate) return alert("Select colleague contact date");

      if(isNew) state.flexibleLeave.unshift(r);
      else state.flexibleLeave = state.flexibleLeave.map(x=>x.id===r.id?r:x);

      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'flexibleLeave', r.id, r.colleagueId, r.leaveType || '');
      }catch(e){}
      closeModal(); renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Flexible leave added', () => {
          state.flexibleLeave = state.flexibleLeave.filter(x=>x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      } else {
        showToast('Flexible leave updated', () => {
          if(prevCopy){
            const target = state.flexibleLeave.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}

/* ---- IHC process (Add + History) ---- */
function renderIHC(host){
  const rows = state.ihc
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>{
      const l = r.latest || {};
      // Format the date/time into UK format (dd/mm/yyyy hh:mm)
      let dtStr = "";
      if(l.datetime){
        const parts = String(l.datetime).split("T");
        const datePart = parts[0] || "";
        const timePart = parts[1] || "";
        dtStr = `${toUKDate(datePart)} ${timePart}`.trim();
      }
      return [
        // Colleague name and ID
        `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
        // Manager name only (remove underlying ID)
        `<b>${escapeHtml(managerName(r.managerId||""))}</b>`,
        // Date & time of meeting in UK format
        escapeHtml(dtStr),
        // Next meeting date/time in UK format if provided
        (function(){
          const nd = l.nextDT;
          if(!nd) return "";
          const parts = String(nd).split("T");
          const d = parts[0]||"";
          const t = parts[1]||"";
          return `${toUKDate(d)} ${t}`.trim();
        })(),
        escapeHtml(l.restriction || ""),
        escapeHtml(l.meeting || ""),
        // Status of the IHC process
        escapeHtml(l.status||""),
        escapeHtml(l.details||""),
        `<div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
          <button class="btn small primary" data-act="add" data-id="${r.id}">Add</button>
          <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
          <button class="btn small" data-act="history" data-id="${r.id}">History</button>
          <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
        </div>`
      ];
    });

  renderShell(host, "IHC process", "Add updates; latest shown in table.", `
    <button class="btn primary" id="ihc-addnew">+ Add IHC log</button>
    <button class="btn" id="ihc-export">Export CSV</button>
  `, `${filterUI('ihc', false)}`, `
    <table>
      <thead><tr><th>Colleague</th><th>Manager</th><th>Date &amp; time of meeting</th><th>Next meeting</th><th>Meeting type</th><th>Meeting</th><th>Status</th><th>Details</th><th>Actions</th></tr></thead>
      <tbody>
        ${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="9" class="muted">No IHC logs yet.</td></tr>`}
      </tbody>
    </table>
  `);

  document.getElementById("ihc-addnew").addEventListener("click", ()=>openIHCPopup(null));
  document.getElementById("ihc-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Manager","Date & time of meeting","Next meeting","Meeting type","Meeting","Status","Details"]];
    state.ihc.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      const l=r.latest||{};
      const dateMeeting=(function(){
        if(!l.datetime) return "";
        const parts=String(l.datetime).split("T");
        const d=parts[0]||"";
        const t=parts[1]||"";
        return `${toUKDate(d)} ${t}`.trim();
      })();
      const nextMeeting=(function(){
        if(!l.nextDT) return "";
        const parts=String(l.nextDT).split("T");
        const d=parts[0]||"";
        const t=parts[1]||"";
        return `${toUKDate(d)} ${t}`.trim();
      })();
      csv.push([
        colleagueName(r.colleagueId),
        r.colleagueId,
        managerName(r.managerId||""),
        dateMeeting,
        nextMeeting,
        l.restriction||"",
        l.meeting||"",
        l.status||"",
        l.details||""
      ]);
    });
    downloadCSV("IHC.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.ihc.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('ihc', rec, 'IHC log', renderCurrentTab);
      } else if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("IHC process", rec.id);
        }
      } else if(act === "history"){
        openHistoryModal("IHC History", rec);
      } else if(act === "edit"){
        // Edit the latest IHC entry
        openIHCPopup(rec, true);
      } else {
        // default add a new update
        openIHCPopup(rec);
      }
    });
  });

  // Add filtering and sorting for the IHC process table.  Sorting uses the meeting date/time column (index 2).
  {
    const applyFilters = () => applyTableFilters(host, 'ihc', 2);
    ['ihc-filter','ihc-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openIHCPopup(rec=null, editExisting=false){
  const isNew = !rec;
  // extend IHC record to include managerId for conducting manager
  const r = rec || { id:uid(), colleagueId:"", managerId:"", latest:null, history:[] };
  const l = r.latest || {};
  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="ihc-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Conducting manager</label><select id="ihc-manager">${managerOptions(r.managerId||"")}</select></div>
      <div class="field"><label>Date &amp; time of meeting</label><input id="ihc-dt" type="datetime-local" value="${escapeHtml(l.datetime||"")}"></div>
      <div class="field"><label>Time / Date of next meeting</label><input id="ihc-nextdt" type="datetime-local" value="${escapeHtml(l.nextDT||"")}"></div>
      <div class="field"><label>Meeting Type</label>
        <select id="ihc-restriction">
          ${["","Welfare","Capability"].map(v=>`<option value="${v}" ${(l.restriction||"")===v?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
      <div class="field"><label>Meeting</label>
        <select id="ihc-meeting">
          ${["","Meeting 1","Meeting 2","Meeting 3"].map(v=>`<option value="${escapeHtml(v)}" ${v===(l.meeting||"")?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="ihc-details">${escapeHtml(l.details||"")}</textarea></div>
      <div class="field"><label>Status</label>
        <select id="ihc-status">
          ${["","Under review","Ongoing","Closed"].map(v=>`<option value="${v}" ${(l.status||"")===v?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`).join("")}
        </select>
      </div>
    </div>
  `;
  openModal(
    isNew ? "Add IHC Log" : editExisting ? "Edit IHC Log" : "Add update to IHC Log",
    body,
    [
      {label:"Cancel", onClick: closeModal},
      {label:"Save", kind:"primary", onClick: ()=>{
        r.colleagueId = document.getElementById("ihc-col").value;
        const managerId = document.getElementById("ihc-manager").value;
        if(!r.colleagueId) return alert("Select colleague");
        if(!managerId) return alert("Select manager");
        const dt = document.getElementById("ihc-dt").value;
        const nextDTVal = document.getElementById("ihc-nextdt").value;
        const restrictionVal = document.getElementById("ihc-restriction").value;
        const meetingVal = document.getElementById("ihc-meeting").value;
        const detailsVal = document.getElementById("ihc-details").value.trim();
        const statusVal = document.getElementById("ihc-status").value;
        if(!dt) return alert("Select date & time of meeting");
        if(!meetingVal) return alert("Select meeting");
        if(editExisting){
          // Update existing latest entry rather than creating new history entry
          r.latest = r.latest || {};
          const latest = r.latest;
          latest.managerId = managerId;
          latest.datetime  = dt;
          latest.restriction= restrictionVal;
          latest.meeting    = meetingVal;
          latest.details    = detailsVal;
          // update next meeting date/time and status if provided
          latest.nextDT     = nextDTVal;
          latest.status     = statusVal;
          // also update first history record if exists
          r.history = Array.isArray(r.history)? r.history : [];
          if(r.history.length>0){
            r.history[0] = latest;
          } else {
            r.history.unshift(latest);
          }
        } else {
          const entry = {
            id: uid(),
            managerId: managerId,
            datetime: dt,
            restriction: restrictionVal,
            meeting: meetingVal,
            details: detailsVal,
            createdAt: new Date().toISOString()
            ,nextDT: nextDTVal
            ,status: statusVal
          };
          // assign manager on the record so it appears in the table
          r.managerId = managerId;
          // push into history (latest first)
          r.history = Array.isArray(r.history)?r.history:[];
          r.history.unshift(entry);
          r.latest = entry;
        }
        // update manager on record for display
        r.managerId = managerId;
        if(isNew) state.ihc.unshift(r);
        else state.ihc = state.ihc.map(x=>x.id===r.id?r:x);
        saveState(); closeModal(); renderCurrentTab();
      }}
    ]
  );
}

/* ---- Rehabilitations (Add + History) ---- */
function renderRehab(host){
  const rows = state.rehab
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>{
      const l = r.latest || {};
      return [
        `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
        escapeHtml(managerName(l.managerId||"")),
        escapeHtml(toUKDate(l.date)),
        escapeHtml(toUKDate(l.nextDate)),
        escapeHtml(l.week||""),
        escapeHtml(toUKDate(l.signOffDate)),
        escapeHtml(l.details||""),
        `<div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
          <button class="btn small primary" data-act="add" data-id="${r.id}">Add</button>
          <button class="btn small" data-act="editLatest" data-id="${r.id}">Edit</button>
          <button class="btn small" data-act="history" data-id="${r.id}">History</button>
          <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
        </div>`
      ];
    });

  renderShell(host, "Rehabilitations", "Rehabilitation meeting tracking", `
    <button class="btn primary" id="reh-add">+ Add rehabilitation</button>
    <button class="btn" id="reh-export">Export CSV</button>
  `, `${filterUI('rehab', false)}`, `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Manager</th>
          <th>Date of meeting</th>
          <th>Date of next meeting</th>
          <th>Week</th>
          <th>Rehab sign off date</th>
          <th>Details</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="8" class="muted">No rehabilitation logs.</td></tr>`}</tbody>
    </table>
  `);

  // Actions
  document.getElementById("reh-add").onclick = ()=>openRehabPopup(null);
  document.getElementById("reh-export").onclick = ()=>exportCSV("rehab", ["colleagueId","managerId","date","nextDate","week","signOffDate","details"], state.rehab.map(r=>({colleagueId:r.colleagueId, ...(r.latest||{})})));

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.rehab.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('rehab', rec, 'rehabilitation log', renderCurrentTab);
      } else if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Rehabilitation", rec.id);
        }
      } else if(act === "history"){
        openHistoryModal("Rehab History", rec);
      } else if(act === "editLatest"){
        // Edit the latest rehabilitation entry rather than adding a new update
        openRehabPopup(rec, true);
      } else {
        // Add a new update to this rehabilitation record
        openRehabPopup(rec);
      }
    });
  });

  // Filtering and sorting for rehabilitation logs.  Sort by the meeting date (column index 2).
  {
    const applyFilters = () => applyTableFilters(host, 'rehab', 2);
    ['rehab-filter','rehab-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openRehabPopup(rec=null, editExisting=false){
  const isNew = !rec;
  const r = rec || { id:uid(), colleagueId:"", latest:null, history:[] };
  const l = r.latest || {};
  const body = `
    <div class="grid">
      <div class="field">
        <label>Colleague</label>
        <select id="reh-col">${colleagueOptions(r.colleagueId)}</select>
      </div>

      <div class="field">
        <label>Manager</label>
        <select id="reh-mgr">${managerOptions(l.managerId||"")}</select>
      </div>

      <div class="field">
        <label>Date of meeting</label>
        <input id="reh-date" type="date" value="${escapeHtml(l.date||"")}">
      </div>

      <div class="field">
        <label>Date of next meeting</label>
        <input id="reh-nextdate" type="date" value="${escapeHtml(l.nextDate||"")}">
      </div>

      <div class="field">
        <label>Week :</label>
        <select id="reh-week">
          ${["","Week 1","Week 2","Week 3","Week 4","Authorised extension"].map(v=>
            `<option value="${escapeHtml(v)}" ${v===(l.week||"")?"selected":""}>${v===""?"-- Select --":escapeHtml(v)}</option>`
          ).join("")}
        </select>
      </div>

      <div class="field">
        <label>Rehab Sign off date</label>
        <input id="reh-signoff" type="date" value="${escapeHtml(l.signOffDate||"")}">
      </div>

      <div class="field" style="grid-column:1/-1">
        <label>Details</label>
        <textarea id="reh-details" rows="4">${escapeHtml(l.details||"")}</textarea>
      </div>
    </div>
  `;

  openModal(
    isNew ? "Add rehabilitation" : editExisting ? "Edit rehabilitation" : "Update rehabilitation",
    body,
    [
      { label:"Cancel", onClick: closeModal },
      { label: isNew || editExisting ? "Save" : "Save update", kind:"primary", onClick: ()=>{
        const colleagueId = document.getElementById("reh-col").value;
        const managerId  = document.getElementById("reh-mgr").value;
        const date       = document.getElementById("reh-date").value;
        const nextDate   = document.getElementById("reh-nextdate").value;
        const week       = document.getElementById("reh-week").value;
        const signOffDate= document.getElementById("reh-signoff").value;
        const details    = document.getElementById("reh-details").value.trim();

        if(!colleagueId){ alert("Please select a colleague."); return; }
        if(!managerId){ alert("Please select a manager."); return; }
        if(!date){ alert("Please select the date of meeting."); return; }

        // always set colleague for record
        r.colleagueId = colleagueId;
        // editing existing latest entry
        if(editExisting){
          // ensure latest entry exists
          r.latest = r.latest || {};
          const latest = r.latest;
          latest.managerId  = managerId;
          latest.date       = date;
          latest.nextDate   = nextDate;
          latest.week       = week;
          latest.signOffDate= signOffDate;
          latest.details    = details;
          // update manager on record for display
          r.latest = latest;
          // keep history in sync (replace first history entry if exists)
          r.history = Array.isArray(r.history) ? r.history : [];
          if(r.history.length > 0){
            r.history[0] = latest;
          } else {
            r.history.unshift(latest);
          }
        } else {
          // create new history entry
          const entry = {
            datetime: new Date().toISOString(),
            managerId,
            date,
            nextDate,
            week,
            signOffDate,
            details
          };
          r.history = Array.isArray(r.history) ? r.history : [];
          r.history.unshift(entry);
          r.latest = entry;
        }
        // update manager id for display when editing or adding
        r.latest.managerId = managerId;
        // update overall state array
        if(isNew) state.rehab.unshift(r);
        else state.rehab = state.rehab.map(x=>x.id===r.id?r:x);
        saveState();
        closeModal();
        renderCurrentTab();
      }}
    ]
  );
}

function openHistoryModal(title, rec){
  const items = (rec.history||[]).map(h=>`
    <div style="border:1px solid var(--line);border-radius:12px;padding:10px;margin-bottom:10px;background:#fff">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <b>${escapeHtml(toUKDate(h.datetime||h.date||h.meetingDate||h.rehabStart||h.createdAt))}</b>
        <span class="muted">${escapeHtml(h.meeting||h.week||h.stage||h.nextAction||"")}</span>
      </div>
      <div class="muted" style="margin-top:6px;white-space:pre-wrap">${escapeHtml(h.details||"-")}</div>
    </div>
  `).join("") || `<div class="muted">No history yet.</div>`;
  openModal(`${title} — ${colleagueName(rec.colleagueId)}`, items, [{label:"Close", kind:"primary", onClick: closeModal}]);
}

/* ---- Ill Health Leave ---- */
function renderIllHealth(host){
  const rows = state.illHealth
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>{
      // Only show colleague and manager names without IDs to avoid random alphanumeric codes
      const colName = `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b>`;
      const mgrName = `<b>${escapeHtml(managerName(r.managerId)||"-")}</b>`;
      return [
        colName,
        mgrName,
        escapeHtml(toUKDate(r.startDate)),
        escapeHtml(toUKDate(r.endDate)),
        escapeHtml(r.details||""),
        `<div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
          <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
          <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
        </div>`
      ];
    });

  // Show filter bar for ill health leave
  renderShell(host, "Ill Health Leave", "Long-term ill health cases", `
    <button class="btn primary" id="ihl-add">+ Add ill health leave</button>
    <button class="btn" id="ihl-export">Export CSV</button>
  `, `${filterUI('illhealth', false)}`, `
    <table>
      <thead><tr><th>Colleague</th><th>Manager</th><th>Start date</th><th>End date</th><th>Details</th><th>Actions</th></tr></thead>
      <tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="5" class="muted">No ill health leave logged yet. Use + Add ill health leave to record your first entry.</td></tr>`}</tbody>
    </table>
  `);

  document.getElementById("ihl-add").addEventListener("click", ()=>openIllHealthModal());
  document.getElementById("ihl-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Manager","Manager ID","Start date","End date","Details"]];
    state.illHealth.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId),r.colleagueId,managerName(r.managerId)||"",r.managerId||"",toUKDate(r.startDate),toUKDate(r.endDate),r.details||""]);
    });
    downloadCSV("IllHealthLeave.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.illHealth.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Ill health leave", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('illHealth', rec, 'ill health record', renderCurrentTab);
      } else {
        openIllHealthModal(rec);
      }
    });
  });

  // Add filtering and sorting for ill health leave.  Sort uses the start date column (index 2).
  {
    const applyFilters = () => applyTableFilters(host, 'illhealth', 2);
    ['illhealth-filter','illhealth-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}

function openIllHealthModal(rec=null){
  const isNew = !rec;
  const r = rec || { id:uid(), colleagueId:"", managerId:"", startDate:"", endDate:"", details:"" };
  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="ihl-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="ihl-mgr">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Start date</label><input id="ihl-start" type="date" value="${escapeHtml(r.startDate||"")}"></div>
      <div class="field"><label>End date</label><input id="ihl-end" type="date" value="${escapeHtml(r.endDate||"")}"></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="ihl-details">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;
  openModal(isNew?"Add Ill Health Leave":"Edit Ill Health Leave", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      // Capture previous copy for undo
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("ihl-col").value;
      r.managerId = document.getElementById("ihl-mgr").value;
      r.startDate = fromDateInput(document.getElementById("ihl-start").value);
      r.endDate = fromDateInput(document.getElementById("ihl-end").value);
      r.details = document.getElementById("ihl-details").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.startDate) return alert("Select start date");

      if(isNew) state.illHealth.unshift(r);
      else state.illHealth = state.illHealth.map(x=>x.id===r.id?r:x);
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'illHealth', r.id, r.colleagueId, r.details || '');
      }catch(e){}
      closeModal(); renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Ill health leave added', () => {
          state.illHealth = state.illHealth.filter(x=>x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      } else {
        showToast('Ill health leave updated', () => {
          if(prevCopy){
            const target = state.illHealth.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}

/* ---- Bereavement ---- */
function renderBereavement(host){
  const rows = state.bereavement
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      // Display manager name without showing the underlying ID
      `<b>${escapeHtml(managerName(r.managerId))}</b>`,
      escapeHtml(toUKDate(r.startDate)),
      escapeHtml(toUKDate(r.endDate)),
      escapeHtml(r.details||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Include filter bar for bereavement logs
  renderShell(host, "Bereavement", "Bereavement leave tracking.", `
    <button class="btn primary" id="ber-add">+ Add bereavement</button>
    <button class="btn" id="ber-export">Export CSV</button>
  `, `${filterUI('bereavement', false)}`, `
    <table>
      <thead><tr><th>Colleague</th><th>Manager</th><th>Start date</th><th>End date</th><th>Details</th><th>Actions</th></tr></thead>
      <tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="5" class="muted">No bereavement logs yet.</td></tr>`}</tbody>
    </table>
  `);

  document.getElementById("ber-add").addEventListener("click", ()=>openBereavementModal());
  document.getElementById("ber-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Manager","Manager ID","Start date","End date","Details"]];
    state.bereavement.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId),r.colleagueId,managerName(r.managerId),r.managerId,toUKDate(r.startDate),toUKDate(r.endDate),r.details||""]);
    });
    downloadCSV("Bereavement.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.bereavement.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Bereavement", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('bereavement', rec, 'bereavement log', renderCurrentTab);
      } else {
        openBereavementModal(rec);
      }
    });
  });

  // Enable search and sort for bereavement logs.  Uses start date column (index 2) for sorting.
  {
    const applyFilters = () => applyTableFilters(host, 'bereavement', 2);
    ['bereavement-filter','bereavement-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}
function openBereavementModal(rec=null){
  const isNew=!rec;
  const r=rec||{id:uid(),colleagueId:"",managerId:"",startDate:"",endDate:"",details:""};
  const body=`
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="ber-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="ber-mgr">${managerOptions(r.managerId||"")}</select></div>
      <div class="field"><label>Start date</label><input id="ber-start" type="date" value="${escapeHtml(r.startDate||"")}"></div>
      <div class="field"><label>End date</label><input id="ber-end" type="date" value="${escapeHtml(r.endDate||"")}"></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="ber-details">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;
  openModal(isNew?"Add Bereavement":"Edit Bereavement", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      r.colleagueId=document.getElementById("ber-col").value;
      r.managerId=document.getElementById("ber-mgr").value;
      r.startDate=fromDateInput(document.getElementById("ber-start").value);
      r.endDate=fromDateInput(document.getElementById("ber-end").value);
      r.details=document.getElementById("ber-details").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.startDate) return alert("Select start date");
      if(!r.endDate) return alert("Select end date");

      if(isNew) state.bereavement.unshift(r);
      else state.bereavement = state.bereavement.map(x=>x.id===r.id?r:x);
      saveState(); closeModal(); renderCurrentTab();
    }}
  ]);
}

/* ---- AWOL ---- */
function renderAWOL(host){
  const rows = state.awol
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(toUKDate(r.dateAwol)),
      escapeHtml(r.gitSent||""),
      escapeHtml(toUKDate(r.gitSentDate)),
      escapeHtml(r.callBackAttempted||""),
      escapeHtml(r.nextAction||""),
      escapeHtml(toUKDate(r.nextActionDate)),
      escapeHtml(r.details||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Add a filter bar for AWOL logs
  renderShell(host, "AWOL", "Absent without leave", `
    <button class="btn primary" id="aw-add">+ Add AWOL</button>
    <button class="btn" id="aw-export">Export CSV</button>
  `, `${filterUI('awol', false)}`, `
    <table>
      <thead><tr><th>Colleague</th><th>Manager</th><th>Date of AWOL</th><th>GIT letter sent?</th><th>Date letter sent</th><th>Call back attempted?</th><th>Next Action</th><th>Next action date</th><th>Details</th><th>Actions</th></tr></thead>
      <tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="10" class="muted">No AWOL logs yet.</td></tr>`}</tbody>
    </table>
  `);

  document.getElementById("aw-add").addEventListener("click", ()=>openAwolModal());
  document.getElementById("aw-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Manager","Date of AWOL","GIT sent","GIT sent date","Callback attempted","Next action","Next action date","Details"]];
    state.awol.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId),r.colleagueId,managerName(r.managerId),toUKDate(r.dateAwol),r.gitSent||"",toUKDate(r.gitSentDate),r.callBackAttempted||"",r.nextAction||"",toUKDate(r.nextActionDate),r.details||""]);
    });
    downloadCSV("AWOL.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.awol.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("AWOL", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('awol', rec, 'AWOL log', renderCurrentTab);
      } else {
        openAwolModal(rec);
      }
    });
  });

  // Filtering and sorting for AWOL logs.  Uses the date of AWOL column (index 2) for sorting.
  {
    const applyFilters = () => applyTableFilters(host, 'awol', 2);
    ['awol-filter','awol-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}
function openAwolModal(rec=null){
  const isNew=!rec;
  const r=rec||{id:uid(),colleagueId:"",managerId:"",dateAwol:"",gitSent:"",gitSentDate:"",callBackAttempted:"",nextAction:"",nextActionDate:"",details:""};
  const body=`
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="aw-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Manager</label><select id="aw-man">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Date of AWOL</label><input id="aw-date" type="date" value="${escapeHtml(r.dateAwol||"")}"></div>
      <div class="field"><label>GIT letter sent?</label>
        <select id="aw-git">${["","Yes","No"].map(v=>`<option ${v===(r.gitSent||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}</select>
      </div>
      <div class="field"><label>Date letter sent</label><input id="aw-gitdate" type="date" value="${escapeHtml(r.gitSentDate||"")}"></div>
      <div class="field"><label>Call back attempted?</label>
        <select id="aw-cb">${["","Yes","No"].map(v=>`<option ${v===(r.callBackAttempted||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}</select>
      </div>
      <div class="field"><label>Next Action</label>
        <select id="aw-nextAction">
          ${["","Attempt Call back","Send GIT letter","Review CSP"].map(v=>`<option ${v===(r.nextAction||"")?"selected":""}>${v===""?"-- Select --":v}</option>`).join("")}
        </select>
      </div>
      <div class="field"><label>Next action date</label><input id="aw-nextdate" type="date" value="${escapeHtml(r.nextActionDate||"")}"></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="aw-details">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;
  openModal(isNew?"Add AWOL":"Edit AWOL", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save AWOL", kind:"primary", onClick: ()=>{
      r.colleagueId=document.getElementById("aw-col").value;
      r.managerId=document.getElementById("aw-man").value;
      r.dateAwol=fromDateInput(document.getElementById("aw-date").value);
      r.gitSent=document.getElementById("aw-git").value;
      r.gitSentDate=fromDateInput(document.getElementById("aw-gitdate").value);
      r.callBackAttempted=document.getElementById("aw-cb").value;
      r.nextAction=document.getElementById("aw-nextAction").value;
      r.nextActionDate=fromDateInput(document.getElementById("aw-nextdate").value);
      r.details=document.getElementById("aw-details").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.managerId) return alert("Select manager");
      if(!r.dateAwol) return alert("Select date of AWOL");
      if(!r.nextActionDate) return alert("Select next action date");

      if(isNew) state.awol.unshift(r);
      else state.awol = state.awol.map(x=>x.id===r.id?r:x);
      saveState(); closeModal(); renderCurrentTab();
    }}
  ]);
}

/* ---- Me Days ---- */
function renderMeDays(host){
  const rows = state.meDays
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      escapeHtml(managerName(r.managerId)),
      escapeHtml(toUKDate(r.date)),
      escapeHtml(String(r.days26 ?? "")),
      escapeHtml(r.reason||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  const actions = `
    <button class="btn primary" id="meday-add">+ Add Me Day</button>
    <button class="btn" id="meday-export">Export CSV</button>
  `;

  const tableHTML = `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Authorising Manager</th>
          <th>Logged</th>
          <th>Me days (last 26 weeks)</th>
          <th>Reason</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${rows.length ? rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") : `<tr><td colspan="6" class="muted">No Me Days logged yet. Use + Add Me Day to record your first entry.</td></tr>`}
      </tbody>
    </table>
  `;

  // Use the shared scaffold so the Me Days tab matches the new layout.
  // Add filter bar for Me Days
  renderShell(host, "Me Days", "", actions, `${filterUI('medays', false)}`, tableHTML);

  document.getElementById("meday-add").addEventListener("click", ()=>openMeDayModal());
  document.getElementById("meday-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Authorising Manager","Logged","Me days taken in last 26 weeks","Reason"]];
    state.meDays.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId),r.colleagueId,managerName(r.managerId),toUKDate(r.date),String(r.days26 ?? ""),r.reason||""]);
    });
    downloadCSV("MeDays.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.meDays.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Me days", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('meDays', rec, 'Me Day log', renderCurrentTab);
      } else {
        openMeDayModal(rec);
      }
    });
  });

  // Apply filter and sorting to the Me Days table.  Sort uses the logged date column (index 2).
  {
    const applyFilters = () => applyTableFilters(host, 'medays', 2);
    ['medays-filter','medays-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}
function openMeDayModal(rec=null){
  const isNew=!rec;
  const today = new Date().toISOString().slice(0,10);
  const r = rec || {id:uid(), colleagueId:"", managerId:"", date:today, days26:0, reason:""};

  const body = `
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="me-col">${colleagueOptions(r.colleagueId)}</select></div>
      <div class="field"><label>Authorising Manager</label><select id="me-man">${managerOptions(r.managerId)}</select></div>
      <div class="field"><label>Me days taken in the last 26 weeks</label><input id="me-days26" type="number" min="0" step="1" value="${escapeHtml(String(r.days26 ?? 0))}"></div>
      <div class="field" style="grid-column:1 / -1"><label>Reason</label><textarea id="me-reason" rows="4" placeholder="Add details / reason...">${escapeHtml(r.reason||"")}</textarea></div>
    </div>
  `;

  openModal(isNew ? "Add Me Day" : "Edit Me Day", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      // Capture previous copy for undo
      const prevCopy = rec ? { ...rec } : null;
      r.colleagueId = document.getElementById("me-col").value;
      r.managerId = document.getElementById("me-man").value;
      const n = parseInt(document.getElementById("me-days26").value, 10);
      r.days26 = isNaN(n) ? 0 : Math.max(0, n);
      r.reason = document.getElementById("me-reason").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");

      // Ensure date exists for legacy compatibility (used for sorting / display)
      if(!r.date) r.date = new Date().toISOString().slice(0,10);

      if(isNew){
        state.meDays.unshift(r);
      }
      saveState();
      // Record audit
      try{
        logAudit(isNew ? 'create' : 'update', 'meDay', r.id, r.colleagueId, r.reason || '');
      }catch(e){}
      closeModal();
      renderCurrentTab();
      // Toast notifications
      if(isNew){
        showToast('Me Day added', () => {
          state.meDays = state.meDays.filter(x => x.id !== r.id);
          saveState();
          renderCurrentTab();
        });
      } else {
        showToast('Me Day updated', () => {
          if(prevCopy){
            const target = state.meDays.find(x => x.id === prevCopy.id);
            if(target){ Object.assign(target, prevCopy); }
            saveState();
            renderCurrentTab();
          }
        });
      }
    }}
  ]);
}
function renderLateRTW(host){
  const rows = state.lateRTW
    .filter(r=>deptPass(r.colleagueId))
    .map(r=>[
      `<b class="col-link" data-col-id="${r.colleagueId}">${escapeHtml(colleagueName(r.colleagueId))}</b><div class="muted">${escapeHtml(r.colleagueId)}</div>`,
      // Show only the manager's name; omit the underlying ID to avoid confusing characters
      `<b>${escapeHtml(managerName(r.managerId))}</b>`,
      escapeHtml(r.timeArrived||""),
      escapeHtml(r.shiftStart||""),
      escapeHtml(r.occasion||""),
      escapeHtml(r.details||""),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small ok" data-act="complete" data-id="${r.id}">Complete</button>
        <button class="btn small" data-act="edit" data-id="${r.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${r.id}">Delete</button>
      </div>`
    ]);

  // Include filter bar for Late RTW logs
  renderShell(host, "Late RTW", "Late return to work tracking", `
    <button class="btn primary" id="lr-add">+ Add Late RTW</button>
    <button class="btn" id="lr-export">Export CSV</button>
  `, `${filterUI('latertw', false)}`, `
    <table>
      <thead><tr><th>Colleague</th><th>Manager</th><th>Time arrived</th><th>Shift start time</th><th>Occasion</th><th>Details</th><th>Actions</th></tr></thead>
      <tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="7" class="muted">No Late RTW logs yet.</td></tr>`}</tbody>
    </table>
  `);

  document.getElementById("lr-add").addEventListener("click", ()=>openLateRTWModal());
  document.getElementById("lr-export").addEventListener("click", ()=>{
    const csv=[["Colleague","Colleague ID","Time arrived","Shift start time","Occasion","Details"]];
    state.lateRTW.filter(r=>deptPass(r.colleagueId)).forEach(r=>{
      csv.push([colleagueName(r.colleagueId),r.colleagueId,r.timeArrived||"",r.shiftStart||"",r.occasion||"",r.details||""]);
    });
    downloadCSV("LateRTW.csv", csv);
  });

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.lateRTW.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      const act = b.dataset.act;
      if(act === "complete"){
        if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
          completeRecord("Late RTW", rec.id);
        }
        return;
      }
      if(act === "del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('lateRTW', rec, 'Late RTW log', renderCurrentTab);
      } else {
        openLateRTWModal(rec);
      }
    });
  });

  // Add filtering for late RTW logs.  There is no date column, so sorting will not change the order.
  {
    const applyFilters = () => applyTableFilters(host, 'latertw', null);
    ['latertw-filter','latertw-search'].forEach(id=>{
      const el = document.getElementById(id);
      if(el){
        const evt = id.endsWith('search') ? 'input' : 'change';
        el.addEventListener(evt, applyFilters);
      }
    });
    applyFilters();
  }
}
function openLateRTWModal(rec=null){
  const isNew=!rec;
  // Match pre-rewrite popup fields exactly: Time arrived, shift start time, occasion, details
  const r=rec||{id:uid(),managerId:"",colleagueId:"",timeArrived:"",shiftStart:"",occasion:"",details:""};
  const body=`
    <div class="grid">
      <div class="field"><label>Colleague</label><select id="lr-col">${colleagueOptions(r.colleagueId)}</select></div>
            <div class="field"><label>Manager</label><select id="lr-mgr">${managerOptions(r.managerId)}</select></div>
<div class="field"><label>Time arrived</label><input id="lr-arr" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.timeArrived||"")}"></div>
      <div class="field"><label>Shift start time</label><input id="lr-shift" type="text" placeholder="--:--" list="timeOptions" value="${escapeHtml(r.shiftStart||"")}"></div>
      <div class="field"><label>Occasion</label><input id="lr-occ" value="${escapeHtml(r.occasion||"")}"></div>
      <div class="field" style="grid-column:1/-1"><label>Details</label><textarea id="lr-details">${escapeHtml(r.details||"")}</textarea></div>
    </div>
  `;
  openModal(isNew?"Add Late RTW":"Edit Late RTW", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      r.colleagueId=document.getElementById("lr-col").value;
            r.managerId=document.getElementById("lr-mgr").value;
r.timeArrived=document.getElementById("lr-arr").value;
      r.shiftStart=document.getElementById("lr-shift").value;
      r.occasion=document.getElementById("lr-occ").value.trim();
      r.details=document.getElementById("lr-details").value.trim();

      if(!r.colleagueId) return alert("Select colleague");
      if(!r.managerId) return alert("Select manager");
      if(!r.timeArrived) return alert("Enter time arrived");
      if(!r.shiftStart) return alert("Enter shift start time");
      if(!r.occasion) return alert("Enter occasion");

      // Validate time formats for arrival and shift start
      if(r.timeArrived && !isValidTimeString(r.timeArrived)){
        alert("Please enter a valid arrival time in HH:MM format.");
        return;
      }
      if(r.shiftStart && !isValidTimeString(r.shiftStart)){
        alert("Please enter a valid shift start time in HH:MM format.");
        return;
      }

      if(isNew) state.lateRTW.unshift(r);
      else state.lateRTW = state.lateRTW.map(x=>x.id===r.id?r:x);
      saveState(); closeModal(); renderCurrentTab();
    }}
  ]);
}

/* ==========================
   People & Admin
   ========================== */
function renderColleagues(host){
  // Build filter dropdown for managers.  Include an "All" option followed by each manager.
  const mgrOpts = [
    `<option value="ALL" ${!ui.colManagerFilter || ui.colManagerFilter==="ALL" ? 'selected' : ''}>All managers</option>`,
    ...state.managers.map(m => `<option value="${escapeHtml(m.id)}" ${ui.colManagerFilter===m.id?'selected':''}>${escapeHtml(m.name)}</option>`) 
  ];
  // Compose the filters HTML row.  It includes the manager filter and search box.
  const filtersHTML = `
    <div style="margin:10px 0; display:flex; gap:10px; flex-wrap:wrap; position:relative; z-index:2; width:100%">
      <select id="col-manager-filter">${mgrOpts.join('')}</select>
      <input type="text" id="col-search" placeholder="Search..." value="${escapeHtml(ui.colSearch||'')}" style="flex:1; min-width:200px; padding:4px 8px; box-sizing:border-box;">
    </div>
  `;

  // (removed old filteredCols/rows definitions; row generation is now handled by buildColRows)

  // Helper to build colleague rows based on current filters.  This function is
  // defined here so it can be reused for the initial render and for subsequent
  // refreshes when the manager or search filters change without re-rendering the
  // entire tab.
  const buildColRows = () => {
    const filteredCols = state.colleagues
      .filter(c => (ui.dept === 'ALL' || c.department === ui.dept))
      .filter(c => !ui.colManagerFilter || ui.colManagerFilter === 'ALL' || c.teamManagerId === ui.colManagerFilter)
      .filter(c => {
        const s = (ui.colSearch || '').toLowerCase().trim();
        if(!s) return true;
        const dept = c.department ? c.department.toLowerCase() : '';
        const tmName = c.teamManagerId ? managerName(c.teamManagerId).toLowerCase() : '';
        return c.name.toLowerCase().includes(s) || c.id.toLowerCase().includes(s) || dept.includes(s) || tmName.includes(s);
      });
    return filteredCols.map(c=>{
      let statusTag;
      if(c.status === "Resigned"){
        statusTag = '<span class="tag bad">Resigned</span>';
      }else if(c.status === "Suspended"){
        statusTag = '<span class="tag warn">Suspended</span>';
      }else if(isCurrentlyAbsent(c.id)){
        statusTag = '<span class="tag bad">Absent</span>';
      }else{
        statusTag = '<span class="tag ok">At work</span>';
      }
      const warnAction = latestWarningAction(c.id);
      let warnTag;
      if(warnAction){
        warnTag = `<span class="tag warn">${escapeHtml(warnAction)}</span>`;
      }else{
        warnTag = '<span class="tag ok">None</span>';
      }
      const rType = restrictionTypeFor(c.id);
      let resTag;
      if(rType === "Permanent"){
        resTag = '<span class="tag bad">Permanent</span>';
      }else if(rType === "Temporary"){
        resTag = '<span class="tag warn">Temporary</span>';
      }else{
        resTag = '<span class="tag ok">None</span>';
      }
      return [
        `<b class="col-link" data-col-id="${c.id}">${escapeHtml(c.name)}</b><div class="muted">${escapeHtml(c.id)}</div>`,
        escapeHtml(c.department),
        (c.teamManagerId ? escapeHtml(managerName(c.teamManagerId)) : ''),
        escapeHtml(c.contact||""),
        statusTag,
        warnTag,
        resTag,
        `<div style="display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn small info" data-act="timeline" data-id="${c.id}">Timeline</button>
          <button class="btn small" data-act="edit" data-id="${c.id}">Edit</button>
          <button class="btn small danger" data-act="del" data-id="${c.id}">Delete</button>
        </div>`
      ];
    });
  };

  const initialRows = buildColRows();

  renderShell(host, "Colleagues", "Add/edit colleagues used across all dropdowns.", `
    <button class="btn primary" id="col-add">+ Add colleague</button>
  `, filtersHTML, `
    <table>
      <thead>
        <tr>
          <th>Colleague</th>
          <th>Department</th>
          <th>Team Manager</th>
          <th>Contact</th>
          <th>Status</th>
          <th>Warnings</th>
          <th>Restrictions</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="col-tbody">${initialRows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="8" class="muted">No colleagues.</td></tr>`}</tbody>
    </table>
  `);

  // Define a function to refresh the colleague rows in-place without re-rendering the entire tab.
  function refreshColRows(){
    const tbody = host.querySelector('#col-tbody');
    if(!tbody) return;
    const rows = buildColRows();
    const html = rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="8" class="muted">No colleagues.</td></tr>`;
    tbody.innerHTML = html;
    // Attach actions to the new buttons
    tbody.querySelectorAll('button[data-act]').forEach(b=>{
      b.addEventListener('click', ()=>{
        const id = b.dataset.id;
        const rec = state.colleagues.find(x=>x.id===id);
        if(!rec) return;
        const act = b.dataset.act;
        if(act === 'timeline'){
          // Add to recents and open the colleague's timeline
          addRecentColleague(id);
          openTimeline(id);
        }else if(act === 'del'){
          // Use generic deletion helper with audit and undo
          handleDeleteRecord('colleagues', rec, 'colleague', refreshColRows);
        }else{
          openColleagueModal(rec);
        }
      });
    });
    // Attach click handlers for colleague links
    tbody.querySelectorAll('.col-link').forEach(link => {
      link.addEventListener('click', () => {
        const id = link.dataset.colId;
        addRecentColleague(id);
        openTimeline(id);
      });
    });
  }

  document.getElementById("col-add").addEventListener("click", ()=>openColleagueModal());

  // Attach event listeners to the colleagues manager filter and search box.  When either control
  // changes, update the UI state and re-render the tab.  The manager filter uses 'ALL' to
  // show all managers.
  const mgrFilterEl = host.querySelector('#col-manager-filter');
  if(mgrFilterEl){
    mgrFilterEl.addEventListener('change', () => {
      ui.colManagerFilter = mgrFilterEl.value || 'ALL';
      saveUI();
      // Refresh rows instead of re-rendering the entire tab
      refreshColRows();
    });
  }
  const colSearchEl = host.querySelector('#col-search');
  if(colSearchEl){
    // When typing in the colleague search box, persist the value to ui and update
    // the table without re-rendering the entire tab.  Debounce updates to avoid
    // filtering on every keystroke in quick succession.
    colSearchEl.addEventListener('input', () => {
      ui.colSearch = colSearchEl.value;
      saveUI();
      if(window.__colSearchTimer){
        clearTimeout(window.__colSearchTimer);
      }
      window.__colSearchTimer = setTimeout(() => {
        refreshColRows();
      }, 200);
    });
    // Also refresh when the user presses Enter or the input loses focus.
    colSearchEl.addEventListener('keyup', (ev) => {
      if(ev.key === 'Enter'){
        if(window.__colSearchTimer){
          clearTimeout(window.__colSearchTimer);
          window.__colSearchTimer = null;
        }
        refreshColRows();
      }
    });
    colSearchEl.addEventListener('change', () => {
      if(window.__colSearchTimer){
        clearTimeout(window.__colSearchTimer);
        window.__colSearchTimer = null;
      }
      refreshColRows();
    });
  }

  // Immediately invoke refreshColRows on initial render so that timeline/edit/delete
  // buttons are wired up. Without this call, the action buttons are inert until a
  // filter or search input triggers a refresh.
  refreshColRows();

  // Action buttons inside the colleague table are handled within refreshColRows().
}

/* ---- Upcoming Actions tab ---- */
function renderUpcoming(host){
  // Build grouped upcoming actions by category. Each category gets its own heading and table.
  const groups = {};
  // Absence: nextActionDT and nextActionType
  state.absences.forEach(r=>{
    const e = (r.events||[])[0];
    if(!e || !e.nextActionDT) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "Absence";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: e.nextActionDT,
      extra: e.nextActionType || ""
    };
    // skip if marked complete
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // Flexible leave: contactDate (no extra)
  state.flexibleLeave.forEach(r=>{
    if(!r.contactDate) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "Flexible leave";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: r.contactDate,
      extra: "Contact Date"
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // IHC process: nextDT (only include if nextDT exists)
  state.ihc.forEach(r=>{
    const l = r.latest || {};
    const nd = l.nextDT;
    if(!nd) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "IHC process";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: nd,
      extra: ""
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // Rehabilitation: nextDate
  state.rehab.forEach(r=>{
    const l = r.latest || {};
    const nd = l.nextDate;
    if(!nd) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "Rehabilitation";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: nd,
      extra: l.week ? `Week ${l.week}` : ""
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // Ill health leave: endDate
  state.illHealth.forEach(r=>{
    if(!r.endDate) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "Ill health leave";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: r.endDate,
      extra: "End date"
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // Bereavement: endDate
  state.bereavement.forEach(r=>{
    if(!r.endDate) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "Bereavement";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: r.endDate,
      extra: "End date"
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // Warnings: hearing date/time
  (state.warnings || []).forEach(r=>{
    if(!r.hearingDate) return;
    if(!deptPass(r.colleagueId)) return;
    const key = "Warnings";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      // If a hearing time is provided, append it to the date using 'T' to create a date-time string
      due: (r.hearingTime && r.hearingTime !== "") ? `${r.hearingDate}T${r.hearingTime}` : r.hearingDate,
      extra: r.action || ""
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });
  // Investigations: date/time
  (state.investigations || []).forEach(r=>{
    if(!r.date) return;
    if(!deptPass(r.colleagueId)) return;
    let dueStr = r.date;
    if(r.time){
      dueStr = `${r.date}T${r.time}`;
    }
    const key = "Investigations";
    groups[key] = groups[key] || [];
    const rec = {
      category: key,
      colleagueId: r.colleagueId,
      colleagueName: colleagueName(r.colleagueId),
      due: dueStr,
      extra: r.outcome || ""
    };
    if(!state.completedUpcoming.some(c=>c.category===rec.category && c.colleagueId===rec.colleagueId && c.due===rec.due)){
      groups[key].push(rec);
    }
  });

  // Before rebuilding the upcoming actions tab, capture the current filter selections and
  // search value from any existing filter bar.  Without preserving these values,
  // the search box and sort/type dropdowns will reset to their default on every
  // re-render (e.g. on each keypress), causing the user’s input to disappear.
  const prevFilterEl = document.getElementById("upcoming-filter");
  const prevTypeEl   = document.getElementById("upcoming-type");
  const prevSearchEl = document.getElementById("upcoming-search");
  const sortVal      = prevFilterEl ? prevFilterEl.value : "new";
  const typeVal      = prevTypeEl ? prevTypeEl.value : "";
  // Persist the upcoming search value in the ui object so it survives
  // subsequent re-renders within the same session.  If the input exists
  // from a previous render, capture its current value; otherwise retain
  // whatever was stored previously.
  if(prevSearchEl){
    ui.upcomingSearch = prevSearchEl.value;
  }
  const origSearchVal = ui.upcomingSearch || "";

  // Build HTML content for each group
  let content="";
  Object.keys(groups).forEach(groupName=>{
    const items = groups[groupName];
    // Sort each group by due date
    items.sort((a,b)=> new Date(a.due) - new Date(b.due));
    // Table rows for this group
    const rows = items.map(item=>{
      let displayDT="";
      if(item.due){
        const str=String(item.due);
        if(str.includes("T")){
          const parts=str.split("T");
          const d=parts[0];
          const t=parts[1]||"";
          displayDT = `${toUKDate(d)} ${t}`.trim();
        }else{
          displayDT = toUKDate(item.due);
        }
      }
      // Determine row style based on due date/time relative to current date/time
      let rowStyle="";
      try{
        const now = new Date();
        const dueDate = new Date(item.due);
        if(!isNaN(dueDate.getTime())){
          // Compare date parts for yellow (due today)
          const sameDay = now.getFullYear()===dueDate.getFullYear() && now.getMonth()===dueDate.getMonth() && now.getDate()===dueDate.getDate();
          if(sameDay){
            // highlight for actions due today: use a bolder yellow colour
            rowStyle = 'background:#fff2b2;';
          }
          // overdue if dueDate < now (time included)
          if(dueDate < now){
            // highlight overdue actions with a stronger red tint
            rowStyle = 'background:#ffb3b3;';
          }
        }
      }catch(err){}
      return `<tr style="${rowStyle}"><td><b>${escapeHtml(item.colleagueName)}</b><div class="muted">${escapeHtml(item.colleagueId)}</div></td><td>${escapeHtml(item.extra||"")}</td><td>${escapeHtml(displayDT)}</td><td><button class="btn small danger" data-act="completeUpcoming" data-category="${escapeHtml(item.category)}" data-col="${escapeHtml(item.colleagueId)}" data-due="${escapeHtml(item.due)}" data-extra="${escapeHtml(item.extra||"")}">Complete</button></td></tr>`;
    }).join("");
    // Build a table with a group heading row spanning all columns.  The first
    // header row contains the group name centred across the four columns and
    // uses the same green background as the other headers.  This ensures
    // headings remain aligned and coloured consistently with the site theme.
    // Insert a separate heading element with green background for this category
    content += `<h3 class="group-heading">${escapeHtml(groupName)}</h3>`;
    // Build the table for this group.  Column headers use green text on a neutral background and larger font size
    content += `<table class="upcoming-table"><thead>`;
    content += `<tr><th style="font-size:16px;font-weight:bold;color:var(--green2);background:transparent;">Colleague</th><th style="font-size:16px;font-weight:bold;color:var(--green2);background:transparent;">Details</th><th style="font-size:16px;font-weight:bold;color:var(--green2);background:transparent;">Due date/time</th><th style="font-size:16px;font-weight:bold;color:var(--green2);background:transparent;">Action</th></tr>`;
    content += `</thead><tbody>${rows}</tbody></table>`;
  });
  if(!content){
    // Friendly empty state when no upcoming actions
    content = `<div class="muted">No upcoming actions – nice work 👍</div>`;
  }
  // Build actions bar and filters.  The upcoming actions page now includes a filter
  // bar with sort, type and search options, similar to other tabs.  We also
  // change the confirmation prompt to remind the user to ensure paperwork is up
  // to date.  Completed upcoming actions are simply hidden and do not appear
  // anywhere else.
  const actionsBar = `
    <button class="btn" id="export-upcoming-csv">Export CSV</button>
    <button class="btn" id="export-upcoming-pdf">Export PDF</button>
  `;
  // Render with filter bar using the shared filterUI helper.  The type filter
  // allows selecting categories from all logs.
  renderShell(host, "Upcoming actions", "Actions that are due soon.", actionsBar, `${filterUI('upcoming', true)}`, content);
  // After rendering the new filter bar, restore the previously selected sort, type
  // and search values so the dropdowns and search box reflect the user's
  // current input.  Without restoring these values the search box would
  // reset on every re-render.
  {
    const fEl = host.querySelector('#upcoming-filter');
    if(fEl) fEl.value = sortVal;
    const tEl = host.querySelector('#upcoming-type');
    if(tEl) tEl.value = typeVal;
    const sEl = host.querySelector('#upcoming-search');
    if(sEl) sEl.value = origSearchVal;
  }
  // Attach handlers for export buttons and completion buttons
  document.getElementById("export-upcoming-csv")?.addEventListener("click", exportUpcomingCSV);
  document.getElementById("export-upcoming-pdf")?.addEventListener("click", exportUpcomingPDF);
  host.querySelectorAll('button[data-act="completeUpcoming"]').forEach(btn => {
    btn.onclick = () => {
      const category = btn.dataset.category;
      const colId   = btn.dataset.col;
      const due     = btn.dataset.due;
      const extra   = btn.dataset.extra || "";
      if(confirm("Please ensure all relevant paperwork is up to date before completing this action")){
        completeUpcomingAction(category, colId, due, extra);
      }
    };
  });
  // Re-render when filters change.  While the upcoming actions list does not
  // currently perform any client-side filtering based on these values, we
  // register change/input listeners to trigger a re-render in future.  This
  // ensures the UI responds consistently when the user interacts with the
  // filter controls.
  ['upcoming-filter','upcoming-type','upcoming-search'].forEach(id=>{
    const el = host.querySelector('#'+id);
    if(el){
      const evt = id==='upcoming-search' ? 'input' : 'change';
      el.addEventListener(evt, () => {
        // Persist search value when typing so it can be restored on re-render.
        if(id === 'upcoming-search'){
          ui.upcomingSearch = el.value;
          // Do not trigger a full re-render on every keystroke; the value is
          // stored in ui and will be applied the next time the tab renders.
          return;
        }
        // For sort/type changes, re-render the tab to apply the new selection.
        renderCurrentTab();
      });
    }
  });
}

// Mark an upcoming action as complete and move it out of the upcoming list.
function completeUpcomingAction(category, colleagueId, due, extra){
  if(!state.completedUpcoming.some(c=>c.category===category && c.colleagueId===colleagueId && c.due===due)){
    state.completedUpcoming.push({category, colleagueId, due, extra: extra||""});
    saveState();
    renderCurrentTab();
  }
}

// Gather all uncompleted upcoming actions into grouped structure for exporting
function gatherUpcoming(){
  const groups = {};
  // helper to add to group if not completed
  // Include managerId in upcoming items so the dashboard can filter by
  // responsible manager.  The managerId argument may be undefined when
  // not applicable (e.g. certain attendance logs).
  function addItem(category, colleagueId, colleagueName, due, extra, managerId){
    const rec = { category, colleagueId, colleagueName, due, extra, managerId };
    if(state.completedUpcoming.some(c=>c.category===category && c.colleagueId===colleagueId && c.due===due)) return;
    groups[category] = groups[category] || [];
    groups[category].push(rec);
  }
  // Absence
  state.absences.forEach(r=>{
    const e=(r.events||[])[0];
    if(!e || !e.nextActionDT) return;
    if(!deptPass(r.colleagueId)) return;
    // Pass through the managerId on the parent absence record for filtering
    addItem("Absence", r.colleagueId, colleagueName(r.colleagueId), e.nextActionDT, e.nextActionType||"", r.managerId);
  });
  // Flexible leave
  state.flexibleLeave.forEach(r=>{
    if(!r.contactDate) return;
    if(!deptPass(r.colleagueId)) return;
    addItem("Flexible leave", r.colleagueId, colleagueName(r.colleagueId), r.contactDate, "Contact Date", r.managerId);
  });
  // IHC
  state.ihc.forEach(r=>{
    const l=r.latest||{};
    const nd=l.nextDT;
    if(!nd) return;
    if(!deptPass(r.colleagueId)) return;
    addItem("IHC process", r.colleagueId, colleagueName(r.colleagueId), nd, "", r.managerId);
  });
  // Rehab
  state.rehab.forEach(r=>{
    const l=r.latest||{};
    const nd=l.nextDate;
    if(!nd) return;
    if(!deptPass(r.colleagueId)) return;
    const extra = l.week ? `Week ${l.week}` : "";
    addItem("Rehabilitation", r.colleagueId, colleagueName(r.colleagueId), nd, extra, r.managerId);
  });
  // Ill health
  state.illHealth.forEach(r=>{
    if(!r.endDate) return;
    if(!deptPass(r.colleagueId)) return;
    addItem("Ill health leave", r.colleagueId, colleagueName(r.colleagueId), r.endDate, "End date", r.managerId);
  });
  // Bereavement
  state.bereavement.forEach(r=>{
    if(!r.endDate) return;
    if(!deptPass(r.colleagueId)) return;
    addItem("Bereavement", r.colleagueId, colleagueName(r.colleagueId), r.endDate, "End date", r.managerId);
  });
  // Warnings (hearing date/time)
  (state.warnings || []).forEach(r=>{
    if(!r.hearingDate) return;
    if(!deptPass(r.colleagueId)) return;
    // Combine date and time for due string if time provided
    let dueStr = r.hearingDate;
    if(r.hearingTime) {
      dueStr = `${r.hearingDate}T${r.hearingTime}`;
    }
    addItem("Warnings", r.colleagueId, colleagueName(r.colleagueId), dueStr, r.action || "", r.managerId);
  });
  // Investigations (date/time)
  (state.investigations || []).forEach(r=>{
    if(!r.date) return;
    if(!deptPass(r.colleagueId)) return;
    let dueStr = r.date;
    if(r.time) dueStr = `${r.date}T${r.time}`;
    addItem("Investigations", r.colleagueId, colleagueName(r.colleagueId), dueStr, r.outcome || "", r.managerId);
  });
  return groups;
}

/*
 * Mapping of human-readable category names to the internal state array names.
 * This map is used when completing an action from any attendance or conduct tab. When
 * a record is completed, it will be removed from its source array and placed
 * into `state.completedLogs` along with the category type and a timestamp.
 */
const typeToStateKey = {
  "Part shift": "partShifts",
  "Medical reports": "medicalReports",
  "Restrictions": "restrictions",
  "Flexible leave": "flexibleLeave",
  "IHC process": "ihc",
  "Rehabilitation": "rehab",
  "Ill health leave": "illHealth",
  "Bereavement": "bereavement",
  "AWOL": "awol",
  "Me days": "meDays",
  "Late RTW": "lateRTW",
  "Investigations": "investigations",
  "Warnings": "warnings",
  "D&A": "daTests",
  "Positive ROC": "positiveRocs"
};

// Complete a record from a given category and remove it from the active state.
// The removed record is stored in state.completedLogs with a timestamp so it
// appears in the Completed actions tab under its original category.  This
// function will save the state and re-render the current tab after completion.
function completeRecord(type, id){
  const key = typeToStateKey[type];
  if(!key) return;
  const list = state[key] || [];
  const index = list.findIndex(item => item.id === id);
  if(index >= 0){
    const rec = list[index];
    // remove the record from its list
    list.splice(index, 1);
    // append to completed logs
    state.completedLogs = state.completedLogs || [];
    state.completedLogs.unshift({ type: type, record: rec, completedAt: new Date().toISOString() });
    saveState();
    renderCurrentTab();
  }
}

// Generate a short summary string for a completed log based on its type and
// record content.  This is used in the Completed actions tab to display
// context about the log without having to open its full history.
function recordSummary(type, rec){
  try{
    switch(type){
      case "Part shift":
        return `${toUKDate(rec.dateAbsence||"")} – ${(rec.details||"")}`.trim();
      case "Medical reports":
        return `${toUKDate(rec.dateStart||"")} – ${(rec.details||"")}`.trim();
      case "Restrictions":
        return `${(rec.restriction||"")} – ${toUKDate(rec.startDate||"")}`.trim();
      case "Flexible leave":
        return `${toUKDate(rec.date||"")} – ${(rec.reason||"")}`.trim();
      case "IHC process":
        return rec.latest && rec.latest.stage ? `Stage: ${rec.latest.stage}` : "";
      case "Rehabilitation":
        return rec.latest && rec.latest.week ? `Week ${rec.latest.week}` : "";
      case "Ill health leave":
        return `${toUKDate(rec.startDate||"")} – ${toUKDate(rec.endDate||"")}`.trim();
      case "Bereavement":
        return `${toUKDate(rec.date||"")} – ${(rec.relationship||"")}`.trim();
      case "AWOL":
        return `${toUKDate(rec.dateAwol||"")} – ${(rec.details||"")}`.trim();
      case "Me days":
        return `${toUKDate(rec.date||"")} – ${(rec.reason||"")}`.trim();
      case "Late RTW":
        return `${toUKDate(rec.dateExpected||"")} – ${toUKDate(rec.dateReturned||"")}`.trim();
      case "Investigations":
        return `${toUKDate(rec.date||"")} – ${(rec.outcome||"")}`.trim();
      case "Warnings":
        return `${(rec.action||"")} – ${toUKDate(rec.hearingDate||"")}`.trim();
      case "D&A":
        return `${toUKDate(rec.dateTest||"")} – ${(rec.testResult||"")}`.trim();
      case "Positive ROC":
        return `${toUKDate(rec.dateIssued||"")} – ${(rec.reason||"")}`.trim();
      default:
        return "";
    }
  }catch(e){
    return "";
  }
}

/*
 * Create a filter bar for tables with optional type selection.  This helper returns
 * a string of HTML containing a filter dropdown (new-to-old, old-to-new, today's date),
 * an optional type/category dropdown, and a search box.  Each filter bar is given
 * a unique prefix so its elements can be referenced later.  The caller is responsible
 * for hooking up event listeners to trigger re-rendering when the user changes the
 * selection or enters a search term.  The type dropdown lists all keys from
 * typeToStateKey to allow filtering by category in the upcoming/completed actions tabs.
 */
function filterUI(prefix, showType){
  let typeSelect = "";
  if(showType){
    const cats = Object.keys(typeToStateKey || {});
    typeSelect = '<select id="'+prefix+'-type"><option value="">All categories</option>'+cats.map(c=>'<option value="'+escapeHtml(c)+'">'+escapeHtml(c)+'</option>').join("")+"</select>";
  }
  // Each filter bar is positioned relative with a high z-index so it sits above
  // subsequent scrollable tables.  The search input is explicitly type="text"
  // with padding to improve clickability.  Without these adjustments the
  // Completed Actions filter search box can become inaccessible when the table
  // below overlaps it.
  return `
    <div style="margin:10px 0; display:flex; gap:10px; flex-wrap:wrap; position:relative; z-index:2; width:100%">
      <select id="${prefix}-filter">
        <option value="new">New to Old</option>
        <option value="old">Old to New</option>
        <option value="today">Today's Date</option>
      </select>
      ${typeSelect}
      <input type="text" id="${prefix}-search" placeholder="Search..." style="flex:1; min-width:200px; padding:4px 8px; box-sizing:border-box;">
    </div>
  `;
}

// Generic helper to apply sort, search, and date filters to tables.
// `host` is the container that holds the card with a table.  `prefix` corresponds to the
// ID prefix used for the filter and search controls (e.g. 'illhealth' for ill health leave).
// `dateIdx` is the zero-based index of the column containing a date used for sorting
// and filtering; pass null if no date column exists.  The function hides rows that
// do not match the search string, filters to today's date when the 'today' option
// is selected, and sorts visible rows by date for 'new' or 'old'.
function applyTableFilters(host, prefix, dateIdx){
  const filterEl = document.getElementById(prefix+'-filter');
  const searchEl = document.getElementById(prefix+'-search');
  const sortVal = filterEl ? filterEl.value : 'new';
  const searchVal = searchEl ? searchEl.value.trim().toLowerCase() : '';
  const tbody = host.querySelector('tbody');
  if(!tbody) return;
  const rows = Array.from(tbody.querySelectorAll('tr'));
  const visible = [];
  const todayStr = new Date().toISOString().slice(0,10);
  rows.forEach(row=>{
    row.style.display = '';
    let show = true;
    if(searchVal){
      const txt = row.innerText.toLowerCase();
      if(!txt.includes(searchVal)){
        show = false;
      }
    }
    if(show && sortVal === 'today' && dateIdx != null){
      let dateCellText = '';
      const cell = row.children[dateIdx];
      if(cell) dateCellText = cell.innerText.trim();
      let iso = '';
      if(dateCellText){
        if(dateCellText.includes('/')){
          const parts = dateCellText.split('/');
          if(parts.length === 3){
            const d = parts[0].padStart(2,'0');
            const m = parts[1].padStart(2,'0');
            const y = parts[2];
            iso = `${y}-${m}-${d}`;
          }
        } else {
          iso = dateCellText;
        }
      }
      if(iso !== todayStr){
        show = false;
      }
    }
    if(!show){
      row.style.display = 'none';
    } else {
      visible.push(row);
    }
  });
  if((sortVal === 'new' || sortVal === 'old') && dateIdx != null){
    visible.sort((a,b)=>{
      function parseDate(row){
        const cell = row.children[dateIdx];
        if(!cell) return new Date(0);
        let ds = cell.innerText.trim();
        if(!ds) return new Date(0);
        if(ds.includes('/')){
          const p = ds.split('/');
          if(p.length === 3){
            const d = p[0].padStart(2,'0');
            const m = p[1].padStart(2,'0');
            const y = p[2];
            ds = `${y}-${m}-${d}`;
          }
        }
        return new Date(ds);
      }
      const da = parseDate(a);
      const db = parseDate(b);
      return sortVal === 'new' ? db - da : da - db;
    });
    visible.forEach(row => tbody.appendChild(row));
  }
}

// Export upcoming actions to CSV
function exportUpcomingCSV(){
  const groups = gatherUpcoming();
  const rows = [];
  // header
  rows.push(["Category","Colleague","Details","Due date/time"]);
  Object.keys(groups).forEach(cat => {
    const items = groups[cat];
    items.sort((a,b)=> new Date(a.due) - new Date(b.due));
    items.forEach(item=>{
      let displayDT="";
      if(item.due){
        const str=String(item.due);
        if(str.includes("T")){
          const parts=str.split("T");
          const d=parts[0];
          const t=parts[1]||"";
          displayDT = `${toUKDate(d)} ${t}`.trim();
        }else{
          displayDT = toUKDate(item.due);
        }
      }
      rows.push([
        cat,
        `${item.colleagueName} (${item.colleagueId})`,
        item.extra||"",
        displayDT
      ]);
    });
  });
  downloadCSV('upcoming_actions.csv', rows);
}

// Export upcoming actions to a printable PDF (opens print dialog)
function exportUpcomingPDF(){
  const groups = gatherUpcoming();
  const lines = [];
  Object.keys(groups).forEach(cat => {
    const items = groups[cat];
    items.sort((a,b)=> new Date(a.due) - new Date(b.due));
    lines.push(cat);
    items.forEach(item=>{
      let displayDT="";
      if(item.due){
        const str=String(item.due);
        if(str.includes("T")){
          const parts=str.split("T");
          const d=parts[0];
          const t=parts[1]||"";
          displayDT = `${toUKDate(d)} ${t}`.trim();
        }else{
          displayDT = toUKDate(item.due);
        }
      }
      const details = item.extra||"";
      lines.push(`- ${item.colleagueName} (${item.colleagueId})${details?` – ${details}`:""}${displayDT?` – ${displayDT}`:""}`);
    });
    lines.push("");
  });
  if(lines.length===0){
    lines.push("No upcoming actions – nice work 👍");
  }
  const w = window.open('', '_blank');
  const title = 'Upcoming actions';
  const escapedTitle = escapeHtml(title);
  const escapedText = escapeHtml(lines.join('\n')).replace(/\n/g, '<br>');
  w.document.write(`<!doctype html><html><head><title>${escapedTitle}</title></head><body>`);
  w.document.write(`<h2>${escapedTitle}</h2><p style="white-space:pre-wrap;font-family:inherit;">${escapedText}</p>`);
  w.document.write('</body></html>');
  w.document.close();
  setTimeout(() => { w.print(); w.close(); }, 100);
}

/* ---- Completed Actions tab ---- */
function renderCompleted(host){
  // Determine filter selections (if filters exist from previous render)
  // Before reading values for filtering, capture the raw search input so we can
  // restore it on re-render.  Without preserving the original value the input
  // would reset to blank every time the tab re-renders (e.g. on each keypress).
  const prevFilterEl = document.getElementById("completed-filter");
  const prevTypeEl   = document.getElementById("completed-type");
  const prevSearchEl = document.getElementById("completed-search");
  const sortVal = prevFilterEl ? prevFilterEl.value : "new";
  const typeVal = prevTypeEl ? prevTypeEl.value : "";
  const origSearchVal = prevSearchEl ? prevSearchEl.value : "";
  const searchVal = origSearchVal.trim().toLowerCase();

  // Build Completed Absences section
  const absRecords = (state.completedAbsences || []).filter(rec => deptPass(rec.colleagueId));
  // Apply search filter for completed absences
  const filteredAbs = absRecords.filter(rec => {
    if(!searchVal) return true;
    const name = colleagueName(rec.colleagueId).toLowerCase();
    return name.includes(searchVal);
  });
  // Sort completed absences by completedAt date (descending by default)
  filteredAbs.sort((a,b)=>{
    const da = new Date(a.completedAt || 0);
    const db = new Date(b.completedAt || 0);
    if(sortVal === "old") return da - db;
    if(sortVal === "today"){
      // no sorting in today filter; filter itself happens later
      return da - db;
    }
    // default "new"
    return db - da;
  });
  // Apply today's date filter
  const absList = (sortVal === "today") ? filteredAbs.filter(rec => {
    if(!rec.completedAt) return false;
    const d = rec.completedAt.split('T')[0];
    return d === (new Date().toISOString().split('T')[0]);
  }) : filteredAbs;
  const absRows = absList.map(rec => {
    const ev = (rec.events || [])[rec.events.length - 1] || {};
    const originalDate = ev.dateStart ? toUKDate(ev.dateStart) : "";
    const originalReason = ev.reason || "";
    const sanction = rec.sanction || "";
    const returnDate = rec.dateReturn ? toUKDate(rec.dateReturn) : "";
    const returnTime = toUKTime(rec.timeReturn) || "";
    const completed = rec.completedAt ? toUKDateTime(rec.completedAt) : "";
    return [
      `<b class="col-link" data-col-id="${rec.colleagueId}">${escapeHtml(colleagueName(rec.colleagueId))}</b><div class="muted">${escapeHtml(rec.colleagueId)}</div>`,
      escapeHtml(originalDate),
      escapeHtml(originalReason),
      escapeHtml(sanction),
      escapeHtml(returnDate + (returnTime ? ' ' + returnTime : '')),
      escapeHtml(completed),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small" data-ca-hist="${escapeHtml(rec.id)}">History</button>
        <button class="btn small danger" data-ca-del="${escapeHtml(rec.id)}">Delete</button>
      </div>`
    ];
  });
  // Build Completed Absences section with a centred green heading similar to upcoming actions
  const absHtml = `
    <div style="margin:14px 0;padding:12px;border:1px solid var(--line);border-radius:14px;background:#fff">
      <div class="group-heading">Completed Absences</div>
      <div style="display:flex;justify-content:flex-end;align-items:center;margin-top:4px;margin-bottom:6px;">
        <div class="muted">${absRows.length} item(s)</div>
      </div>
      <table class="absences-table">
        <thead><tr><th>Colleague</th><th>Absence start</th><th>Reason</th><th>Sanction imposed</th><th>Return</th><th>Logged</th><th>Actions</th></tr></thead>
        <tbody>
          ${absRows.length ? absRows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('') : `<tr><td colspan="7" class="muted">No completed absences.</td></tr>`}
        </tbody>
      </table>
    </div>
  `;
  // Build Completed logs section grouped by type
  const groups = {};
  (state.completedLogs || []).forEach(item => {
    const rec = item.record || {};
    if(!deptPass(rec.colleagueId)) return;
    // Apply type filter
    if(typeVal && item.type !== typeVal) return;
    // Apply search filter across colleague and manager names
    if(searchVal){
      const name = colleagueName(rec.colleagueId).toLowerCase();
      const mgrName = managerName(rec.managerId || "").toLowerCase();
      if(!(name.includes(searchVal) || mgrName.includes(searchVal))) return;
    }
    if(sortVal === "today"){
      if(!item.completedAt) return;
      const d = item.completedAt.split('T')[0];
      if(d !== (new Date().toISOString().split('T')[0])) return;
    }
    groups[item.type] = groups[item.type] || [];
    groups[item.type].push(item);
  });
  let logsHtml = "";
  Object.keys(groups).forEach(cat => {
    const items = groups[cat];
    // Sort items by completedAt
    items.sort((a,b)=>{
      const da = new Date(a.completedAt || 0);
      const db = new Date(b.completedAt || 0);
      if(sortVal === "old") return da - db;
      // default new and today also sort newest first
      return db - da;
    });
    const rows = items.map(item => {
      const rec = item.record || {};
      const dateStr = item.completedAt ? toUKDateTime(item.completedAt) : "";
      const summary = recordSummary(cat, rec) || "";
      return `
        <tr>
          <td><b class="col-link" data-col-id="${escapeHtml(rec.colleagueId)}">${escapeHtml(colleagueName(rec.colleagueId))}</b><div class="muted">${escapeHtml(rec.colleagueId)}</div></td>
          <td>${escapeHtml(summary)}</td>
          <td>${escapeHtml(dateStr)}</td>
          <td style="white-space:nowrap">
            <button class="btn small" data-cl-hist="${escapeHtml(cat + '__' + rec.id)}">History</button>
            <button class="btn small danger" data-cl-del="${escapeHtml(cat + '__' + rec.id)}">Delete</button>
          </td>
        </tr>
      `;
    }).join("");
    logsHtml += `
      <div style="margin:14px 0;padding:12px;border:1px solid var(--line);border-radius:14px;background:#fff">
        <div class="group-heading">${escapeHtml(cat)}</div>
        <div style="display:flex;justify-content:flex-end;align-items:center;margin-top:4px;margin-bottom:6px;">
          <div class="muted">${items.length} item(s)</div>
        </div>
        <table class="completed-logs-table">
          <thead><tr><th>Colleague</th><th>Details</th><th>Completed</th><th>Actions</th></tr></thead>
          <tbody>
            ${rows || `<tr><td colspan="4" class="muted">No completed actions in this category.</td></tr>`}
          </tbody>
        </table>
      </div>
    `;
  });
  // Combine filter bar, completed absences and logs.  The filter UI must be passed
  // as the `filtersHTML` parameter to renderShell (5th argument) so that it
  // appears above the scrollable table area and remains interactive.  Passing
  // the filter UI in the `tableHTML` slot would put it inside the scroll
  // container and prevent the search box from receiving focus.
  const filters = filterUI('completed', true);
  renderShell(host, "Completed actions", "Completed absences and actions.", "", filters, absHtml + logsHtml);
  // After rendering the new filter bar, restore the previously selected filter
  // values so the dropdowns and search box reflect the user’s current input.
  {
    const fEl = host.querySelector('#completed-filter');
    if(fEl) fEl.value = sortVal;
    const tEl = host.querySelector('#completed-type');
    if(tEl) tEl.value = typeVal;
    const sEl = host.querySelector('#completed-search');
    if(sEl) sEl.value = origSearchVal;
  }
  // Attach event handlers
  // Completed absences: history and delete
  host.querySelectorAll('button[data-ca-hist]').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.dataset.caHist;
      const rec = (state.completedAbsences || []).find(x => x.id === id);
      if(rec) openCompletedAbsenceHistory(rec);
    });
  });
  host.querySelectorAll('button[data-ca-del]').forEach(btn => {
    btn.addEventListener('click', () => {
      deleteCompletedAbsence(btn.dataset.caDel);
    });
  });
  // Completed logs: history and delete
  host.querySelectorAll('button[data-cl-hist]').forEach(btn => {
    btn.addEventListener('click', () => {
      const parts = btn.dataset.clHist.split('__');
      const t = parts[0];
      const id = parts.slice(1).join('__');
      openCompletedLogHistory(t, id);
    });
  });
  host.querySelectorAll('button[data-cl-del]').forEach(btn => {
    btn.addEventListener('click', () => {
      const parts = btn.dataset.clDel.split('__');
      const t = parts[0];
      const id = parts.slice(1).join('__');
      deleteCompletedLog(t, id);
    });
  });
  // Filter controls: re-render on sort or type change, but do in-place filtering on search
  // Sort/type changes re-render the tab to rebuild sections using the selected criteria
  ['completed-filter','completed-type'].forEach(id=>{
    const el = host.querySelector('#'+id);
    if(el){
      el.addEventListener('change', ()=> renderCurrentTab());
    }
  });
  // Search input filters rows across all tables in-place without re-rendering
  {
    const sEl = host.querySelector('#completed-search');
    if(sEl){
      sEl.addEventListener('input', () => {
        const val = sEl.value.trim().toLowerCase();
        host.querySelectorAll('tbody tr').forEach(row => {
          const txt = row.innerText.toLowerCase();
          row.style.display = val ? (txt.includes(val) ? '' : 'none') : '';
        });
      });
    }
  }
}

/* ---- Dashboard tab ---- */
// Compute data used for the enhanced dashboard.  This helper collates metrics,
// trending figures, upcoming actions, activity composition, department
// snapshots and risk flags based on the current department filter (ui.dept).
function computeDashboardData(){
  const dept = ui.dept || "ALL";
  const colleagues = state.colleagues.filter(c => dept === "ALL" || c.department === dept);
  const total = colleagues.length;
  const currentlyAbsent = colleagues.filter(c => isCurrentlyAbsent(c.id));
  const absencePercent = total ? Math.round(currentlyAbsent.length / total * 100) : 0;
  const withWarnings = colleagues.filter(c => hasWarnings(c.id));
  const withRestrictions = colleagues.filter(c => hasRestrictions(c.id));
  // Count open investigations (no outcome recorded)
  const investigationsOpen = (state.investigations || []).filter(r => (dept === "ALL" || deptPass(r.colleagueId)) && (!r.outcome || !r.outcome.trim())).length;
  // Helper to format dates for comparisons
  const isoDate = (d) => {
    const ds = d.toISOString().split("T")[0];
    return ds;
  };
  const now = new Date();
  // Determine the reporting window based on the dashboard range (7, 28 or 90 days).  Parse the numeric portion safely.
  const rangeDays = parseInt(ui.dashRange || "28") || 28;
  const startRange = new Date(now.getTime() - rangeDays * 24 * 3600 * 1000);
  const startPrev = new Date(now.getTime() - 2 * rangeDays * 24 * 3600 * 1000);
  const isoRange = isoDate(startRange);
  const isoPrev = isoDate(startPrev);
  // Count new records in a time window for trending.  dateField names vary per array.
  function countRecent(list, dateField){
    let nowCount = 0, prevCount = 0;
    (list || []).forEach(r => {
      // Respect the department filter when the record has a colleagueId.  Records without
      // colleagueId (e.g. DA tests) are counted globally when dept === "ALL".
      if(r.colleagueId && !(dept === "ALL" || deptPass(r.colleagueId))) return;
      const dateStr = r[dateField];
      if(!dateStr) return;
      const part = String(dateStr).split("T")[0];
      if(part >= isoRange) nowCount++;
      else if(part >= isoPrev && part < isoRange) prevCount++;
    });
    return { now: nowCount, prev: prevCount };
  }
  const absCounts = countRecent(state.absences, "createdAt");
  const partCounts = countRecent(state.partShifts, "dateAbsence");
  const medCounts = countRecent(state.medicalReports, "dateStart");
  const restrictCounts = countRecent(state.restrictions, "startDate");
  const warnCounts = countRecent(state.warnings, "createdAt");
  const invCounts = countRecent(state.investigations, "date");
  const trending = {
    absences: absCounts.now - absCounts.prev,
    partShifts: partCounts.now - partCounts.prev,
    medicalReports: medCounts.now - medCounts.prev,
    restrictions: restrictCounts.now - restrictCounts.prev,
    warnings: warnCounts.now - warnCounts.prev,
    investigations: invCounts.now - invCounts.prev
  };
  // Collect all upcoming actions without filtering by a time window.  The calling
  // code will filter based on the chosen dashboard focus (all, overdue, next7).
  const upcoming = gatherUpcoming();
  const allUpcoming = [];
  Object.keys(upcoming).forEach(cat => {
    upcoming[cat].forEach(item => {
      allUpcoming.push({
        category: cat,
        colleagueName: item.colleagueName,
        colleagueId: item.colleagueId,
        due: item.due,
        extra: item.extra
      });
    });
  });
  // If a manager filter is active (selected manager id), remove items not managed by that manager.
  const mgrFilter = ui.managerFilter || "ALL";
  if(mgrFilter && mgrFilter !== "ALL"){
    for(let i = allUpcoming.length - 1; i >= 0; i--){
      const it = allUpcoming[i];
      if(!it.managerId || it.managerId !== mgrFilter){
        allUpcoming.splice(i, 1);
      }
    }
  }
  allUpcoming.sort((a,b) => {
    const dA = new Date(a.due);
    const dB = new Date(b.due);
    return dA - dB;
  });
  // Activity composition in the current range (dashRange).  Use startRange as
  // the cutoff.  Count events after startRange.
  function countInRange(list, dateField){
    let cnt = 0;
    (list || []).forEach(r => {
      if(r.colleagueId && !(dept === "ALL" || deptPass(r.colleagueId))) return;
      const dt = r[dateField];
      if(!dt) return;
      const part = String(dt).split("T")[0];
      if(part >= isoRange) cnt++;
    });
    return cnt;
  }
  const actCounts = {
    absences: countInRange(state.absences, "createdAt"),
    partShifts: countInRange(state.partShifts, "dateAbsence"),
    medicalReports: countInRange(state.medicalReports, "dateStart"),
    restrictions: countInRange(state.restrictions, "startDate"),
    warnings: countInRange(state.warnings, "createdAt"),
    investigations: countInRange(state.investigations, "date"),
    // Include Me Days in the activity counts.  Use the recorded date field when
    // present.  If there are no meDays records this will safely return 0.
    meDays: countInRange(state.meDays, "date")
  };
  const totalAct = Object.values(actCounts).reduce((a,b) => a + b, 0) || 1;
  const actPercents = {};
  Object.keys(actCounts).forEach(key => {
    actPercents[key] = Math.round(actCounts[key] / totalAct * 100);
  });
  // Department snapshot.  Only include departments that match the current filter.
  const deptStats = {};
  state.colleagues.forEach(c => {
    if(!(dept === "ALL" || c.department === dept)) return;
    const d = c.department || "Unknown";
    if(!deptStats[d]) {
      deptStats[d] = { headcount:0, absent:0, warnings:0, restrictions:0, investigations:0, upcoming:0 };
    }
    deptStats[d].headcount++;
    if(isCurrentlyAbsent(c.id)) deptStats[d].absent++;
    if(hasWarnings(c.id)) deptStats[d].warnings++;
    if(hasRestrictions(c.id)) deptStats[d].restrictions++;
  });
  // Open investigations per department
  (state.investigations || []).forEach(r => {
    if(!(dept === "ALL" || deptPass(r.colleagueId))) return;
    const col = state.colleagues.find(x => x.id === r.colleagueId);
    const d = col ? col.department : "Unknown";
    if(!deptStats[d]) return;
    if(!r.outcome || !r.outcome.trim()) deptStats[d].investigations++;
  });
  // Upcoming actions (next 7 days) per department
  const sevenDays = new Date(now.getTime() + 7*24*3600*1000);
  Object.keys(upcoming).forEach(cat => {
    upcoming[cat].forEach(item => {
      const dueDate = new Date(item.due);
      if(String(dueDate) === "Invalid Date") return;
      if(dueDate <= sevenDays){
        const col = state.colleagues.find(x => x.id === item.colleagueId);
        const d = col ? col.department : "Unknown";
        if(deptStats[d]) deptStats[d].upcoming++;
      }
    });
  });
  // Risk radar: identify colleagues with multiple risk factors using configurable thresholds.  Pull the
  // thresholds from state.config; fallback to defaults if missing.  Track colleagues
  // with combinations of risk factors such as frequent absences, multiple warnings and
  // overdue follow‑ups.
  const cfg = state.config || {};
  const absenceThresh = cfg.absenceThreshold || 3;
  const absenceWindow = cfg.absenceDaysWindow || 60;
  const warningThresh = cfg.warningThreshold || 2;
  const warningWindow = cfg.warningDaysWindow || 365;
  const flagged = [];
  colleagues.forEach(c => {
    const tags = [];
    // Basic combos
    if(isCurrentlyAbsent(c.id) && hasWarnings(c.id)) tags.push("Absent + Warnings");
    if(isCurrentlyAbsent(c.id) && hasRestrictions(c.id)) tags.push("Absent + Restrictions");
    // Frequent absences in configured window
    const startAbs = new Date(now.getTime() - absenceWindow * 24 * 3600 * 1000);
    const isoAbs = isoDate(startAbs);
    const absCount = (state.absences || []).filter(r => r.colleagueId === c.id && r.createdAt && String(r.createdAt).split("T")[0] >= isoAbs).length;
    if(absCount >= absenceThresh) tags.push(`Frequent absences (${absCount})`);
    // Multiple warnings in configured window
    const startWarn = new Date(now.getTime() - warningWindow * 24 * 3600 * 1000);
    const isoWarn = isoDate(startWarn);
    const warnCount = (state.warnings || []).filter(r => r.colleagueId === c.id && r.createdAt && String(r.createdAt).split("T")[0] >= isoWarn).length;
    if(warnCount >= warningThresh) tags.push(`Multiple warnings (${warnCount})`);
    // Restrictions and open investigation
    const openInv = (state.investigations || []).some(r => r.colleagueId === c.id && (!r.outcome || !r.outcome.trim()));
    if(hasRestrictions(c.id) && openInv) tags.push("Restrictions + Investigation");
    // Overdue follow‑ups: check upcoming list for this colleague and identify overdue items
    const hasOverdue = allUpcoming.some(item => item.colleagueId === c.id && new Date(item.due) <= now);
    if(hasOverdue) tags.push("Overdue follow-ups");
    if(tags.length){
      flagged.push({ id: c.id, name: c.name, department: c.department, tags: tags });
    }
  });
  flagged.sort((a,b) => b.tags.length - a.tags.length);

  // Prepare counts for the summary chart.  These counts aggregate all logs for
  // each category regardless of the selected date range.  When a department
  // filter is active only records belonging to the selected department are
  // counted.  AWOL and Late RTW records do not have a date so they are
  // counted unconditionally.
  function countTotal(list){
    let cnt = 0;
    (list || []).forEach(r => {
      if(r.colleagueId && !(dept === "ALL" || deptPass(r.colleagueId))) return;
      cnt++;
    });
    return cnt;
  }
  const chartCounts = {
    absences: countTotal(state.absences),
    partShifts: countTotal(state.partShifts),
    meDays: countTotal(state.meDays),
    awol: countTotal(state.awol),
    lateRTW: countTotal(state.lateRTW)
  };
  // Compute items that need special attention.  These lists are
  // returned to the dashboard for rendering actionable insights.
  // Overdue restrictions: review date before today and not yet reviewed or expired.
  const nowMs = now.getTime();
  const overdueRestrictions = (state.restrictions || []).filter(r => {
    if(r.colleagueId && !(dept === "ALL" || deptPass(r.colleagueId))) return false;
    const review = r.reviewDate;
    if(!review) return false;
    const reviewDate = new Date(review);
    if(isNaN(reviewDate)) return false;
    // Treat review state 'Reviewed' or 'Expired' as not requiring attention
    if(r.reviewState && (r.reviewState === 'Reviewed' || r.reviewState === 'Expired')) return false;
    return reviewDate.getTime() < nowMs;
  }).map(r => {
    const colName = colleagueName(r.colleagueId) || r.colleagueId;
    return { type:'Overdue restriction', colleagueId: r.colleagueId, text: `${colName}: review overdue since ${toUKDate(r.reviewDate)}` };
  });
  // Open investigations: outcome empty or 'Ongoing'
  const openInvestigations = (state.investigations || []).filter(r => {
    if(r.colleagueId && !(dept === "ALL" || deptPass(r.colleagueId))) return false;
    const outcome = (r.outcome || '').trim();
    return !outcome || outcome.toLowerCase() === 'ongoing' || outcome.toLowerCase() === 'to be conducted';
  }).map(r => {
    const colName = colleagueName(r.colleagueId) || r.colleagueId;
    return { type:'Open investigation', colleagueId: r.colleagueId, text: `${colName}: open investigation ${escapeHtml(r.caseRef || '')}` };
  });
  // Warnings nearing expiry: older than 6 months (180 days).  Exclude those with final warning or dismissal as they may not expire.
  const sixMonthsMs = 180 * 24 * 3600 * 1000;
  const warningsExpiring = (state.warnings || []).filter(w => {
    if(w.colleagueId && !(dept === "ALL" || deptPass(w.colleagueId))) return false;
    const created = w.createdAt ? new Date(w.createdAt) : null;
    if(!created || isNaN(created)) return false;
    const age = nowMs - created.getTime();
    return age >= sixMonthsMs;
  }).map(w => {
    const colName = colleagueName(w.colleagueId) || w.colleagueId;
    return { type:'Warning expiry', colleagueId: w.colleagueId, text: `${colName}: warning issued on ${toUKDate(w.createdAt)} nearing expiry` };
  });
  // Absence spikes: colleagues with frequent absences in the last 4 weeks relative to the past 26 weeks.  Thresholds configurable via state.config.
  const absSpikeThreshold = cfg.absenceSpikeThreshold || 3;
  const absSpikeRatio = cfg.absenceSpikeRatio || 0.5;
  const fourWeeksMs = 28 * 24 * 3600 * 1000;
  const twentySixWeeksMs = 182 * 24 * 3600 * 1000;
  const absSpikes = [];
  colleagues.forEach(c => {
    const allAbs = (state.absences || []).filter(a => a.colleagueId === c.id);
    // Count events within last 4 weeks and last 26 weeks by checking the createdAt (record) date, not the event date
    let recent4 = 0, recent26 = 0;
    allAbs.forEach(r => {
      const dt = r.createdAt ? new Date(r.createdAt) : null;
      if(!dt || isNaN(dt)) return;
      const diff = nowMs - dt.getTime();
      if(diff <= fourWeeksMs) recent4++;
      if(diff <= twentySixWeeksMs) recent26++;
    });
    if(recent4 >= absSpikeThreshold && recent26 > 0 && (recent4 / recent26) >= absSpikeRatio){
      absSpikes.push({ type:'Absence spike', colleagueId: c.id, text: `${c.name || c.id}: ${recent4} absences in last 4 weeks` });
    }
  });

  return {
    total: total,
    absent: currentlyAbsent.length,
    absencePercent: absencePercent,
    warnings: withWarnings.length,
    restrictions: withRestrictions.length,
    investigations: investigationsOpen,
    trending: trending,
    allUpcoming: allUpcoming,
    actCounts: actCounts,
    actPercents: actPercents,
    deptStats: deptStats,
    flagged: flagged,
    chartCounts: chartCounts
    ,attention: {
      overdueRestrictions: overdueRestrictions,
      openInvestigations: openInvestigations,
      warningsExpiring: warningsExpiring,
      absenceSpikes: absSpikes
    }
  };
}

/* ---- Dashboard tab ---- */
function renderDashboard(host){
  const data = computeDashboardData();
  // Determine dashboard controls (range and focus) from UI state
  const rangeOptions = ["7d","28d","90d"];
  const rangeButtons = rangeOptions.map(r => `<button class="${r===ui.dashRange?'active':''}" data-range="${r}">${escapeHtml(r)}</button>`).join("");
  const rangeHTML = `<div class="range-toggle">${rangeButtons}</div>`;
  const focusOptions = [
    { id: 'all', label: 'All' },
    { id: 'overdue', label: 'Overdue' },
    { id: 'next7', label: 'Next 7 days' },
    { id: 'highrisk', label: 'High risk' }
  ];
  const focusButtons = focusOptions.map(opt => `<button class="${opt.id===ui.dashFocus?'active':''}" data-focus="${opt.id}">${escapeHtml(opt.label)}</button>`).join("");
  const focusHTML = `<div class="focus-toggle">${focusButtons}</div>`;
  // Build the manager filter dropdown.  This dropdown lists all managers plus an "All" option.
  const mgrOpts = state.managers.map(m => {
    const sel = (ui.managerFilter === m.id) ? 'selected' : '';
    return `<option value="${escapeHtml(m.id)}" ${sel}>${escapeHtml(m.name)}</option>`;
  });
  // Prepend the All option.  When ui.managerFilter is undefined or "ALL" this option appears selected.
  const allSel = (!ui.managerFilter || ui.managerFilter === 'ALL') ? 'selected' : '';
  mgrOpts.unshift(`<option value="ALL" ${allSel}>All managers</option>`);
  const managerHTML = `<div class="manager-filter"><label>Manager:</label><select id="dash-manager">${mgrOpts.join('')}</select></div>`;
  const controlsHTML = `<div class="dashboard-controls">${rangeHTML}${focusHTML}${managerHTML}</div>`;

  // Define SVG icons for each metric.  These are simple inline shapes using currentColor so they inherit
  // the colour defined in CSS (via kpi-card svg style).
  const icons = {
    colleagues: `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><circle cx="8" cy="7" r="3"/><circle cx="16" cy="7" r="3"/><path d="M2 21v-2c0-2.2 1.8-4 4-4h12c2.2 0 4 1.8 4 4v2H2z"/></svg>`,
    absent: `<svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><circle cx="12" cy="7" r="4"/><path d="M6 22v-2c0-2.2 1.8-4 4-4h4c2.2 0 4 1.8 4 4v2H6z"/><line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2"/></svg>`,
    percent: `<svg viewBox="0 0 24 24" aria-hidden="true"><line x1="4" y1="20" x2="20" y2="4" stroke="currentColor" stroke-width="2"/><circle cx="7" cy="17" r="2" fill="currentColor"/><circle cx="17" cy="7" r="2" fill="currentColor"/></svg>`,
    warnings: `<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2L2 22h20L12 2z" fill="currentColor"/><line x1="12" y1="8" x2="12" y2="14" stroke="#fff" stroke-width="2"/><circle cx="12" cy="17" r="1" fill="#fff"/></svg>`,
    restrictions: `<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="5" y="11" width="14" height="9" rx="2" fill="currentColor"/><path d="M8 11V8a4 4 0 118 0v3" stroke="#fff" stroke-width="2" fill="none"/><circle cx="12" cy="16" r="1" fill="#fff"/></svg>`,
    investigations: `<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="11" cy="11" r="5" stroke="currentColor" stroke-width="2" fill="none"/><line x1="16" y1="16" x2="21" y2="21" stroke="currentColor" stroke-width="2"/></svg>`,
    partshifts: `<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="2" fill="none"/><line x1="12" y1="12" x2="12" y2="7" stroke="currentColor" stroke-width="2"/><line x1="12" y1="12" x2="16" y2="12" stroke="currentColor" stroke-width="2"/></svg>`,
    medical: `<svg viewBox="0 0 24 24" aria-hidden="true"><rect x="6" y="4" width="12" height="16" rx="2" fill="currentColor"/><line x1="9" y1="8" x2="15" y2="8" stroke="#fff" stroke-width="2"/><line x1="9" y1="12" x2="15" y2="12" stroke="#fff" stroke-width="2"/><line x1="9" y1="16" x2="13" y2="16" stroke="#fff" stroke-width="2"/></svg>`
  };

  // Compose the list of KPI metrics with icons and target tabs.  The targetTab property tells the
  // dashboard which tab should open when the card is clicked.  When no tab is specified,
  // the card is non-interactive.
  const metrics = [
    { label: "Colleagues", number: data.total, trendKey: null, icon: icons.colleagues, targetTab: "colleagues" },
    { label: "Currently absent", number: data.absent, trendKey: "absences", icon: icons.absent, targetTab: "absence" },
    { label: "Absence %", number: data.absencePercent + "%", trendKey: null, icon: icons.percent, targetTab: "absence" },
    { label: "Warnings", number: data.warnings, trendKey: "warnings", icon: icons.warnings, targetTab: "warnings" },
    { label: "Restrictions", number: data.restrictions, trendKey: "restrictions", icon: icons.restrictions, targetTab: "restrictions" },
    { label: "Investigations", number: data.investigations, trendKey: "investigations", icon: icons.investigations, targetTab: "investigations" },
    { label: "Part shifts", number: data.actCounts.partShifts || 0, trendKey: "partShifts", icon: icons.partshifts, targetTab: "partshift" },
    { label: "Medical reports", number: data.actCounts.medicalReports || 0, trendKey: "medicalReports", icon: icons.medical, targetTab: "medical" }
  ];
  const kpiCardsHTML = metrics.map(m => {
    const trendVal = m.trendKey ? data.trending[m.trendKey] : 0;
    let trendSymbol = "–";
    let trendClass = "";
    let absVal = "";
    if(m.trendKey){
      absVal = Math.abs(trendVal);
      if(trendVal > 0){ trendSymbol = "▲"; trendClass = "up"; }
      else if(trendVal < 0){ trendSymbol = "▼"; trendClass = "down"; }
      else { trendSymbol = "–"; }
    }
    return `<div class="kpi-card" ${m.targetTab ? `data-tab="${m.targetTab}"` : ""}>
      <div class="kpi-card-header">
        ${m.icon}
        <span class="number">${escapeHtml(String(m.number))}</span>
      </div>
      <div class="label">${escapeHtml(m.label)}</div>
      <div class="trend ${trendClass}">${trendSymbol}${m.trendKey ? (" " + absVal) : ""}</div>
    </div>`;
  }).join("");

  // Determine the heading and time window for priority actions based on dashFocus
  let upcomingHeading;
  const focus = ui.dashFocus || 'all';
  if(focus === 'overdue') upcomingHeading = 'Overdue actions';
  else if(focus === 'next7') upcomingHeading = 'Priority actions (next 7 days)';
  else upcomingHeading = 'Priority actions (next 3 days)';
  // Filter upcoming actions based on selected focus
  const nowDate = new Date();
  let cutoff;
  if(focus === 'overdue'){
    cutoff = nowDate;
  }else if(focus === 'next7'){
    cutoff = new Date(nowDate.getTime() + 7*24*3600*1000);
  }else{
    cutoff = new Date(nowDate.getTime() + 3*24*3600*1000);
  }
  const filteredUpcoming = data.allUpcoming.filter(item => {
    const dueDate = new Date(item.due);
    if(String(dueDate) === 'Invalid Date') return false;
    // Overdue: dueDate <= now
    // Next7 and default: dueDate <= cutoff
    if(focus === 'overdue'){
      return dueDate <= cutoff;
    }
    return dueDate <= cutoff;
  });
  // Build the priority items HTML
  const upcomingItemsHTML = filteredUpcoming.slice(0, 8).map(item => {
    const dueDate = new Date(item.due);
    const diff = dueDate - nowDate;
    let cls = 'ok';
    if(diff <= 0) cls = 'danger';
    else if(diff <= 2*24*3600*1000) cls = 'warn';
    const dueStr = toUKDate(item.due);
    return `<div class="priority-item">
      <div class="info">
        <span class="name">${escapeHtml(item.colleagueName)}</span>
        <span class="muted">${escapeHtml(item.category)}</span>
      </div>
      <span class="badge ${cls}">${escapeHtml(dueStr)}</span>
    </div>`;
  }).join("");
  const priorityHTML = `<div class="priority-list">${upcomingItemsHTML || '<div class="muted">No actions in selected window.</div>'}</div>`;

  // Build new priority sections for the dashboard.  These lists separate upcoming actions
  // into those due in the next 3 days, those due in the next 7 days, and overdue items.
  // We will later insert the composed HTML into the page instead of the single
  // priorityHTML block above.
  const nowDatePriority = new Date();
  const next3CutoffPriority = new Date(nowDatePriority.getTime() + 3*24*3600*1000);
  const next7CutoffPriority = new Date(nowDatePriority.getTime() + 7*24*3600*1000);
  const overdueItems = [];
  const next3Items = [];
  const next7Items = [];
  data.allUpcoming.forEach(item => {
    const dueDate = new Date(item.due);
    if(String(dueDate) === 'Invalid Date') return;
    if(dueDate <= nowDatePriority){
      overdueItems.push(item);
    } else {
      if(dueDate <= next3CutoffPriority) next3Items.push(item);
      if(dueDate <= next7CutoffPriority) next7Items.push(item);
    }
  });
  function buildUpcomingHTML(list){
    const rows = list.slice(0, 8).map(item => {
      const dueDate = new Date(item.due);
      const diff = dueDate - nowDatePriority;
      let cls = 'ok';
      if(diff <= 0) cls = 'danger';
      else if(diff <= 2*24*3600*1000) cls = 'warn';
      const dueStr = toUKDate(item.due);
      return `<div class="priority-item">
        <div class="info">
          <span class="name">${escapeHtml(item.colleagueName)}</span>
          <span class="muted">${escapeHtml(item.category)}</span>
        </div>
        <span class="badge ${cls}">${escapeHtml(dueStr)}</span>
      </div>`;
    }).join("");
    return `<div class="priority-list">${rows || '<div class="muted">No actions in this window.</div>'}</div>`;
  }
  const next3HTML = buildUpcomingHTML(next3Items);
  const next7HTML = buildUpcomingHTML(next7Items);
  const overdueHTML = buildUpcomingHTML(overdueItems);
  // Counts for upcoming windows – used to annotate section headings
  const next3Count = next3Items.length;
  const next7Count = next7Items.length;
  const overdueCount = overdueItems.length;
  // Build the priority sections.  Each section (priority or overdue) is wrapped in its
  // own container to prevent floating issues and ensure headings always render.
  let prioritySectionsHTML = "";
  const dashFocus = ui.dashFocus || 'all';
  // Helper to build a single priority section with heading, a count badge and export buttons.
  // The count is displayed beside the heading and coloured based on the section type.
  function buildPrioritySection(title, id, html, count){
    let exportButtons;
    if(id === 'next3'){
      exportButtons = `<button class="btn small export-next3-csv">Export CSV</button><button class="btn small export-next3-pdf">Export PDF</button>`;
    } else if(id === 'next7'){
      exportButtons = `<button class="btn small export-next7-csv">Export CSV</button><button class="btn small export-next7-pdf">Export PDF</button>`;
    } else if(id === 'highrisk'){
      // Provide export buttons specific to high risk list.  Reuse the generic risk export handlers
      exportButtons = `<button class="btn small export-risk">Export CSV</button><button class="btn small export-risk-pdf">Export PDF</button>`;
    } else {
      exportButtons = `<button class="btn small export-overdue-csv">Export CSV</button><button class="btn small export-overdue-pdf">Export PDF</button>`;
    }
    // Determine badge colour: overdue always danger; others warn
    const badgeClass = id === 'overdue' ? 'danger' : 'warn';
    const countBadge = `<span class="badge-count ${badgeClass}">${escapeHtml(String(count))}</span>`;
    return `
      <div class="dash-section">
        <div class="section-header">${title} ${countBadge}<div class="export-group">${exportButtons}</div></div>
        ${html}
      </div>
    `;
  }
  if(dashFocus === 'overdue'){
    prioritySectionsHTML = buildPrioritySection('Overdue actions', 'overdue', overdueHTML, overdueCount);
  } else if(dashFocus === 'next7'){
    prioritySectionsHTML = buildPrioritySection('Priority actions (next 7 days)', 'next7', next7HTML, next7Count);
  } else if(dashFocus === 'highrisk'){
    // When high risk focus is selected show the list of flagged colleagues
    const hrRows = data.flagged.slice(0,10).map(item => {
      const tags = item.tags.map(t => `<span class=\"risk-tag\">${escapeHtml(t)}</span>`).join('');
      return `<tr><td><b>${escapeHtml(item.name)}</b><div class=\"muted\">${escapeHtml(item.id)}</div></td><td>${escapeHtml(item.department)}</td><td>${tags}</td></tr>`;
    }).join('');
    const hrHTML = `<table class=\"risk-table\"><thead><tr><th>Colleague</th><th>Dept</th><th>Risk factors</th></tr></thead><tbody>${hrRows || '<tr><td colspan=\"3\" class=\"muted\">No flagged colleagues.</td></tr>'}</tbody></table>`;
    prioritySectionsHTML = buildPrioritySection('High risk colleagues', 'highrisk', hrHTML, data.flagged.length);
  } else {
    // Default (all) shows next 3 and overdue stacked
    prioritySectionsHTML =
      buildPrioritySection('Priority actions (next 3 days)', 'next3', next3HTML, next3Count) +
      buildPrioritySection('Overdue actions', 'overdue', overdueHTML, overdueCount);
  }

  // Activity composition bars remain similar but rename to summary; colour scheme reused
  // Activity categories for the summary bars.  Include Me days to reflect Me Day
  // activity in the summary.  Colours reuse the dashboard palette.
  const actCats = [
    { label: 'Absences', key: 'absences', color: 'var(--danger)' },
    { label: 'Part shifts', key: 'partShifts', color: 'var(--warn)' },
    { label: 'Me days', key: 'meDays', color: 'var(--ok)' },
    { label: 'Medical reports', key: 'medicalReports', color: 'var(--ok)' },
    { label: 'Restrictions', key: 'restrictions', color: 'var(--warn)' },
    { label: 'Warnings', key: 'warnings', color: 'var(--danger)' },
    { label: 'Investigations', key: 'investigations', color: 'var(--danger)' }
  ];
  const activityHTML = `<div class="activity-bars">${actCats.map(cat => {
      const count = data.actCounts[cat.key] || 0;
      const pct = data.actPercents[cat.key] || 0;
      return `<div class="activity-bar"><div class="labelRow"><span>${escapeHtml(cat.label)}</span><span>${escapeHtml(String(count))} (${pct}%)</span></div><div class="barOuter"><div class="barInner" style="width:${pct}%;background:${cat.color};"></div></div></div>`;
    }).join('')}</div>`;

  // Department snapshot table (unchanged) but update heading for upcoming column to use 7d always
  const deptRows = Object.keys(data.deptStats).map(deptName => {
    const stats = data.deptStats[deptName];
    const pct = stats.headcount ? Math.round(stats.absent / stats.headcount * 100) : 0;
    const openCases = (stats.warnings + stats.restrictions + stats.investigations);
    return `<tr><td>${escapeHtml(deptName)}</td><td>${escapeHtml(String(stats.headcount))}</td><td>${escapeHtml(String(stats.absent))} (${pct}%)</td><td>${escapeHtml(String(openCases))}</td><td>${escapeHtml(String(stats.upcoming))}</td></tr>`;
  }).join('');
  const deptHTML = `<table class="dept-table"><thead><tr><th>Department</th><th>Colleagues</th><th>Absent (%)</th><th>Open cases</th><th>Upcoming (7d)</th></tr></thead><tbody>${deptRows || '<tr><td colspan="5" class="muted">No data</td></tr>'}</tbody></table>`;

  // Risk radar remains unchanged
  const riskRows = data.flagged.slice(0,10).map(item => {
    const tags = item.tags.map(t => `<span class="risk-tag">${escapeHtml(t)}</span>`).join('');
    return `<tr><td><b>${escapeHtml(item.name)}</b><div class="muted">${escapeHtml(item.id)}</div></td><td>${escapeHtml(item.department)}</td><td>${tags}</td></tr>`;
  }).join('');
  const riskHTML = `<table class="risk-table"><thead><tr><th>Colleague</th><th>Dept</th><th>Risk factors</th></tr></thead><tbody>${riskRows || '<tr><td colspan="3" class="muted">No flagged colleagues.</td></tr>'}</tbody></table>`;

  // Build needs attention section.  Pull lists from data.attention and
  // construct groups for overdue restrictions, open investigations,
  // warnings nearing expiry and absence spikes.  If a list is empty,
  // the group is omitted.  Each item links to the colleague profile.
  let attentionHTML = '';
  const att = data.attention || {};
  function buildAttGroup(title, list){
    if(!list || !list.length) return '';
    const items = list.slice(0, 10).map(item => {
      // Build a clickable row that opens the colleague profile on click.  Use
      // data-col-id attribute for event delegation.
      return `<div class="att-item" data-col-id="${escapeHtml(item.colleagueId)}"><span>${escapeHtml(item.text)}</span></div>`;
    }).join('');
    return `<div class="attention-group"><div class="attention-title">${escapeHtml(title)}</div>${items}</div>`;
  }
  attentionHTML += buildAttGroup('Overdue restrictions', att.overdueRestrictions);
  attentionHTML += buildAttGroup('Open investigations', att.openInvestigations);
  attentionHTML += buildAttGroup('Warnings nearing expiry', att.warningsExpiring);
  attentionHTML += buildAttGroup('Absence spikes', att.absenceSpikes);
  if(!attentionHTML){
    attentionHTML = '<div class="muted">No urgent items</div>';
  } else {
    attentionHTML = `<div class="attention-list">${attentionHTML}</div>`;
  }
  // Build quick actions bar.  These buttons provide fast entry points to log new cases.
  // The dashboard previously included a row of "quick actions" buttons (Investigation, Absence, Warning)
  // at the top of the priority actions section.  Because a global Quick Add button now lives in the
  // top bar with the same functionality, we intentionally leave this empty so no duplicate buttons render.
  const quickActionsHTML = '';
  // Compose the dashboard HTML
  // Build the full dashboard layout.  Controls at top, KPI cards, quick actions, then the priority sections and other summaries.
  host.innerHTML = `
    <div class="dashboard">
      ${controlsHTML}
      <div class="dashboard-kpis">
        ${kpiCardsHTML}
      </div>
      ${quickActionsHTML}
      <div>
        ${prioritySectionsHTML}
      </div>
      <div>
        <div class="section-header">Activity summary (last ${escapeHtml(ui.dashRange || "28d")})</div>
        ${activityHTML}
      </div>
      <div>
        <div class="section-header">Department snapshot</div>
        ${deptHTML}
      </div>
      <div>
        <div class="section-header">Risk radar<div class="export-group"><button class="btn small export-risk">Export CSV</button><button class="btn small export-risk-pdf">Export PDF</button></div></div>
        ${riskHTML}
      </div>
      <div>
        <div class="section-header">Needs attention</div>
        ${attentionHTML}
      </div>
      <!-- Summary chart section -->
      <div>
        <div class="section-header">Activity overview chart</div>
        <div class="chart-container" style="position:relative;">
          <canvas id="summary-chart"></canvas>
          <div id="chart-tooltip" class="chart-tooltip" style="display:none;"></div>
          <!-- Legend below the chart will be populated dynamically -->
          <div id="chart-legend" class="chart-legend"></div>
        </div>
      </div>
    </div>
  `;
  // Add interactivity: clicking KPI cards navigates to their respective tabs.  Range and focus buttons
  // update UI state and re-render the dashboard.
  host.querySelectorAll('.kpi-card[data-tab]').forEach(card => {
    card.style.cursor = 'pointer';
    card.addEventListener('click', () => {
      const t = card.dataset.tab;
      if(t) openTab(t);
    });
  });

  // Attach click handlers to needs attention items.  Each item holds a
  // data-col-id attribute.  When clicked, open the colleague profile.
  host.querySelectorAll('.att-item').forEach(item => {
    const colId = item.dataset.colId;
    if(colId){
      item.addEventListener('click', () => {
        openColProfileModal(colId);
      });
    }
  });
  host.querySelectorAll('.range-toggle button').forEach(btn => {
    btn.addEventListener('click', () => {
      const r = btn.dataset.range;
      if(!r || r === ui.dashRange) return;
      ui.dashRange = r;
      saveUI();
      renderCurrentTab();
    });
  });
  host.querySelectorAll('.focus-toggle button').forEach(btn => {
    btn.addEventListener('click', () => {
      const f = btn.dataset.focus;
      if(!f || f === ui.dashFocus) return;
      ui.dashFocus = f;
      saveUI();
      renderCurrentTab();
    });
  });

  // Manager filter select: changing selection updates ui.managerFilter and re-renders the dashboard.  When the value is "ALL"
  // all managers are shown; otherwise only upcoming actions managed by the selected manager are included.
  const mgrSelectEl = host.querySelector('#dash-manager');
  if(mgrSelectEl){
    mgrSelectEl.addEventListener('change', () => {
      ui.managerFilter = mgrSelectEl.value || 'ALL';
      saveUI();
      renderCurrentTab();
    });
  }

  // Export handlers for priority sections.
  // Each priority window (next3, next7, overdue) has its own CSV and PDF buttons.
  // Build CSV rows for a given list of upcoming items.
  function exportUpcomingList(list, filename){
    const rows = list.map(item => ({
      Colleague: item.colleagueName,
      Category: item.category,
      Due: toUKDate(item.due),
      Extra: item.extra || ''
    }));
    downloadCSV(filename, rows);
  }
  // Add handlers for Next 3 days CSV/PDF
  host.querySelectorAll('.export-next3-csv').forEach(btn => {
    btn.addEventListener('click', () => {
      exportUpcomingList(next3Items, 'priority_next3days.csv');
    });
  });
  host.querySelectorAll('.export-next3-pdf').forEach(btn => {
    btn.addEventListener('click', () => {
      window.print();
    });
  });
  // Handlers for Next 7 days CSV/PDF
  host.querySelectorAll('.export-next7-csv').forEach(btn => {
    btn.addEventListener('click', () => {
      exportUpcomingList(next7Items, 'priority_next7days.csv');
    });
  });
  host.querySelectorAll('.export-next7-pdf').forEach(btn => {
    btn.addEventListener('click', () => {
      window.print();
    });
  });
  // Handlers for Overdue CSV/PDF
  host.querySelectorAll('.export-overdue-csv').forEach(btn => {
    btn.addEventListener('click', () => {
      exportUpcomingList(overdueItems, 'priority_overdue.csv');
    });
  });
  host.querySelectorAll('.export-overdue-pdf').forEach(btn => {
    btn.addEventListener('click', () => {
      window.print();
    });
  });
  // CSV export handler for risk table remains.  Use .export-risk for CSV and .export-risk-pdf for PDF.
  // Handle exports for risk sections (both risk radar and high risk focus).  There may be multiple buttons,
  // so attach handlers to each.  Export to CSV uses the flagged list; PDF triggers browser print.
  host.querySelectorAll('.export-risk').forEach(btn => {
    btn.addEventListener('click', () => {
      const rows = data.flagged.map(item => ({
        Colleague: item.name,
        ID: item.id,
        Department: item.department,
        Tags: item.tags.join('; ')
      }));
      downloadCSV('risk_radar.csv', rows);
    });
  });
  host.querySelectorAll('.export-risk-pdf').forEach(btn => {
    btn.addEventListener('click', () => {
      window.print();
    });
  });

  // Quick action buttons.  These provide a fast way to open the relevant case modals
  // from the dashboard.  Each button triggers the same modal that would be opened
  // from the corresponding tab.  Because these modals live in the global scope,
  // calling the functions directly is sufficient.
  host.querySelectorAll('.quick-investigation').forEach(btn => {
    btn.addEventListener('click', () => {
      // Open a fresh investigation modal
      openInvestigationModal();
    });
  });
  host.querySelectorAll('.quick-absence').forEach(btn => {
    btn.addEventListener('click', () => {
      // Launch the absence modal without any preselected record
      openAbsenceModal();
    });
  });
  host.querySelectorAll('.quick-warning').forEach(btn => {
    btn.addEventListener('click', () => {
      // Show the add warning modal
      openWarningModal();
    });
  });

  // Draw the activity overview chart.  Pass the aggregated counts from the
  // dashboard data to the drawing function.  The function will handle
  // responsiveness and hover interactions.
  drawSummaryChart(data.chartCounts);
}

/* ---- Admin tab ---- */
function renderAdmin(host){
  renderShell(host, "Admin", "Administrative functionality.", "", "", `
    <div class="muted">Admin functions coming soon.</div>
  `);
}

/* ---- Settings tab ---- */
// Display system configuration and allow admins to update thresholds for risk detection and other options.
function renderSettings(host){
  // Check admin privileges: only admins or users with canAdmin flag may access settings.
  const canAdmin = state.session && (state.session.role === 'admin' || state.session.canAdmin);
  if(!canAdmin){
    host.innerHTML = '<div class="card"><p>You do not have permission to view or edit settings.</p></div>';
    return;
  }
  // Build form inputs for each configurable value.  Pre-fill with current values from state.config or defaults.
  const cfg = state.config || {};
  const absenceThreshold = cfg.absenceThreshold != null ? cfg.absenceThreshold : 3;
  const absenceWindow = cfg.absenceDaysWindow != null ? cfg.absenceDaysWindow : 60;
  const warningThreshold = cfg.warningThreshold != null ? cfg.warningThreshold : 2;
  const warningWindow = cfg.warningDaysWindow != null ? cfg.warningDaysWindow : 365;
  host.innerHTML = `
    <div class="settings">
      <h2>System Settings</h2>
      <p class="muted">Configure thresholds that determine risk flags on the dashboard.  Changing these values will affect how the risk radar identifies frequent absences and multiple warnings.</p>
      <form id="settings-form" class="settings-form">
        <div class="form-row">
          <label>Absence threshold<br><small class="muted">Number of absences to trigger a frequent absence flag</small></label>
          <input type="number" id="cfg-absence-threshold" min="1" value="${escapeHtml(String(absenceThreshold))}" />
        </div>
        <div class="form-row">
          <label>Absence window (days)<br><small class="muted">Look‑back window for counting frequent absences</small></label>
          <input type="number" id="cfg-absence-window" min="1" value="${escapeHtml(String(absenceWindow))}" />
        </div>
        <div class="form-row">
          <label>Warning threshold<br><small class="muted">Number of warnings to trigger a multiple warnings flag</small></label>
          <input type="number" id="cfg-warning-threshold" min="1" value="${escapeHtml(String(warningThreshold))}" />
        </div>
        <div class="form-row">
          <label>Warning window (days)<br><small class="muted">Look‑back window for counting warnings</small></label>
          <input type="number" id="cfg-warning-window" min="1" value="${escapeHtml(String(warningWindow))}" />
        </div>
        <div class="form-row">
          <button type="button" class="btn primary" id="cfg-save">Save Settings</button>
        </div>
      </form>
    </div>
  `;
  // Save button handler: update state.config with new values and persist state
  const saveBtn = document.getElementById('cfg-save');
  if(saveBtn){
    saveBtn.addEventListener('click', () => {
      // Fetch values and ensure they are integers > 0
      const nAbsTh = parseInt(document.getElementById('cfg-absence-threshold').value, 10);
      const nAbsWin = parseInt(document.getElementById('cfg-absence-window').value, 10);
      const nWarnTh = parseInt(document.getElementById('cfg-warning-threshold').value, 10);
      const nWarnWin = parseInt(document.getElementById('cfg-warning-window').value, 10);
      if(isNaN(nAbsTh) || nAbsTh <= 0 || isNaN(nAbsWin) || nAbsWin <= 0 || isNaN(nWarnTh) || nWarnTh <= 0 || isNaN(nWarnWin) || nWarnWin <= 0){
        alert('Please enter valid positive numbers for all settings.');
        return;
      }
      state.config.absenceThreshold = nAbsTh;
      state.config.absenceDaysWindow = nAbsWin;
      state.config.warningThreshold = nWarnTh;
      state.config.warningDaysWindow = nWarnWin;
      saveState();
      alert('Settings saved successfully.');
      renderCurrentTab();
    });
  }
}

function openColleagueModal(rec=null){
  const isNew=!rec;
  // Add a 'persistent' flag so colleagues can opt out of data wipe.
  const r=rec||{id:"",name:"",department:"Retail",contact:"", teamManagerId: undefined, persistent:false};
  // Build manager options for the team manager select. Include a blank option for no manager.
  const mgrOptions = state.managers.map(m => {
    const sel = (m.id === r.teamManagerId) ? ' selected' : '';
    return `<option value="${escapeHtml(m.id)}"${sel}>${escapeHtml(m.name)}</option>`;
  }).join("");
  const body=`
    <div class="grid">
      <div class="field"><label>Colleague ID</label><input id="col-id" value="${escapeHtml(r.id||"")}" ${isNew?"":"disabled"} placeholder="e.g. C004"></div>
      <div class="field"><label>Name</label><input id="col-name" value="${escapeHtml(r.name||"")}"></div>
      <div class="field"><label>Department</label>
        <select id="col-dept">
          ${["Dot Com","Retail","Transport","Stock - Dot Com","Stock - Retail"].map(d=>`<option ${d===r.department?"selected":""}>${d}</option>`).join("")}
        </select>
      </div>
      <div class="field"><label>Team Manager</label>
        <select id="col-team-manager">
          <option value="">-- None --</option>
          ${mgrOptions}
        </select>
      </div>
      <div class="field"><label>Contact</label><input id="col-contact" value="${escapeHtml(r.contact||"")}" placeholder="Optional"></div>
      <div class="field"><label><input id="col-persist" type="checkbox" ${r.persistent?"checked":""}> Keep on wipe</label></div>
    </div>
  `;
  openModal(isNew?"Add Colleague":"Edit Colleague", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      const id = document.getElementById("col-id").value.trim();
      const name = document.getElementById("col-name").value.trim();
      const dept = document.getElementById("col-dept").value;
      const contact = document.getElementById("col-contact").value.trim();
      if(isNew && !id) return alert("Enter colleague ID");
      if(!name) return alert("Enter name");
      if(isNew && state.colleagues.some(c=>c.id===id)) return alert("Colleague ID already exists");

      r.id = isNew ? id : r.id;
      r.name = name;
      r.department = dept;
      r.contact = contact;
      // Assign persistent flag from checkbox
      r.persistent = document.getElementById("col-persist").checked;
      // Assign team manager from dropdown. Empty value becomes undefined.
      const tmVal = document.getElementById("col-team-manager").value;
      r.teamManagerId = tmVal ? tmVal : undefined;

      if(isNew) {
        state.colleagues.unshift(r);
      } else {
        state.colleagues = state.colleagues.map(x=>x.id===r.id?r:x);
      }

      saveState(); closeModal(); renderCurrentTab();
    }}
  ]);
}

// Display a chronological timeline of a colleague's history across absences, warnings and investigations.
function openTimeline(colId){
  const col = state.colleagues.find(c => c.id === colId);
  if(!col) return;
  // Gather events from various modules
  const events = [];
  // Absence events and creation
  (state.absences || []).forEach(abs => {
    if(abs.colleagueId !== colId) return;
    const created = abs.createdAt || abs.date || abs.dateAbsence;
    if(created) events.push({date: new Date(created), label: 'Absence recorded', details: ''});
    (abs.events || []).forEach(ev => {
      const dt = ev.dateStart || ev.date || ev.sicknessDate;
      if(!dt) return;
      let details = '';
      if(ev.sickness) details += ev.sickness;
      if(ev.nextAction) details += (details ? '; ' : '') + 'Next: ' + ev.nextAction;
      if(ev.nextActionDT) details += ' on ' + toUKDate(ev.nextActionDT);
      events.push({date: new Date(dt), label:'Absence event', details: details});
    });
  });
  // Warnings
  (state.warnings || []).forEach(w => {
    if(w.colleagueId !== colId) return;
    const dt = w.hearingDate || w.createdAt;
    const details = (w.action || '') + (w.reason ? ' – ' + w.reason : '');
    if(dt) events.push({date: new Date(dt), label:'Warning', details: details});
  });
  // Investigations
  (state.investigations || []).forEach(inv => {
    if(inv.colleagueId !== colId) return;
    const dt = inv.date;
    const details = (inv.caseRef ? inv.caseRef + ' – ' : '') + (inv.outcome || 'To be conducted');
    if(dt) events.push({date: new Date(dt), label:'Investigation', details: details});
  });
  // Audit trail entries for this colleague. Include entries where colleagueId matches or null (global) but skip unrelated.
  (state.auditTrail || []).forEach(entry => {
    // If entry has a colleagueId and it's not the one we are showing, skip
    if(entry.colleagueId && entry.colleagueId !== colId) return;
    const dt = entry.ts;
    if(!dt) return;
    // Compose a descriptive label and details. Prefix with action/entity for clarity.
    const actionLabel = (entry.action || '') + ' ' + (entry.entity || '');
    const detailStr = entry.details ? (actionLabel + ' – ' + entry.details) : actionLabel;
    events.push({ date: new Date(dt), label: 'Audit', details: detailStr });
  });
  // Sort events chronologically
  events.sort((a,b) => a.date - b.date);
  const listItems = events.map(ev => {
    const d = toUKDate(ev.date.toISOString());
    return `<li><b>${escapeHtml(d)}</b>: ${escapeHtml(ev.label)}${ev.details ? ' – ' + escapeHtml(ev.details) : ''}</li>`;
  }).join('');
  const body = `<ul class="timeline-list" style="list-style:none;padding-left:0;">${listItems || '<li>No history recorded.</li>'}</ul>`;
  openModal('Timeline – ' + escapeHtml(col.name), body, [
    {label:'Export', kind:'primary', onClick: () => downloadEvidence(colId)},
    {label:'Close', onClick: closeModal}
  ]);
}

// Download a narrative summary of a colleague's history as a plain text file.
function downloadEvidence(colId){
  const col = state.colleagues.find(c => c.id === colId);
  if(!col) return;
  const events = [];
  (state.absences || []).forEach(abs => {
    if(abs.colleagueId !== colId) return;
    const created = abs.createdAt || abs.date || abs.dateAbsence;
    if(created) events.push({date: new Date(created), label:'Absence recorded', details:''});
    (abs.events || []).forEach(ev => {
      const dt = ev.dateStart || ev.date || ev.sicknessDate;
      if(!dt) return;
      let details = '';
      if(ev.sickness) details += ev.sickness;
      if(ev.nextAction) details += (details ? '; ' : '') + 'Next: ' + ev.nextAction;
      if(ev.nextActionDT) details += ' on ' + toUKDate(ev.nextActionDT);
      events.push({date: new Date(dt), label:'Absence event', details: details});
    });
  });
  (state.warnings || []).forEach(w => {
    if(w.colleagueId !== colId) return;
    const dt = w.hearingDate || w.createdAt;
    const details = (w.action || '') + (w.reason ? ' – ' + w.reason : '');
    if(dt) events.push({date: new Date(dt), label:'Warning', details: details});
  });
  (state.investigations || []).forEach(inv => {
    if(inv.colleagueId !== colId) return;
    const dt = inv.date;
    const details = (inv.caseRef ? inv.caseRef + ' – ' : '') + (inv.outcome || 'To be conducted');
    if(dt) events.push({date: new Date(dt), label:'Investigation', details: details});
  });
  events.sort((a,b) => a.date - b.date);
  const lines = [];
  lines.push('Evidence pack for ' + col.name + ' (' + col.id + ')');
  lines.push('');
  events.forEach(ev => {
    const d = toUKDate(ev.date.toISOString());
    lines.push(d + ' - ' + ev.label + (ev.details ? ': ' + ev.details : ''));
  });
  const text = lines.join('\n');
  const blob = new Blob([text], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'Evidence_' + col.id + '.txt';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function renderManagers(host){
  const rows = state.managers
    .filter(m=>ui.dept==="ALL"||m.department===ui.dept)
    .map(m=>[
      `<b>${escapeHtml(m.name)}</b>`,
      escapeHtml(m.department),
      `<div style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="btn small" data-act="edit" data-id="${m.id}">Edit</button>
        <button class="btn small danger" data-act="del" data-id="${m.id}">Delete</button>
      </div>`
    ]);

  renderShell(host, "Managers", "Managers used across tabs.", `
    <button class="btn primary" id="man-add">+ Add manager</button>
  `, "", `
    <table>
      <thead><tr><th>Name</th><th>Department</th><th>Actions</th></tr></thead>
      <tbody>${rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join("")}</tr>`).join("") || `<tr><td colspan="3" class="muted">No managers.</td></tr>`}</tbody>
    </table>
  `);

  document.getElementById("man-add").addEventListener("click", ()=>openManagerModal());

  host.querySelectorAll("button[data-act]").forEach(b=>{
    b.addEventListener("click", ()=>{
      const rec = state.managers.find(x=>x.id===b.dataset.id);
      if(!rec) return;
      if(b.dataset.act==="del"){
        // Use generic deletion helper with audit and undo
        handleDeleteRecord('managers', rec, 'manager', renderCurrentTab);
      }else openManagerModal(rec);
    });
  });
}

function openManagerModal(rec=null){
  const isNew=!rec;
  // Add a 'persistent' flag so managers can opt out of data wipe.
  const r=rec||{id:uid(),name:"",department:"Retail",persistent:false};
  const body=`
    <div class="grid">
      <div class="field"><label>Name</label><input id="man-name" value="${escapeHtml(r.name||"")}"></div>
      <div class="field"><label>Department</label>
        <select id="man-dept">
          ${["Dot Com","Retail","Transport","Stock - Dot Com","Stock - Retail"].map(d=>`<option ${d===r.department?"selected":""}>${d}</option>`).join("")}
        </select>
      </div>
      <div class="field"><label><input id="man-persist" type="checkbox" ${r.persistent?"checked":""}> Keep on wipe</label></div>
    </div>
  `;
  openModal(isNew?"Add Manager":"Edit Manager", body, [
    {label:"Cancel", onClick: closeModal},
    {label:"Save", kind:"primary", onClick: ()=>{
      const name = document.getElementById("man-name").value.trim();
      const dept = document.getElementById("man-dept").value;
      if(!name) return alert("Enter manager name");
      r.name = name; 
      r.department = dept;
      // Assign persistent flag from checkbox
      r.persistent = document.getElementById("man-persist").checked;

      if(isNew) {
        state.managers.unshift(r);
      }
      else {
        state.managers = state.managers.map(x=>x.id===r.id?r:x);
      }

      saveState(); closeModal(); renderCurrentTab();
    }}
  ]);
}

// Modal to create or edit a user account.  Administrators can use this
// to grant login access to others.  A user has a username, password,
// and permissions controlling whether they may delete entries or access
// the Admin tab.  When adding a new user, ensure that the username
// does not clash with existing custom accounts or the built-in USERS.
function openUserModal(rec=null){
  const isNew = !rec;
  // When editing an existing record, copy its properties; otherwise start
  // with empty/default values.  We do not assign an id because user
  // objects are identified solely by username.
  // Add a 'persistent' flag so users can opt out of data wipe.
  const r = rec || { username:"", password:"", canDelete:false, canAdmin:false, persistent:false };
  const body = `
    <div class="grid">
      <div class="field"><label>Username</label><input id="user-username" value="${escapeHtml(r.username || "")}" ${isNew?"":"readonly"}></div>
      <div class="field"><label>Password</label><input id="user-password" type="password" value="${escapeHtml(r.password || "")}"></div>
      <div class="field"><label><input id="user-delete" type="checkbox" ${r.canDelete?"checked":""}> Can delete</label></div>
      <div class="field"><label><input id="user-admin" type="checkbox" ${r.canAdmin?"checked":""}> Can access Admin</label></div>
      <div class="field"><label><input id="user-persist" type="checkbox" ${r.persistent?"checked":""}> Keep on wipe</label></div>
    </div>
  `;
  openModal(isNew ? "Add user" : "Edit user", body, [
    { label: "Cancel", onClick: closeModal },
    { label: "Save", kind: "primary", onClick: () => {
      const uname = document.getElementById("user-username").value.trim();
      const pwd   = document.getElementById("user-password").value;
      const canDel = document.getElementById("user-delete").checked;
      const canAdm = document.getElementById("user-admin").checked;
      const persist = document.getElementById("user-persist").checked;
      if(!uname) return alert("Enter a username");
      if(!pwd)   return alert("Enter a password");
      // Check for duplicate usernames.  New users cannot have a name that
      // matches an existing custom account or a built-in account.  When
      // editing, allow the same username.  The built-in USERS array is
      // immutable and cannot be modified here.
      const nameLower = uname.toLowerCase();
      if(isNew){
        const existsCustom = (state.users || []).some(u => (u.username || "").toLowerCase() === nameLower);
        const existsBuilt  = USERS.some(u => (u.username || "").toLowerCase() === nameLower);
        if(existsCustom || existsBuilt){
          return alert("Username already exists. Please choose another.");
        }
        // Append new user to state.users
        state.users = state.users || [];
        state.users.push({ username: uname, password: pwd, canDelete: canDel, canAdmin: canAdm, persistent: persist });
      }else{
        // Editing an existing user: find and update the record.  We do not
        // allow editing the username because it is the identifier.
        state.users = (state.users || []).map(u => {
          if(u.username === r.username){
            return Object.assign({}, u, { password: pwd, canDelete: canDel, canAdmin: canAdm, persistent: persist });
          }
          return u;
        });
      }
      saveState();
      closeModal();
      // Re-render the admin tab to refresh the user list
      renderCurrentTab();
    } }
  ]);
}

// Prompt the user for admin credentials when attempting to access the Admin tab.  This
// modal accepts a username and password and checks against any user with
// administrator access.  On successful authentication it sets
// state.session.adminUnlocked to true, enabling the Admin tab for the remainder
// of the session.  The optional onSuccess callback is invoked after a
// successful login to allow the caller to continue opening the admin tab.
function openAdminLoginModal(onSuccess){
  const body = `
    <div class="grid">
      <div class="field"><label>Username</label><input id="admin-login-user" placeholder="Enter admin username"></div>
      <div class="field"><label>Password</label><input id="admin-login-pass" type="password" placeholder="Enter admin password"></div>
    </div>
  `;
  openModal("Admin login", body, [
    { label: "Cancel", onClick: closeModal },
    { label: "Login", kind: "primary", onClick: async () => {
      const u = document.getElementById("admin-login-user").value.trim();
      const p = document.getElementById("admin-login-pass").value;
      // Search custom user accounts with admin permission
      let match = null;
      if(Array.isArray(state.users)){
        match = state.users.find(x => x.username === u && x.password === p && x.canAdmin);
      }
      // Fall back to built-in USERS with role admin
      if(!match){
        const cand = USERS.find(x => x.username === u && (x.role === 'admin'));
        const ok = cand ? await verifyPassword(cand, p) : false;
        match = ok ? cand : null;
      }
      if(!match){
        alert("Invalid administrator credentials");
        return;
      }
      // Unlock admin for this session
      state.session.adminUnlocked = true;
      // Elevate canAdmin and canDelete permissions if the matched account has them
      state.session.canAdmin = true;
      if(match.canDelete || match.role === 'admin'){
        state.session.canDelete = true;
      }
      // Persist session state
      sessionStorage.setItem(LS_SESSION, JSON.stringify(state.session));
      closeModal();
      // Re-render navigation to show the Admin tab if it was hidden
      renderNav();
      if(typeof onSuccess === 'function') onSuccess();
    } }
  ]);
}

function renderAdmin(host){
  // Clear the host container
  host.innerHTML = "";

  /*
   * User Accounts Management
   * Build a card allowing the administrator to create, view and delete user
   * accounts.  Each user has a username, password (stored in state), and
   * permissions for deletion and admin access.  A table lists existing
   * accounts with a delete button.  The Add User button opens a modal
   * where new accounts can be created.
   */
  const usersContainer = document.createElement('div');
  host.appendChild(usersContainer);
  // Build table rows for existing users
  const userRows = (state.users || []).map(u => {
    return `
      <tr>
        <td>${escapeHtml(u.username)}</td>
        <td>${u.canDelete ? 'Yes' : 'No'}</td>
        <td>${u.canAdmin ? 'Yes' : 'No'}</td>
        <td>
          <button class="btn small" data-act="editUser" data-u="${escapeHtml(u.username)}">Edit</button>
          <button class="btn small danger" data-act="delUser" data-u="${escapeHtml(u.username)}">Delete</button>
        </td>
      </tr>
    `;
  }).join("");
  renderShell(usersContainer, "User Accounts", "Manage login accounts for this app.", `
    <button class="btn" id="admin-add-user">+ Add user</button>
  `, "", `
    <table>
      <thead><tr><th>Username</th><th>Can delete</th><th>Can access Admin</th><th>Actions</th></tr></thead>
      <tbody>
        ${userRows || '<tr><td colspan="4" class="muted">No user accounts yet.</td></tr>'}
      </tbody>
    </table>
  `);
  // Bind Add User button
  document.getElementById('admin-add-user').addEventListener('click', () => openUserModal());
  // Bind edit and delete buttons for users
  usersContainer.querySelectorAll('button[data-act]').forEach(btn => {
    btn.addEventListener('click', () => {
      const uname = btn.dataset.u;
      const act = btn.dataset.act;
      if(act === 'editUser'){
        // Find the user record and open the modal for editing
        const rec = (state.users || []).find(x => x.username === uname);
        if(rec) openUserModal(rec);
      } else if(act === 'delUser'){
        // Use generic deletion helper with audit and undo. Users are identified by username, not id.
        const recUser = (state.users || []).find(x => x.username === uname);
        if(recUser){
          handleDeleteRecord('users', recUser, 'user account', renderCurrentTab);
        }
      }
    });
  });

  /*
   * Manager Management
   * Reuse the existing renderManagers function to provide a card with
   * manager listings and add/edit/delete functionality.  This card will
   * appear directly beneath the user management card.
   */
  const mgrContainer = document.createElement('div');
  host.appendChild(mgrContainer);
  renderManagers(mgrContainer);

  /*
   * Data & Backup Management
   * Provide export and wipe functions.  Wipe requires a double confirmation
   * and a password prompt (ASDACLEAR) before clearing all data.
   */
  const dataContainer = document.createElement('div');
  // Assign an id to the data/backup container so we can customise its
  // button alignment later.  This id is only used internally and does
  // not affect functionality.
  dataContainer.id = 'dataBackupSection';
  host.appendChild(dataContainer);
  // Data & Backup Management
  // Added an Import JSON backup button between Export and Wipe buttons.  This
  // allows administrators to load a previously exported backup file.  The
  // import button is separate to keep the actions clear and avoids
  // accidentally triggering a wipe when intending to import.
  renderShell(dataContainer, "Data & Backup", "", `
    <button class="btn" id="admin-export-state">Export JSON backup</button>
    <button class="btn" id="admin-import-state">Import JSON backup</button>
    <button class="btn danger" id="admin-wipe">Wipe ALL data (localStorage)</button>
  `, "", "");
  // Centre the action buttons for the Data & Backup card.  After
  // renderShell runs, locate the actionsRow within the card header
  // and apply a class that overrides the absolute positioning defined
  // in the stylesheet.  This class is defined near the CSS for
  // .actionsRow and sets the layout to be centered.
  (function(){
    try {
      const actionsRow = dataContainer.querySelector('.actionsRow');
      if(actionsRow) actionsRow.classList.add('center-actions');
    } catch(err) {
      // Silently ignore errors since this styling is non-critical
      console.error('Could not apply centre-actions', err);
    }
  })();
  // Export JSON backup
  document.getElementById('admin-export-state').addEventListener('click', () => {
    const blob = new Blob([JSON.stringify(state,null,2)],{type:'application/json'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='ACE_Backup.json';
    document.body.appendChild(a); a.click(); a.remove();
  });
  // Import JSON backup
  document.getElementById('admin-import-state').addEventListener('click', () => {
    // Create a hidden file input for selecting a JSON backup file.  We
    // intentionally limit accepted file types to JSON to avoid loading
    // arbitrary formats.  The event listener is defined only once at
    // creation time and cleans itself up when the import is complete.
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json,application/json';
    input.style.display = 'none';
    input.addEventListener('change', (event) => {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      // Warn if the file is large; this can cause heavy memory usage
      // particularly on low-end devices.  Provide the user an option to
      // cancel the import before reading the file.
      if (file.size > 5 * 1024 * 1024) {
        if (!confirm('This backup appears large and may take time to load.\nDo you still want to proceed?')) {
          return;
        }
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const imported = JSON.parse(e.target.result);
          // Normalize imported data: start from a fresh default state and
          // selectively copy only known keys.  This prevents arbitrary
          // properties from polluting the global state and causing
          // unexpected behaviour.
          const allowedKeys = [
            'users', 'managers', 'colleagues',
            'availableDays', 'availableTimes', 'locations',
            'jobTypes', 'jobSizes', 'duration', 'unit',
            'deadline', 'tags', 'session', 'ui'
          ];
          const newState = defaultState();
          allowedKeys.forEach(key => {
            const value = imported && imported[key];
            if (value === undefined) return;
            // Copy arrays and objects shallowly to avoid sharing
            // references with the original imported object.  Primitive
            // values are copied directly.
            if (Array.isArray(value)) {
              newState[key] = value.map(item => {
                if (typeof item === 'object' && item !== null) {
                  return Object.assign({}, item);
                }
                return item;
              });
            } else if (typeof value === 'object' && value !== null) {
              newState[key] = Object.assign({}, value);
            } else {
              newState[key] = value;
            }
          });
          // Preserve the current session ID when importing so that the
          // administrator remains logged in after import.  If no session
          // exists in the current state, accept any session from the
          // imported backup.
          if (state && state.session) {
            newState.session = state.session;
          }
          state = newState;
          saveState();
          saveUI();
          // After importing we re-render the navigation and set the
          // current tab to the dashboard to avoid heavy table re-rendering
          // immediately.  Then we call renderCurrentTab() to refresh the
          // view.  Using dashboard as the landing tab ensures that even
          // large datasets do not freeze the UI during import.
          renderNav();
          currentTab = 'dashboard';
          renderCurrentTab();
          alert('Backup imported successfully.');
        } catch (err) {
          console.error(err);
          alert('Failed to import JSON backup: ' + (err && err.message ? err.message : err));
        }
      };
      reader.onerror = (err) => {
        console.error(err);
        alert('Error reading file: ' + (err && err.message ? err.message : err));
      };
      reader.readAsText(file);
    });
    document.body.appendChild(input);
    input.click();
    // Remove the input element after triggering the click to clean up
    // the DOM.  Delay removal slightly to ensure the click event
    // registers properly.
    setTimeout(() => {
      document.body.removeChild(input);
    }, 0);
  });
  // Wipe all data with double confirmation and password
  document.getElementById('admin-wipe').addEventListener('click', () => {
    if(!confirm('This will wipe all data, are you sure?')) return;
    const pwd = prompt('Enter wipe password');
    if(pwd !== 'ASDACLEAR'){
      alert('Incorrect password. Data was not cleared.');
      return;
    }
    // Before wiping, capture any persistent colleagues, managers, and users.
    const preservedColleagues = (state.colleagues || []).filter(c => c && c.persistent);
    const preservedManagers   = (state.managers   || []).filter(m => m && m.persistent);
    const preservedUsers      = (state.users      || []).filter(u => u && u.persistent);
    // Clear localStorage keys
    localStorage.removeItem(LS_KEY);
    localStorage.removeItem(LS_UI);
    // Build a fresh default state
    let newState = defaultState();
    // Merge preserved colleagues, avoiding ID conflicts with defaults
    if(Array.isArray(preservedColleagues) && preservedColleagues.length){
      const idSet = new Set(newState.colleagues.map(c => c.id));
      preservedColleagues.forEach(c => {
        let cid = c.id;
        if(idSet.has(cid)){
          let suffix = 1;
          while(idSet.has(`${cid}-${suffix}`)) suffix++;
          cid = `${cid}-${suffix}`;
        }
        idSet.add(cid);
        const clone = Object.assign({}, c, { id: cid });
        newState.colleagues.push(clone);
      });
    }
    // Merge preserved managers, avoiding ID conflicts with defaults
    if(Array.isArray(preservedManagers) && preservedManagers.length){
      const idSet = new Set(newState.managers.map(m => m.id));
      preservedManagers.forEach(m => {
        let mid = m.id;
        if(idSet.has(mid)){
          let suffix = 1;
          while(idSet.has(`${mid}-${suffix}`)) suffix++;
          mid = `${mid}-${suffix}`;
        }
        idSet.add(mid);
        const clone = Object.assign({}, m, { id: mid });
        newState.managers.push(clone);
      });
    }
    // Merge preserved users (custom accounts) - duplicates by username are not allowed
    if(Array.isArray(preservedUsers) && preservedUsers.length){
      const nameSet = new Set(newState.users.map(u => (u.username||"").toLowerCase()));
      preservedUsers.forEach(u => {
        const unameLower = (u.username||"").toLowerCase();
        if(!nameSet.has(unameLower)){
          nameSet.add(unameLower);
          newState.users.push(Object.assign({}, u));
        }
      });
    }
    // Replace global state with the new state
    state = newState;
    ui = defaultUI();
    // Persist and re-render
    saveState();
    saveUI();
    renderNav();
    renderCurrentTab();
    alert('All data wiped. You can continue using the app fresh (persistent records retained).');
  });
}

/* Initial boot */
if(state.session.loggedIn){
  renderNav();
  // Always fall back to the dashboard when no tab is stored.  This ensures
  // that logged-in users land on the dashboard rather than the absence tab.
  openTab(ui.tab || "dashboard");
}
renderNav();


/* ---------- Login (override: bulletproof binding) ---------- */
(function bindLoginHard(){
  const form = document.getElementById("login-form");
  const btn  = document.getElementById("login-btn");
  const uEl  = document.getElementById("username");
  const pEl  = document.getElementById("password");
  const err  = document.getElementById("login-error");
  if(!form || !uEl || !pEl) return;

  const clearErr = ()=>{ if(err) err.style.display = "none"; };
  uEl.addEventListener("input", clearErr);
  pEl.addEventListener("input", clearErr);

  const attempt = async ()=>{
    // Show loading state on the login button while validating credentials.  Disable
    // interactions to prevent multiple submissions.
    if(btn){
      btn.disabled = true;
      btn.classList.add('loading');
    }
    const removeLoading = () => {
      if(btn){
        btn.disabled = false;
        btn.classList.remove('loading');
      }
    };
    const u = (uEl.value || "").trim();
    const p = (pEl.value || "");
    // Find matching user in custom user accounts or built-in users.  Custom users
    // can specify canDelete and canAdmin permissions.  Built-in users use the
    // role field to determine admin status.  We search custom accounts first so
    // that a user with the same username as a built-in account overrides the
    // built-in credentials.
    let match = null;
    // Determine if a custom override exists for this username
    let overrideExists = false;
    if(Array.isArray(state.users)){
      overrideExists = state.users.some(x => x.username === u);
      // Try to match against custom user credentials first
      match = state.users.find(x => x.username === u && x.password === p);
    }
    // If there is no custom override for this username, fall back to built-in
    if(!match && !overrideExists){
      const cand = USERS.find(x => x.username === u);
      const ok = cand ? await verifyPassword(cand, p) : false;
      match = ok ? cand : null;
    }
    if(!match){
      if(err) err.style.display = "block";
      // Remove loading state and re-enable button on failure
      removeLoading();
      return;
    }
    if(err) err.style.display = "none";
    // Set session information based on the matched user
    state.session.loggedIn = true;
    state.session.username = match.username;
    // Role defaults to match.role or 'user'
    state.session.role = match.role || 'user';
    // Permissions: if user object has explicit canDelete/canAdmin flags, use them;
    // otherwise derive from the built‑in user record.  Built‑in permissions
    // take precedence when no explicit override is provided in the custom
    // account.  This ensures that if a default account like ACETEST is
    // granted delete privileges in the built‑in user table, those
    // privileges persist even when a custom user record exists in
    // localStorage without a canDelete flag.  We also elevate canAdmin
    // privileges from the built‑in account if necessary.  See also
    // USERS definition near the top of this file.
    const builtMatch = USERS.find(x => x.username === (match && match.username));
    // Derive delete permission from either custom record or built‑in record
    const allowDelete = (match && match.canDelete) || (builtMatch && builtMatch.canDelete);
    state.session.canDelete = !!allowDelete;
    // Derive admin permission from explicit flag, role, or built‑in admin flag/role
    const allowAdmin = (match && match.canAdmin) || (match && match.role === 'admin') ||
                       (builtMatch && (builtMatch.canAdmin || builtMatch.role === 'admin'));
    state.session.canAdmin = !!allowAdmin;
    // If logging in as the ACETEST account, always elevate to admin and
    // delete permissions.  Even if a custom override exists with limited
    // privileges, this ensures the account retains full control.  Note that
    // canAdmin and canDelete are explicitly set here rather than relying
    // solely on built‑in definitions.
    // Default to locked admin mode on login; certain accounts may override below.
    state.session.adminUnlocked = false;
    if (state.session.username === 'ACETEST') {
      state.session.canDelete = true;
      state.session.canAdmin  = true;
      // Automatically unlock admin mode for ACETEST so they can access
      // Admin and Settings tabs without re-entering credentials.
      state.session.adminUnlocked = true;
    }
    // Expand or collapse the Data & Admin navigation group based on admin privileges.  If the
    // user has canAdmin permission or a role of admin, show the Data & Admin section by
    // default. Otherwise collapse it.  This makes it easier for admins to find the
    // Admin tab without manually expanding the group.  We modify the UI groups and
    // persist the UI using saveUI.
    if(ui && ui.groups){
      ui.groups.dataadmin = !!(state.session.canAdmin || state.session.role === 'admin');
    }
    saveState();
    // After login, always navigate to the dashboard.  Override any stored tab
    // to comply with the requirement that the user be directed to the Dashboard
    // after signing in.  Persist this to the UI state.
    ui.tab = 'dashboard';
    saveUI && saveUI();
    // Persist session in sessionStorage
    sessionStorage.setItem(LS_SESSION, JSON.stringify(state.session));
    applySession();
    renderNav();
    openTab('dashboard');
    // Remove loading state once navigation has been triggered
    removeLoading();
  };

  // Prevent any default submit navigation (this is what was clearing fields)
  form.addEventListener("submit", async (e)=>{
    e.preventDefault();
    e.stopPropagation();
    await attempt();
    return false;
  });

  if(btn){
    btn.addEventListener("click", async (e)=>{
      e.preventDefault();
      e.stopPropagation();
      await attempt();
      return false;
    });
  }

  // Enter key on either field triggers login without form navigation
  [uEl,pEl].forEach(el=>{
    el.addEventListener("keydown", async (e)=>{
      if(e.key==="Enter"){
        e.preventDefault();
        e.stopPropagation();
        await attempt();
        return false;
      }
    });
  });
})();


</script>

  <!-- Datalist for time inputs: provides 15-minute increment options for manual entry -->
  <datalist id="timeOptions">
    <option value="00:00"></option>
    <option value="00:15"></option>
    <option value="00:30"></option>
    <option value="00:45"></option>
    <option value="01:00"></option>
    <option value="01:15"></option>
    <option value="01:30"></option>
    <option value="01:45"></option>
    <option value="02:00"></option>
    <option value="02:15"></option>
    <option value="02:30"></option>
    <option value="02:45"></option>
    <option value="03:00"></option>
    <option value="03:15"></option>
    <option value="03:30"></option>
    <option value="03:45"></option>
    <option value="04:00"></option>
    <option value="04:15"></option>
    <option value="04:30"></option>
    <option value="04:45"></option>
    <option value="05:00"></option>
    <option value="05:15"></option>
    <option value="05:30"></option>
    <option value="05:45"></option>
    <option value="06:00"></option>
    <option value="06:15"></option>
    <option value="06:30"></option>
    <option value="06:45"></option>
    <option value="07:00"></option>
    <option value="07:15"></option>
    <option value="07:30"></option>
    <option value="07:45"></option>
    <option value="08:00"></option>
    <option value="08:15"></option>
    <option value="08:30"></option>
    <option value="08:45"></option>
    <option value="09:00"></option>
    <option value="09:15"></option>
    <option value="09:30"></option>
    <option value="09:45"></option>
    <option value="10:00"></option>
    <option value="10:15"></option>
    <option value="10:30"></option>
    <option value="10:45"></option>
    <option value="11:00"></option>
    <option value="11:15"></option>
    <option value="11:30"></option>
    <option value="11:45"></option>
    <option value="12:00"></option>
    <option value="12:15"></option>
    <option value="12:30"></option>
    <option value="12:45"></option>
    <option value="13:00"></option>
    <option value="13:15"></option>
    <option value="13:30"></option>
    <option value="13:45"></option>
    <option value="14:00"></option>
    <option value="14:15"></option>
    <option value="14:30"></option>
    <option value="14:45"></option>
    <option value="15:00"></option>
    <option value="15:15"></option>
    <option value="15:30"></option>
    <option value="15:45"></option>
    <option value="16:00"></option>
    <option value="16:15"></option>
    <option value="16:30"></option>
    <option value="16:45"></option>
    <option value="17:00"></option>
    <option value="17:15"></option>
    <option value="17:30"></option>
    <option value="17:45"></option>
    <option value="18:00"></option>
    <option value="18:15"></option>
    <option value="18:30"></option>
    <option value="18:45"></option>
    <option value="19:00"></option>
    <option value="19:15"></option>
    <option value="19:30"></option>
    <option value="19:45"></option>
    <option value="20:00"></option>
    <option value="20:15"></option>
    <option value="20:30"></option>
    <option value="20:45"></option>
    <option value="21:00"></option>
    <option value="21:15"></option>
    <option value="21:30"></option>
    <option value="21:45"></option>
    <option value="22:00"></option>
    <option value="22:15"></option>
    <option value="22:30"></option>
    <option value="22:45"></option>
    <option value="23:00"></option>
    <option value="23:15"></option>
    <option value="23:30"></option>
    <option value="23:45"></option>
  </datalist>


<!-- Additional enhancements: search, quick add, breadcrumb, recent colleagues, toast, keyboard shortcuts -->
<script>
// Mapping of tab keys to breadcrumb paths.  Update this as new tabs are added.
const BREADCRUMB_MAP = {
  dashboard: 'Dashboard',
  absence: 'Attendance & Welfare > Absence',
  partshift: 'Attendance & Welfare > Part Shift',
  medical: 'Attendance & Welfare > Medical Reports',
  restrictions: 'Attendance & Welfare > Authorised restrictions',
  flexible: 'Attendance & Welfare > Flexible leave',
  ihc: 'Attendance & Welfare > IHC process',
  rehab: 'Attendance & Welfare > Rehabilitations',
  illhealth: 'Attendance & Welfare > Ill Health Leave',
  bereavement: 'Attendance & Welfare > Bereavement',
  awol: 'Attendance & Welfare > AWOL',
  medays: 'Attendance & Welfare > Me Days',
  latertw: 'Attendance & Welfare > Late RTW',
  investigations: 'Conduct > Investigations',
  warnings: 'Conduct > Warnings',
  da: 'Conduct > D&A',
  positiveRoc: 'Conduct > Positive ROC',
  colleagues: 'People > Colleagues',
  upcoming: 'People > Upcoming actions',
  completed: 'People > Completed actions',
  admin: 'Data and Admin > Admin',
  settings: 'Data and Admin > Settings'
};

// Update the breadcrumb UI based on the current tab.
function updateBreadcrumb(tab){
  const bcEl = document.getElementById('breadcrumb');
  if(!bcEl) return;
  const text = BREADCRUMB_MAP[tab] || '';
  bcEl.textContent = text;
}

// Update the last updated indicator.  This resets the timestamp each time
// renderCurrentTab is called and updates every minute.
let _lastUpdatedTimer;
function updateLastUpdated(){
  const el = document.getElementById('last-updated');
  if(!el) return;
  const setTimestamp = () => {
    el.textContent = 'Updated ' + new Date().toLocaleTimeString('en-GB', {hour:'2-digit', minute:'2-digit'});
  };
  setTimestamp();
  if(_lastUpdatedTimer) clearInterval(_lastUpdatedTimer);
  _lastUpdatedTimer = setInterval(setTimestamp, 60000);
}

// Add a colleague to the recent list and update nav.  Maintains uniqueness and
// limits to 5 entries.
function addRecentColleague(colId){
  if(!state.recentColleagues) state.recentColleagues = [];
  // remove if exists
  state.recentColleagues = state.recentColleagues.filter(x => x !== colId);
  state.recentColleagues.unshift(colId);
  if(state.recentColleagues.length > 5) state.recentColleagues.pop();
  saveState();
  updateRecentColsNav();
}

// Render recently viewed colleagues in sidebar.  Clicking opens history.
function updateRecentColsNav(){
  const ul = document.getElementById('recent-col-nav');
  // If there is no target element or no recent colleagues, nothing to render
  if(!ul || !Array.isArray(state.recentColleagues) || state.recentColleagues.length === 0){
    if(ul) ul.innerHTML = '';
    return;
  }
  // Use a safe copy of the colleagues list.  When state.colleagues is undefined
  // (e.g. before records load), default to an empty array to avoid runtime
  // errors.  This prevents attempts to access .find on undefined and allows the
  // page to continue rendering normally even when the colleagues list has not
  // yet been populated.
  const colleagues = Array.isArray(state.colleagues) ? state.colleagues : [];
  // Generate list items based on recent colleague IDs.  For any ID not
  // currently present in the colleagues array, fall back to displaying the
  // raw ID to ensure a label is always shown.
  const items = state.recentColleagues.map(colId => {
    const match = colleagues.find(x => x.id === colId);
    const name = match ? match.name : colId;
    return `<li><button data-col-id="${escapeHtml(colId)}">${escapeHtml(name)}</button></li>`;
  }).join('');
  ul.innerHTML = items;
  // Attach click handlers after rendering.  Each button will call
  // addRecentColleague to update the list (moving it to the front) and then
  // open the colleague history modal.  Use event delegation rather than
  // direct assignment to avoid accumulating duplicate listeners on re-renders.
  ul.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
      const colId = btn.getAttribute('data-col-id');
      if(colId){
        addRecentColleague(colId);
        openColProfileModal(colId);
      }
    });
  });
}

// Set up global search to filter colleagues.  Shows dropdown suggestions and
// opens colleague history on selection.
function setupGlobalSearch(){
  const searchInput = document.getElementById('global-search');
  const resultsDiv = document.getElementById('search-results');
  if(!searchInput || !resultsDiv) return;
  searchInput.addEventListener('input', () => {
    const q = searchInput.value.trim().toLowerCase();
    if(!q){
      resultsDiv.style.display = 'none';
      resultsDiv.innerHTML = '';
      return;
    }
    const matches = state.colleagues.filter(c => {
      return c.name.toLowerCase().includes(q) || c.id.toLowerCase().includes(q);
    }).slice(0, 6);
    if(matches.length === 0){
      resultsDiv.innerHTML = '<div style="padding:6px 10px;">No results</div>';
    }else{
      resultsDiv.innerHTML = matches.map(c => `<button data-col-id="${escapeHtml(c.id)}"><strong>${escapeHtml(c.name)}</strong> <span class="muted">(${escapeHtml(c.id)})</span></button>`).join('');
    }
    resultsDiv.style.display = 'block';
    // Add click handlers
    resultsDiv.querySelectorAll('button').forEach(btn => {
      btn.addEventListener('click', (ev) => {
        const id = btn.getAttribute('data-col-id');
        if(id){
          addRecentColleague(id);
          openColProfileModal(id);
        }
        searchInput.value = '';
        resultsDiv.style.display = 'none';
      });
    });
  });
  // Hide results when clicking outside
  document.addEventListener('click', (ev) => {
    const t = ev.target;
    if(!searchInput.contains(t) && !resultsDiv.contains(t)){
      resultsDiv.style.display = 'none';
    }
  });
}

// Set up quick add menu for creating new records.  Binds click events to
// respective modal openers.
function setupQuickAdd(){
  const btn = document.getElementById('quick-add-btn');
  const menu = document.getElementById('quick-add-menu');
  if(!btn || !menu) return;
  const toggleMenu = () => {
    const isOpen = menu.style.display === 'flex';
    menu.style.display = isOpen ? 'none' : 'flex';
  };
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleMenu();
  });
  // Hide menu on outside click
  document.addEventListener('click', (ev) => {
    if(!menu.contains(ev.target) && ev.target !== btn){
      menu.style.display = 'none';
    }
  });
  // Allow the Quick Add label itself to toggle the menu.  Users can click either the
  // plus icon or the adjacent text to open/close the menu.
  const labelEl = document.getElementById('quick-add-label');
  if(labelEl){
    labelEl.addEventListener('click', (ev) => {
      ev.stopPropagation();
      toggleMenu();
    });
  }
  // Bind actions for the Quick Add menu.  Investigation and Warning have been replaced
  // with Part Shift and Me Day.  Hide the menu after invoking the appropriate modal.
  const absenceBtn = document.getElementById('qa-absence');
  const partShiftBtn = document.getElementById('qa-partshift');
  const meDayBtn = document.getElementById('qa-meday');
  if(absenceBtn) absenceBtn.addEventListener('click', () => { menu.style.display = 'none'; openAbsenceModal(); });
  if(partShiftBtn) partShiftBtn.addEventListener('click', () => { menu.style.display = 'none'; openPartShiftModal(); });
  if(meDayBtn) meDayBtn.addEventListener('click', () => { menu.style.display = 'none'; openMeDayModal(); });
}

// Show toast message with optional undo callback.  If undo callback is provided
// a clickable link will appear.  Toasts disappear after 8 seconds unless
// clicked.
function showToast(message, undoCallback){
  const container = document.getElementById('toast-container');
  if(!container) return;
  const div = document.createElement('div');
  div.className = 'toast';
  // Insert a simple icon at the start of the toast.  This uses a
  // checkmark to indicate success.  Additional types could be
  // supported in future by passing an optional type and switching
  // the icon accordingly.
  const icon = document.createElement('span');
  icon.className = 'toast-icon';
  icon.textContent = '✓';
  div.appendChild(icon);
  const msgSpan = document.createElement('span');
  msgSpan.className = 'toast-msg';
  msgSpan.textContent = message;
  div.appendChild(msgSpan);
  if(typeof undoCallback === 'function'){
    const undo = document.createElement('span');
    undo.className = 'toast-undo';
    undo.textContent = 'Undo';
    undo.addEventListener('click', () => {
      undoCallback();
      if(container.contains(div)){
        container.removeChild(div);
      }
    });
    div.appendChild(undo);
  }
  container.appendChild(div);
  // Auto-hide after 8 seconds
  setTimeout(() => {
    if(container.contains(div)){
      container.removeChild(div);
    }
  }, 8000);
}

// Record an action in the audit trail. This helper captures who performed an action,
// what entity it affected, and when. It keeps the audit trail bounded to a
// reasonable size to prevent unbounded growth. The calling code should pass
// in the action (e.g. "delete", "create", "update"), the entity type (e.g.
// "warning", "absence"), the record id, the associated colleague id if any, and
// optional details. If the auditTrail array does not exist it will be created.
function logAudit(action, entity, recordId, colleagueId, details){
  try{
    if(!state.auditTrail) state.auditTrail = [];
    const user = (state.session && state.session.username) ? state.session.username : "anonymous";
    const fbUid = (state.session && state.session.firebaseUid) ? state.session.firebaseUid : null;
    const fbEmail = (state.session && state.session.firebaseEmail) ? state.session.firebaseEmail : null;
    const entry = {
      id: uid(),
      ts: new Date().toISOString(),
      user: user,
      action: action,
      entity: entity,
      recordId: recordId,
      colleagueId: colleagueId || null,
      details: details || "",
      firebaseUid: fbUid,
      firebaseEmail: fbEmail
    };
    // Add new entry to the start of the list
    state.auditTrail.unshift(entry);
    // Trim to at most 500 entries
    if(state.auditTrail.length > 500){
      state.auditTrail = state.auditTrail.slice(0, 500);
    }
    // Persist immediately so the record is not lost if the app is closed quickly
    saveState();
  }catch(e){
    console.warn("Audit log failed", e);
  }
}

// Generic helper to delete a record from a given list with confirmation, audit logging
// and undo support. The listName must correspond to a property on the state object.
// rec is the record object to remove. label is a human‑friendly label used in prompts
// and toast messages (e.g. "warning record"). afterFn is an optional callback that
// refreshes the UI after the list has been modified.
function handleDeleteRecord(listName, rec, label, afterFn){
  // Ensure the user has permission to delete
  if(!(state.session && (state.session.canDelete || state.session.role === 'admin'))){
    alert("You do not have permission to delete.");
    return;
  }
  if(!rec) return;
  // Confirmation prompt
  const msg = "Delete this " + label.toLowerCase() + "?";
  if(!confirm(msg)) return;
  const arr = state[listName];
  if(!Array.isArray(arr)) return;
  const index = arr.findIndex(x => x.id === rec.id);
  if(index < 0) return;
  // Remove the record from the state
  const removed = arr.splice(index, 1)[0];
  // Log the action
  try{
    logAudit("delete", listName, removed.id, removed.colleagueId, label);
  }catch(e){
    console.warn("Failed to log audit for deletion", e);
  }
  // Persist changes
  saveState();
  // Refresh UI after deletion
  if(typeof afterFn === "function") afterFn();
  // Show toast with undo callback
  showToast(label.charAt(0).toUpperCase() + label.slice(1) + " deleted", () => {
    try{
      const targetArr = state[listName];
      if(Array.isArray(targetArr)){
        targetArr.splice(index, 0, removed);
        saveState();
      }
    }catch(e){
      console.warn("Undo restore failed", e);
    }
    if(typeof afterFn === "function") afterFn();
  });
}

// Setup keyboard shortcuts.  Slash focuses search; N toggles quick add; Esc closes modals.
function setupKeyboardShortcuts(){
  document.addEventListener('keydown', (ev) => {
    // Determine which element currently has focus for shortcut conditions.  Use
    // ev.target when available (the element that received the keydown), falling
    // back to document.activeElement.  This avoids race conditions when the
    // activeElement becomes body during tab re-renders.
    const focusEl = ev.target || document.activeElement;
    const tag = focusEl && focusEl.tagName ? focusEl.tagName.toLowerCase() : '';
    // Do not trigger shortcuts when focus is inside an input or textarea except slash for search
    if(tag === 'input' || tag === 'textarea'){
      // slash can still focus global search if not meta/ctrl pressed
      if(ev.key === '/' && !ev.ctrlKey && !ev.metaKey){
        ev.preventDefault();
        const gs = document.getElementById('global-search');
        if(gs){ gs.focus(); }
      }
      return;
    }
    // Slash focuses global search when not in input
    if(ev.key === '/' && !ev.ctrlKey && !ev.metaKey){
      ev.preventDefault();
      const gs = document.getElementById('global-search');
      if(gs){ gs.focus(); }
    }
    // Ctrl+N or Cmd+N (Mac) toggles the Quick Add menu when focus is not inside an input/textarea.
    // A modifier key is required to avoid interfering with typing 'n' in search boxes.
    if(ev.key.toLowerCase() === 'n' && (ev.ctrlKey || ev.metaKey)){
      ev.preventDefault();
      const menu = document.getElementById('quick-add-menu');
      if(menu){
        if(menu.style.display === 'flex'){
          menu.style.display = 'none';
        }else{
          menu.style.display = 'flex';
        }
      }
    }
    // Esc closes quick add and search results
    if(ev.key === 'Escape'){
      const menu = document.getElementById('quick-add-menu');
      if(menu) menu.style.display = 'none';
      const results = document.getElementById('search-results');
      if(results) results.style.display = 'none';
      // Also close modals if open
      try{ closeModal(); }catch(e){}
    }
  });
}

// Initialise enhancements: update breadcrumb, last updated, search, quick add,
// recent colleagues, keyboard shortcuts, and override certain functions.
function setupEnhancements(){
  // Update nav for recently viewed colleagues on initial load.  Subsequent
  // calls to renderNav() will automatically update the recent list (see
  // patched renderNav).  We do not override renderNav here to avoid
  // interfering with default navigation behaviour.
  updateRecentColsNav();

  // Breadcrumb and last-updated indicators are updated from within
  // renderCurrentTab().  Navigation click handlers are bound in the core
  // script, so we avoid re-binding them here to prevent duplicate listeners
  // or unexpected behaviour.
  // When a colleague name is clicked, add to recent list
  const origColHistoryHandler = document.addEventListener;
  // Already global click handler calls openColHistoryModal. We'll override to add recent colleague
  document.addEventListener('click', function(ev){
    const target = ev.target.closest && ev.target.closest('.col-link');
    if(target){
      const colId = target.getAttribute('data-col-id');
      if(colId){
        addRecentColleague(colId);
      }
    }
  }, true);
  // Setup search and quick add and keyboard shortcuts
  setupGlobalSearch();
  setupQuickAdd();
  // Removed keyboard shortcuts to prevent interference with log inputs.  If shortcuts
  // are desired in the future, call setupKeyboardShortcuts() here.
  // setupKeyboardShortcuts();

  // Navigation click handlers are registered globally outside of
  // setupEnhancements().  This avoids duplicating listeners and ensures
  // navigation remains functional even if this function is not invoked.

  // NOTE: Navigation click handlers are attached in the main script to each
  // button with a data-tab attribute.  Previously, we added a delegated
  // click listener on the sidebar here as a safety net, but it caused
  // navigation conflicts after other enhancements were introduced.  Since
  // setupEnhancements now runs after the core scripts have been loaded and
  // navigation bindings are established, we no longer rebind navigation
  // clicks here.  This avoids duplicating or overriding the original
  // event listeners, ensuring the built‑in openTab() logic is used for
  // all tab changes.
  // Initial breadcrumb and last updated when app starts
  updateBreadcrumb(ui.tab);
  updateLastUpdated();

  // Ensure the currently selected tab is rendered after enhancements are
  // initialised.  Some navigation bindings may not trigger at first load
  // (for example, when the page is refreshed while already logged in).  By
  // explicitly calling renderCurrentTab() here, we guarantee that the
  // content area is populated with the correct view corresponding to the
  // current UI state.  Without this call, the content panel could appear
  // empty until the user clicks a navigation item.
  try {
    renderCurrentTab();
  } catch (e) {
    console && console.error && console.error(e);
  }
}

// Run enhancements immediately if they have not yet been initialised.  This is
// necessary because setupEnhancements() is defined in a separate script tag
// that may load after applySession() has already executed.  When the user
// reloads the page while still logged in, applySession runs before this
// function exists and therefore cannot invoke it.  This block ensures
// setupEnhancements() executes once when the script defining it has loaded.
try {
  if (typeof setupEnhancements === 'function' &&
      state && state.session && state.session.loggedIn &&
      !window.__aceEnhancementsInit) {
    setupEnhancements();
    window.__aceEnhancementsInit = true;
  }
} catch (e) {
  console && console.error && console.error(e);
}

</script>

</body>
</html>
